<h1>Типизированные хуки</h1>
<p><em>React</em> <em>api</em> насчитывает десять предопределенных хуков большинство которых являются универсальными. Каждый из них будет рассмотрен по отдельности. Кроме этого данная тема расскроет способ определения пользовательских хуков с учетом последних возможностей <em>TypeScript</em>.</p><section id="Predopredelennye-huki" name="Предопределенные хуки" class="subchapter">

            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Predopredelennye-huki" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Предопределенные хуки
            </h2>
        
<p>Рассмотрение данной темы стоит начать с самого частоприменяемого универсального хука <code class="inline-code">useState&#x3C;T>(initialState): [state, dispatch]</code> параметр типа которого представляет определяемое им состояние. В случаях когда при вызове универсальной функции <code class="inline-code">useState&#x3C;T>(initialState)</code> аргумент типа не устанавливается, то тип значения будет выведен на основе аргумента функции обобзначаемым как <code class="inline-code">initialState</code>. Это в свою очередь означает что при отсутствии инициализационного значения (вызов функции <code class="inline-code">useState</code> без значения) или его временном замещении значением принадлежащим к другому типу (например объектный тип замещается значением <code class="inline-code">null</code>), или частичном значении (объектный тип определяющий лишь часть своих членов) изменить его в будущем с помощью функции обобзначаемой <code class="inline-code">dispatch</code> бедет невозможно поскольку она при определении также ассоциируется с выведенным на основе <code class="inline-code">initialState</code> типом.  </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                              <span class="hljs-comment">/**[0][1] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useState();
    dispatch(<span class="hljs-number">0</span>); <span class="hljs-comment">// Error -> type 0 is not type undefined</span>

    <span class="hljs-comment">/**
     * Поскольку отсутствие initialState [1] не было
     * компенсированно аругументом типа [0] невозможно
     * установит новое значение с помощью функции dispatch
     * если оно принадлежит к типу отличному от выведенного
     * в момент определения.
     */</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">const</span> B: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                               <span class="hljs-comment">/**[0][1] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useState(<span class="hljs-literal">null</span>);
    dispatch({ a: <span class="hljs-number">0</span> }); <span class="hljs-comment">// Error -> type {a: number} is not type null</span>

    <span class="hljs-comment">/**
    * Поскольку initialState [1] принадлежит к типу null
    * и отсутствует уточнение типа состояния при помощи
    * аргумента типа [0], то будет невозможно установить новое
    * значение с помощью функции dispatch если оно принадлежит
    * к типу отличному от выведенного в момент определения.
    */</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
<span class="hljs-keyword">const</span> С: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                               <span class="hljs-comment">/**[0] [1] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useState({a: <span class="hljs-number">0</span>});
    dispatch({ a: <span class="hljs-number">0</span>, b: <span class="hljs-string">``</span> }); <span class="hljs-comment">// Error -> type {a: number, b: string} is not type {a: number}</span>

    <span class="hljs-comment">/**
    * Поскольку initialState [1] представляет из себя лишь 
    * часть от предполагаемого типа и при этом отсутствует
    * уточнение типа состояния при помощи
    * аргумента типа [0], то будет невозможно установить новое
    * значение с помощью функции dispatch если оно принадлежит
    * к типу отличному от выведенного в момент определения.
    */</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>В подобных случаях необходимо уточнить тип к которому принадлежит состояние при помощи аргумента типа. Единственное нужно помнить, что несмотря на уточнение типа при отутствуии <code class="inline-code">initialState</code> состояние будет принадлежать к объединению <code class="inline-code">T | undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> [state, dispatch] = useState&#x3C;<span class="hljs-built_in">number</span>>();
    dispatch(<span class="hljs-number">0</span>); <span class="hljs-comment">// Ok</span>
    state; <span class="hljs-comment">// number | undefined</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">const</span> B: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                                              <span class="hljs-comment">/**[*] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useState&#x3C;{a: <span class="hljs-built_in">number</span>} | <span class="hljs-literal">null</span>>(<span class="hljs-literal">null</span>);
    dispatch({ a: <span class="hljs-number">0</span> }); <span class="hljs-comment">// Ok</span>
    state; <span class="hljs-comment">// {a: number} | null</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
<span class="hljs-keyword">const</span> С: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                                             <span class="hljs-comment">/**[*] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useState&#x3C;{a: <span class="hljs-built_in">number</span>; b?: <span class="hljs-built_in">string</span>;}>({a: <span class="hljs-number">0</span>});
    dispatch({ a: <span class="hljs-number">0</span>, b: <span class="hljs-string">``</span> }); <span class="hljs-comment">// Ok</span>
    state; <span class="hljs-comment">// {a: number; b?: string | undefined}</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * [*] конкретизация типа
 */</span></code></pre>
<p>Все описанные случаи так или иначе предполагают дополнительные проверки на существование значения, которые на практике отягащают код. Поэтому при отсутствии конкретного состояния выступающего в роли аргумента универсальной функции всегда лучше устанавливать в полной мере удовлетворяющее значение по умолчанию нежели допускать его отсутствие, замещение или частичную установку.</p>
<p>При условии что <code class="inline-code">initialState</code> представленно значением в полной мере соответствующее требуемому типу, необходимость в уточнении с помощью аргумента типа пропадает, поскольку выводу типов не составит особого труда справится с этим самостоятельно.</p>
<p>Простыми словами  аргумент типа не устанавливается аргумент типа не устанавливается тип выводится на основе аргумента самой функии.  В случае когда состояние в полной мере устанавливается в качестве единственного аргумента хука <code class="inline-code">useState&#x3C;T>()</code> необходимости в уточнении типа при помощи аргумента функционального типа не требуется. Если в качестве значения выстуупает примитив или объект все члены которого иниициализированны, выводу типов не составит труда справится с этим самостоятельно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> [state, dispatch] = useState(<span class="hljs-number">0</span>);
    dispatch(<span class="hljs-number">0</span>); <span class="hljs-comment">// Ok</span>
    state; <span class="hljs-comment">// number</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">const</span> B: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> [state, dispatch] = useState({a: <span class="hljs-number">0</span>});
    dispatch({ a: <span class="hljs-number">0</span> }); <span class="hljs-comment">// Ok</span>
    state; <span class="hljs-comment">// {a: number}</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
<span class="hljs-keyword">const</span> С: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> [state, dispatch] = useState({a: <span class="hljs-number">0</span>, b: <span class="hljs-string">``</span>});
    dispatch({ a: <span class="hljs-number">0</span>, b: <span class="hljs-string">``</span> }); <span class="hljs-comment">// Ok</span>
    state; <span class="hljs-comment">// {a: number; b: string;}</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>Следующими на очереди расположились сразу два идентичных с точки зрения типизации хука <code class="inline-code">useEffect(effect, deps?): void</code> и <code class="inline-code">useLayoutEffect(effect, deps?): void</code>, которые в качестве первого параметра ожидает функцию, а в качестве второго необязательного парметра, массив изменение элементов которого приводит к повторному вызову первого аргумента. Поскольку данные хуки не возвращают значения с которым должен взаимодействовать разработчик сложно представить сценарий в котором возникает ошибка связанная с передачей аргументов. Поэтому подробное рассмотрение и пояснение будет опущено.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}
    }, []);

    useLayoutEffect(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}
    }, []);


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>Следующий претендент на рассмотрение предназначен для работы с контекстом и представляет из себя универсальную функцию <code class="inline-code">useContext&#x3C;T>(context)</code> принимающую в качестве аргумента объект контекста, который при необходимости можно уточнить с помощью аргумнта типа. Поскольку вывод типов в состоянии самостоятельно вывести тип операясь на обязательный параметр <code class="inline-code">useState</code>, то уточнение типа с помощью аргумента типа не требуется.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {createContext, useContext, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> StringContext = createContext(<span class="hljs-string">`Is Context Value!`</span>);

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> context = useContext(StringContext <span class="hljs-comment">// let context: string</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>Уточнение с помощью аргумента типа может потребоватся только при необходимости приведения более общего типа к более конкретному, но в реальности универсальная функция этого не позволяет сделать.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {createContext, useContext, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">interface</span> T0 {
    a: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">interface</span> T1 {
    b: <span class="hljs-built_in">string</span>;
}


       <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> T2 <span class="hljs-keyword">extends</span> T0, T1 {}

<span class="hljs-comment">/**
 * [0] более общий тип
 */</span>


<span class="hljs-keyword">let</span> contextDefaultValue: T2 = {
    a: <span class="hljs-number">0</span>,
    b: <span class="hljs-string">``</span>
};

<span class="hljs-keyword">const</span> StringContext = createContext(contextDefaultValue); <span class="hljs-comment">// const StringContext: React.Context&#x3C;T2></span>

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> c0 = useContext(StringContext); <span class="hljs-comment">// let c0: T2</span>
    <span class="hljs-keyword">let</span> c1 = useContext&#x3C;T0>(StringContext); <span class="hljs-comment">// Error -> [1]</span>

    <span class="hljs-comment">/**
     * [1] при попытке приведения более общего типа
     * T2 к более конкретному типу T0 возникает ошибка ->
     * Argument of type 'Context&#x3C;T2>' is not assignable
     * to parameter of type 'Context&#x3C;T0>'.
     */</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>При возникновении потребности в подобном приведении конкретизировать необходимо идентификатор ассоциированный со значением, то есть переменную.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> c2: T0 = useContext(StringContext); <span class="hljs-comment">// Ok -> let c2: T0</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>Следующий в списке предопределенных хуков раположился <code class="inline-code">useReducer&#x3C;R>(reducer, initialState, stateInit):[state, dispatch]</code> представленный универсальной функцией имеющей множество перегрузок. Чтобы познакомится с каждым из параметров данной функции для начала нам потребуется объявить два типа описывающих состояние (<code class="inline-code">state</code>) и инициализационное состояние (<code class="inline-code">initialState</code>), которое специально будет отличатся от обычного чтобы преобразовать его нужное при помощи функции обозначенной как <code class="inline-code">stateInit</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> InitialState {
    name: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}
<span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">interface</span> State {
    name: <span class="hljs-built_in">string</span>;
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}

<span class="hljs-comment">/**
 * Объявление интерфейсов описывающих
 * состояние [1] и инициализационное состояние [0].
 * 
 */</span></code></pre>
<p> Затем определим функцию <code class="inline-code">reducer</code> для описания сигнатуры которой воспользуемся импортированным их пространства имен <em>React</em> обобщенным типом <code class="inline-code">Reducer&#x3C;S, A></code> ожидающего в качестве первого аргумента типа тип описывающий первый параметр или состояние, а в качестве второго тип описывающий второй параметр или действие\действия <code class="inline-code">Action</code>. В нашем примере второй аргумент типа <code class="inline-code">Reducer&#x3C;S, A></code> будет представлен псевдонимом для двух конкретных типов действий, перед объявлением которых стоит обратить внимание на один относящийся к ним тонкий момент. Тонкость заключается в том что функция редусер в качестве второго параметра может и в большинстве случаев будет принимать объекты действий принадлежащих к разным типам. Для их конкретизации выводу типов потребуется помощь в виде дискрименнантных полей представляющих тип действия и принадлежащих к типу представляемый элементами перечисления.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useReducer, Reducer, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">interface</span> InitialState {
    name: <span class="hljs-built_in">string</span>;
    gender: <span class="hljs-built_in">number</span>;
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}
<span class="hljs-keyword">interface</span> State {
    name: <span class="hljs-built_in">string</span>;
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}


<span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">enum</span> ActionType {
    Name = <span class="hljs-string">`name`</span>,
    Gender = <span class="hljs-string">`gender`</span>,
}

<span class="hljs-comment">/**
 * [0] определение перечисления содержащего
 * константы необходимые для конкретизации типа
 * Action.
 */</span>


            <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">interface</span> NameAction {
    <span class="hljs-keyword">type</span>: ActionType.Name; <span class="hljs-comment">/**[2] */</span>
    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">/**[3] */</span>
}
            <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">interface</span> GenderAction {
    <span class="hljs-keyword">type</span>: ActionType.Gender; <span class="hljs-comment">/**[2] */</span>
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>; <span class="hljs-comment">/**[3] */</span>
}

<span class="hljs-comment">/**
 * [1] объявление более конкретных типов действий
 * объявляющий поля name и gender [3] и дискрименантное
 * поле type [2] в качестве типа которого указан элемент
 * перечисления.
 */</span>


<span class="hljs-comment">/**[4] */</span>
<span class="hljs-keyword">type</span> Actions = NameAction | GenderAction;

<span class="hljs-comment">/**
 * [4] объявление псевдонима ссылающегося на
 * тип объединение представленный типами Action.
 */</span>


     <span class="hljs-comment">/**[5]      [6]    [7]     [8]            [9]     [10] */</span>
<span class="hljs-keyword">const</span> reducer: Reducer&#x3C;State, Actions> = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =></span> {
                <span class="hljs-comment">/**[11] */</span>
    <span class="hljs-keyword">if</span>(action.type === ActionType.Name){
                                <span class="hljs-comment">/**[12] */</span>
        <span class="hljs-keyword">return</span> {...state, name: action.name};
                      <span class="hljs-comment">/**[11] */</span>
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(action.type === ActionType.Gender){
                                <span class="hljs-comment">/**[12] */</span>
        <span class="hljs-keyword">return</span> {...state, gender: action.gender};
    }


    <span class="hljs-keyword">return</span> state;
}

<span class="hljs-comment">/**
 * [5] определение функции редюсера сигнатура
 * которой уточняется при помощи импортированного
 * из пространства имен React обобщенного типа Reducer&#x3C;S, A> [6]
 * в качестве первого параметра который получает тип представляющей
 * State [7], а в качестве второго тип объеддинение Actions [8].
 * При таком сценарии сигнатура функции в явном указании типов не нуждается [9] [10]
 * 
 * Блок кода, вхождение в который возможно в результате положительного
 * результата выволнения условия на принадлежность дискриминантного поля type
 * элементу перечисления [11], подразумевает что объект action принадлежит
 * к соответствующему типу что позволяет обращатся к присущим только ему xчленам [12]
 * 
 */</span></code></pre>
<p>Как было сказанно ранее, сигнатура редюсера не нуждается в аннотации если его тип конкретизирован с помощью <code class="inline-code">Reducer&#x3C;S, A></code>. За этим скрывается один коварный момент. Представьте ситуацию  при которой некоторое время приложение работало с состояние определяющим <code class="inline-code">name</code>, а затем было принято решение изменить его на <code class="inline-code">fullname</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// было</span>

<span class="hljs-keyword">interface</span> State {
    name: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> NameAction {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">`name`</span>;
    name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> reducer: Reducer&#x3C;State, NameAction> = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =></span> {
    <span class="hljs-keyword">if</span>(action.type === <span class="hljs-string">`name`</span>){
        <span class="hljs-keyword">return</span> {...state, name: action.name};
    }
    
    <span class="hljs-keyword">return</span> state;
}</code></pre>
<p>После того как тип описывающий состояние и действие притерпят измения, неминуемо возникнит ошибка указывающая что в действии больше нет поля <code class="inline-code">name</code>. Если впопыхах изменить лишь старый идентификатор <code class="inline-code">name</code> на новый <code class="inline-code">fullname</code>, то можно не заметить как значение ассоциированное с новым идентификатором определенным в объекте действия присваивается старому идентификатору определяемому в объекте нового состояния. К ошибке это не приведет, поскольку механизм распространения старого состояния <code class="inline-code">...state</code> наделяет новое всеми признаками необходимыми для совместимости с типом <code class="inline-code">State</code>. Старый идентификатор <code class="inline-code">name</code> в новом состоянии делает его принадлежащим к более общему типу который совместим с объектом <code class="inline-code">State</code>. Это неминуемо приводит к трудновыявляемому багу, поскольку значение поля <code class="inline-code">fullname</code> всегда будет старым.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> State {
    fullname: <span class="hljs-built_in">string</span>; <span class="hljs-comment">/**[0] */</span>
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> NameAction {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">`name`</span>;
    fullname: <span class="hljs-built_in">string</span>; <span class="hljs-comment">/**[0] */</span>
}

<span class="hljs-keyword">const</span> reducer: Reducer&#x3C;State, NameAction> = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =></span> {
    <span class="hljs-keyword">if</span>(action.type === <span class="hljs-string">`name`</span>){
                        <span class="hljs-comment">/**[1]        [2] */</span>
        <span class="hljs-keyword">return</span> {...state, name: action.fullname};
    }

    <span class="hljs-keyword">return</span> state;
}

<span class="hljs-comment">/**
 * При изменении State и NameAction [0] ошибка
 * укажет на отсутствие поля namt  в объекте
 * принадлежащего к типу NameAction [2]. Интуитивное
 * исправление лишь этой ошибки приведет к трудновыявляемому
 * багу, поскольку новое поле действия присваивается старому идентификатору [1].
 * Нужно быть внимательным, поскольку ошибки не возникнет. Причина заключается в том
 * что распространение старой версии ...state наделяет новый объект всеми необходимыми
 * характеристиками чтобы быть совместимым с типом State. Старое поле делает из нового объекта
 * значение принадлежащие к более общему типу который совместим с типом State. Поэтому
 * ошибки связанной с неверным возвращающимся значением не возникает. Тем не менее редюсер
 * никогда не изменит значение на новое. Оно всегда будет браться из предыдущего объекта состояния.
 */</span></code></pre>
<p>Возвращаясь к основному примеру осталось определить компонент в котором и будет происходить определение элементов <em>Redux</em>. Первым делом в теле компонента определеим инициализационное состояние которое с помощью функции обозначенной ранее как <code class="inline-code">stateInit</code> будет преобразованно в значение соответствующее типу необходимое редюсеру. Стоит заметить что поскольку инициализационное значение в полной мере соответствует типу <code class="inline-code">InitilState</code> аннотация типа является излишней.</p>
<p>При определении с помощью универсальной функции <code class="inline-code">useReducer()</code> элементов редакса стоит сделать акцент на отсутствии необходимости в указании аргументов типа, поскольку вывод типов будет оператся на аннотации типов параметров данного хука.</p>
<p>Осталось последовательно изменить состояние с помощбю функции <code class="inline-code">dispacth</code> вызов которой с объектами вточности соответствующих типам <code class="inline-code">*Action</code> не вызывает никаких нареканий. Вызов с аргументом не надлежащего типа приводит к возникновению ошибки что в свою очередь подтверждает надежность описанной логики сопряженной с хуком <code class="inline-code">useReducer()</code>.</p>
<pre><code class="hljs language-typescript">        <span class="hljs-comment">/**[13]               [14] */</span>
<span class="hljs-keyword">const</span> initState = <span class="hljs-function">(<span class="hljs-params">initialState: InitialState</span>) =></span> {
    <span class="hljs-keyword">let</span> {gender, ...reducerState} = initialState;

    <span class="hljs-keyword">return</span> reducerState; <span class="hljs-comment">/**[15] */</span>
};

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-comment">/** [16]       [17] */</span>
    <span class="hljs-keyword">let</span> initialState: InitialState = {
        name: <span class="hljs-string">`noname`</span>,
        age: <span class="hljs-literal">NaN</span>,
        gender:  <span class="hljs-string">`notspecified`</span>
    };
                        <span class="hljs-comment">/**[18] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useReducer(reducer, initialState, initState);

    <span class="hljs-comment">/**[19] */</span>
    dispatch({
        <span class="hljs-keyword">type</span>: ActionType.Name,
        name: <span class="hljs-string">`superuser`</span>
    });

    <span class="hljs-comment">/**[19] */</span>
    dispatch({
        <span class="hljs-keyword">type</span>: ActionType.Gender,
        gender: <span class="hljs-string">`male`</span>
    });

    <span class="hljs-comment">/**[20] */</span>
    dispatch({
        <span class="hljs-keyword">type</span>: ActionType.Gender,
        gender: <span class="hljs-string">`male`</span>,
        age: <span class="hljs-number">100</span>
    }); <span class="hljs-comment">// Error -> Object literal may only specify known properties, and 'age' does not exist in type 'GenderAction'.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * [14] определение инициализационного состояния которое будет
 * переданно в качестве единственного аргумента [14] функции initState [13]
 * предназначеной для его трансформации в состояние пригодное редюсеру [15].
 * Данная функция вместе с редюсером и инициализационным состоянием передается
 * в универсальную функцию useReducer в качестве аргументов. Стоит заметить что
 * универсальная функция useReducer определяющая элементы redux [18] 
 * в указании аргументов типане нуждается так как вывод типов отталкивается от
 * типов указанных в аннотациях элементов ожидаемых в качестве параметров.
 * 
 * [19] успешное изменение состояния.
 * [20] попытка изменить состояние с помощью объекта тип которого не совместим
 * с типом State приводит к ошибке.
 */</span></code></pre>
<p>Не будет лишним пролить свет на подход объявления типов действий в основе которых лежит базовый тип. Подобное часто требуется для так называемых <code class="inline-code">DataAction</code>, действий которые помимо поля <code class="inline-code">type</code> определяют ещё и поле <code class="inline-code">data</code> с типом <code class="inline-code">T</code>.</p>
<p>Для этого потребуется объявить два обобщенных типа. Первым объявим обобщенный тип <code class="inline-code">Action&#x3C;T></code>, единственный параметр типа которого будет указан в аннотации типа дискриминантного поля <code class="inline-code">type</code>. Вторым тип <code class="inline-code">DataAction&#x3C;T, D></code>, первый параметр типа которого будет передан при расширении в качестве аргумента типу <code class="inline-code">Action&#x3C;T></code>, а второй параметр типа будет указан в аннотации типа единственного поля <code class="inline-code">data</code>. Таким подход очень часто применяется на практике и значительно упрощает объявление типов представляющих действия предназначенных исключительно для транспортировки данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> Action&#x3C;T> {
    <span class="hljs-keyword">type</span>: T;
}
<span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">interface</span> DataAction&#x3C;T, D> <span class="hljs-keyword">extends</span> Action&#x3C;T> {
    readonly data: D;
}

<span class="hljs-comment">/**
 * Объявление обобщенных типов действий первый из которых
 * описывает обычное действие с единственным полем
 * type: T [0], а другой расширяет первый и определяет
 * поле data: D.
 */</span>



<span class="hljs-keyword">enum</span> ActionType {
    Name = <span class="hljs-string">`name`</span>,
    Gender = <span class="hljs-string">`gender`</span>,
}


<span class="hljs-keyword">interface</span> NameData {
    name: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> GenderData {
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}


          <span class="hljs-comment">/**[2]                [3]            [4]          [5] */</span>
<span class="hljs-keyword">interface</span> NameAction <span class="hljs-keyword">extends</span> DataAction&#x3C;ActionType.Name, NameData> {
}
          <span class="hljs-comment">/**[2]                [3]            [4]               [5] */</span>
<span class="hljs-keyword">interface</span> GenderAction <span class="hljs-keyword">extends</span> DataAction&#x3C;ActionType.Gender, GenderData> {
}

<span class="hljs-comment">/**
 * [2] определение конкретных действий в основе
 * которых лежит базовый обобщенный тип DataAction&#x3C;T, D> [3]
 * которому при расширении в качестве первого аргумента типа
 * устанавливается тип дискриминантного поля [4], а в качестве
 * второго тип представляющий данные [5].
 */</span>

<span class="hljs-keyword">type</span> Actions = NameAction | GenderAction;</code></pre>
<p>Осталось рассмотреть только случай предполагающий указания аргументов типа универсальной функции острая необходимость в котором потребуется при определении аргументов в момент вызова. В таком случае в качестве первого аргумента типа универсальная функция ожидает тип описывающий функцию редюсер, вторым инициализационное состояние. Кроме того прибегнуть к помощи аргументов типа может потребоватся и при других сценариях рассматриваемых на всем протежении темы посвященной хукам. Также не стоит забывать что универсальная функция <code class="inline-code">useReducer</code> имеет множество перегрузок что на практике допускает сценарии отличные от данного примера.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useReducer, Reducer, FC, useRef} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">interface</span> InitialState {
    name: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}
<span class="hljs-keyword">interface</span> State {
    name: <span class="hljs-built_in">string</span>;
    gender: <span class="hljs-string">`male`</span> | <span class="hljs-string">`female`</span> | <span class="hljs-string">`notspecified`</span>;
}


<span class="hljs-keyword">enum</span> ActionType {
    Name = <span class="hljs-string">`name`</span>,
    Gender = <span class="hljs-string">`gender`</span>,
}

<span class="hljs-keyword">enum</span> Genders {
    Male = <span class="hljs-string">`male`</span>,
    Female = <span class="hljs-string">`frmale`</span>,
    NotSpecified = <span class="hljs-string">`notspecified`</span>
}


<span class="hljs-keyword">interface</span> NameAction {
    <span class="hljs-keyword">type</span>: ActionType.Name;
    name: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> GenderAction {
    <span class="hljs-keyword">type</span>: ActionType.Gender;
    gender: Genders;
}


<span class="hljs-keyword">type</span> Actions = NameAction | GenderAction;

<span class="hljs-keyword">const</span> App: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                                            <span class="hljs-comment">/**[0]                  [1] */</span>
    <span class="hljs-keyword">let</span> [state, dispatch] = useReducer&#x3C;Reducer&#x3C;State, Actions>, InitialState>(
        <span class="hljs-function">(<span class="hljs-params">state, action</span>) =></span> state, <span class="hljs-comment">/**[2] */</span>
        {name: <span class="hljs-string">``</span>, age: <span class="hljs-number">0</span>, gender: Genders.NotSpecified}, <span class="hljs-comment">/**[3] */</span>
        (initialState) => ({name: initialState.name, gender: initialState.gender})
    );

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * Указание аргументов типа универсальной функции
 * требуется тогда, когда её аргументы определяются
 * при вызове. В таком случае первый аргумент типа
 * будет представлять описание [0] цункции редюсера [02],
 * второй инициализационного состояния [1] [3]. Также возможны
 * и другие сценарии требующией указания аргументов типа которые 
 * были затронуты ранее в теме. Кроме того универсальная функция
 * имеет множество перегрузок допускающих отличие от данного примера. 
 */</span></code></pre>
<p>Следующий на очереде универсальный хук <code class="inline-code">useCallback&#x3C;T>(callback: T, deps): T</code> рассмотрение которого можно ограничить иллюстрацией работы с ним, поскольку с ним не связанно ничего что к данному моменту могло бы вызвать хоть какой-то вопрос. Другими словами как и в остальных расмотренных ранее случаях прибегать к помощи аргументов типа следует только тогда, когда сигнатура функции обобзначенной как <code class="inline-code">callback</code> частично или вовсе не имеет указания типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useCallback, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;


<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-comment">/**[0] */</span>
    <span class="hljs-keyword">const</span> greeter = useCallback(<span class="hljs-function">(<span class="hljs-params">userName: <span class="hljs-built_in">string</span></span>) =></span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${userName}</span>!`</span>;
    }, []);

    <span class="hljs-comment">/**
     * [0] вывод типов ->
     * 
     * const greeter: (userName: string) => string
     */</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}



<span class="hljs-keyword">type</span> Decorate = <span class="hljs-function">(<span class="hljs-params">username: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">string</span>;

<span class="hljs-keyword">const</span> B: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-comment">/**[0] */</span>
    <span class="hljs-keyword">const</span> greeter = useCallback&#x3C;Decorate>( <span class="hljs-function"><span class="hljs-params">userName</span> =></span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${userName}</span>!`</span>;
    }, []);

    <span class="hljs-comment">/**
     * [0] аргумент типа ->
     * 
     * const greeter: Decorate
     */</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>Следующий хук <code class="inline-code">useRef&#x3C;T>(initialValue)</code> является универсальной функцией предназначеной для создания объекта рефы. Поскольку объект рефы возвращаемый из данного хука может служить не только для хранения ссылок на <em>React элементы</em> и <em>React компоненты</em>, но и на любые другие значения, которые к тому же могут выступать в качестве единственного аргумента, данная функция имеет множество перегрузок. И кроме этого на текущий момент с ней связан один нюанс. Но обо всем по порядку.</p>
<p>В тех случаях когда объект рефы выполняет роль хранилища не относящихся к <em>React</em> зачений, в его определении нет ничего необычного. Простыми словами, если инициализационное значение устанавливается частично или не устанавливается вовсе, то его тип необходимо конкретизировать с помощью аргумента типа. В противном случае спереложить эту работу на вывод типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useRef, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">interface</span> Data {
    a: <span class="hljs-built_in">number</span>;
    b: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                        <span class="hljs-comment">/**[0]   [1]      [2] */</span>
    <span class="hljs-keyword">let</span> dataRef = useRef&#x3C;Partial&#x3C;Data>>({a: <span class="hljs-number">0</span>}); <span class="hljs-comment">// let dataRef: React.MutableRefObject&#x3C;Partial&#x3C;Data>></span>
    <span class="hljs-keyword">let</span> a = dataRef.current.a; <span class="hljs-comment">// let a: number | undefined</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * Поскольку значение [1] установлено частично [2]
 * возникла необходисмость прибегнуть к помощи типа
 * Partial&#x3C;T> [0].
 */</span>

<span class="hljs-keyword">const</span> B: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                            <span class="hljs-comment">/**[0]        [1] */</span>
    <span class="hljs-keyword">let</span> dataRef = useRef&#x3C;Data | <span class="hljs-literal">undefined</span>>(); <span class="hljs-comment">// let dataRef: React.MutableRefObject&#x3C;Data | undefined></span>
    <span class="hljs-keyword">let</span> a = dataRef.current?.a; <span class="hljs-comment">// let a: number | undefined</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * Поскольку значение [1] вовсе не было установлено
 * аргумент типа указан как объединение включающего
 * тип undefined [0].
 */</span>

<span class="hljs-keyword">const</span> C: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
           <span class="hljs-comment">/**[0]      [1]   [2] */</span>
    <span class="hljs-keyword">let</span> dataRef = useRef({a: <span class="hljs-number">0</span>, b: <span class="hljs-string">``</span>}); <span class="hljs-comment">// let dataRef: React.MutableRefObject&#x3C;{a: number;b: string;}></span>
    <span class="hljs-keyword">let</span> a = dataRef.current.a; <span class="hljs-comment">// let a: number</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * Поскольку значение [2] в полной мере соответствует
 * предполагаемому типу необходимости в конкретизации
 * типа отпадает [0] [1].
 */</span></code></pre>
<p>Также стоит обратить внимание, что идентификатор которому в момент определения присваивается результат вызова функции <code class="inline-code">useRef()</code> в явной аннотации не нуждается.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> C: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-comment">/**[0] */</span>
    <span class="hljs-keyword">let</span> dataRef = useRef({a: <span class="hljs-number">0</span>, b: <span class="hljs-string">``</span>});

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * [0] ссылка на возвращаемый хуком useRef объект
 * в аннотации типа не нуждается. Указание аннотаций
 * типа в подобных случаях лишь отнимают время и
 * затрудняют чтение кода.
 * 
 * let dataRef: React.MutableRefObject&#x3C;{a: number;b: string;}>
 */</span></code></pre>
<p>Осталось оговорить упомянутый в самом начале нюанс который связан с объектом рефы устанавливаемому <em>React элементу</em>. Дело в том что декларация <em>React элементов</em> , в частности поля <code class="inline-code">ref</code>, аннотирована устаревшим типом, который не совместим с типом значения получаемого в результате вызова хука <code class="inline-code">useRef()</code>. К тому же уточнение типа в аннотации идентификатора или с помощью аргументов типа универсальной функции с данной проблемой справится не помогут. Единственное решение явное приведение к типу <code class="inline-code">RefObject&#x3C;T></code> возвращаемое хуком значение с помощью оператора <code class="inline-code">as</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useRef, FC, RefObject} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-comment">// let formRef: RefObject&#x3C;HTMLFormElement> | null = useRef(); // Error</span>
    <span class="hljs-comment">// let formRef = useRef&#x3C;RefObject&#x3C;HTMLFormElement> | null>(); // Error</span>
    <span class="hljs-keyword">let</span> formRef = useRef() <span class="hljs-keyword">as</span> RefObject&#x3C;HTMLFormElement> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ok</span>


    <span class="hljs-keyword">return</span> &#x3C;form ref={formRef}>&#x3C;<span class="hljs-regexp">/form>
}</span></code></pre>
<p>Более подробно с данным хуком можно познакомиться в главе посвященной рефам.</p>
<p>Следующий на очереди хук <code class="inline-code">useImperativeHandle&#x3C;T, R>(ref: Ref&#x3C;T>, apiFactory() => R): void</code> предназначенный для присваивания объекта выступающего в роли открытой части <em>api</em> функционального компонента. В тех случаях когда закрытая часть <em>api</em> отличается от закрытой, универсальная функция нуждается в уточнении этого при помощи аргументов типа. В остальных случах как всегода рекомендуется поручить эту работу выводу типов. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {ForwardRefRenderFunction, RefObject, useRef, useImperativeHandle, FC, forwardRef} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">interface</span> FormProps {

}

<span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> PublicFormApi {
    a: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
}
<span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">interface</span> PrivateFormApi <span class="hljs-keyword">extends</span> PublicFormApi {
    b: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">/**
 * [0] объявление типа представляющего открытую часть
 * api комопнента, которую будет расширять объявленный
 * позже тип описывающий его закрытую часть [1].
 */</span>


 <span class="hljs-comment">/**
  * 
  * [!] не обращать внимание на код
  * помеченный восклицательным знаком,
  * поскольку данные участи кода будут
  * подробно рассмотренны в свое время.
  */</span>

                    <span class="hljs-comment">/**[!] */</span>
<span class="hljs-keyword">const</span> Form: ForwardRefRenderFunction&#x3C;PublicFormApi, FormProps> = <span class="hljs-function">(<span class="hljs-params">props, ref</span>) =></span> {
                         <span class="hljs-comment">/**[2]             [3] */</span>
    useImperativeHandle&#x3C;PublicFormApi, PrivateFormApi><span class="hljs-function">(<span class="hljs-params">ref, (<span class="hljs-params"></span>) => (<span class="hljs-params">{
        a: (<span class="hljs-params"></span>) => {},
        b: (<span class="hljs-params"></span>) => {},
    }</span>), []</span>);

    /**
     * С помощью аргументов типа указываем тип
     * открытой [2] и закрытой [3] части <span class="hljs-params">api</span> компонента.
     */ 


    <span class="hljs-params">return</span> <span class="hljs-params">null</span>;
}

        /**[!]            [!] */
<span class="hljs-params">const</span> <span class="hljs-params">FormWithRef</span> = <span class="hljs-params">forwardRef</span>(<span class="hljs-params">Form</span>);


<span class="hljs-params">const</span> <span class="hljs-params">App</span>: <span class="hljs-params">FC</span> = <span class="hljs-params">()</span> =></span> {
                        <span class="hljs-comment">/**[!] */</span>
    <span class="hljs-keyword">let</span> formRef = useRef() <span class="hljs-keyword">as</span> RefObject&#x3C;PublicFormApi>;

    formRef.current?.a(); <span class="hljs-comment">// Ok</span>
    <span class="hljs-comment">// formRef.current?.b(); // Error</span>

                     <span class="hljs-comment">/**[6] */</span>
    <span class="hljs-keyword">return</span> &#x3C;FormWithRef ref={formRef} />;
}</code></pre>
<p>Следующим на очереди хук <code class="inline-code">useMemo&#x3C;T>(factory): T</code> является универсальной функцией ожидающей в качестве первого параметра фабричную функцию вычисляющую значение тип которого можно указать с помощью аргумента типа и которое становится результатом вызова самого хука. Второй обязательный параметр принадлежит к типу массива при наличии и изменении элементов которого происходит перевычисление значения фабричной функции. Как всегда стоит упомянуть что явное указание аргумента типа универсальной функции необходимо в очень редких случаях, каждый из которых были рассмотренны на протяжении всей темы посвященной хукам. Кроме того необходимость в аннотации типа переменной не существует вовсе. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useMemo, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
            <span class="hljs-comment">/**[0]           [1] */</span>
    <span class="hljs-keyword">let</span> memoizedValue = useMemo( <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, [] ); <span class="hljs-comment">// let memoizedValue: number</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * Нет необходимости указывать аннотацию
 * типа переменной [0] и передавать аргументы
 * типа [1] универсальной функции поскольку
 * вывод типов самостоятельно справится с этой работой.
 */</span></code></pre>
<p>Следующий и последний на очереди хук <code class="inline-code">useDebugValue&#x3C;T>(data: T, format(data: T) => any): void</code> предназначенный для вывода логов в <em>devtools</em> является универсальной функцией первый параметр которой ожидает значение которое будет выведенно в консоль и которое можно форматировать с помощью функции выступающей в роли второго необязательного параметра. Вся информация имеющаяся к этому моменту и касающаяся явного указания типов в полной мере справедлива и для текущего хука.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {useDebugValue, FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                   <span class="hljs-comment">/**[0]    [1]           [2] */</span>
   useDebugValue(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-function"><span class="hljs-params">date</span> =></span> date.getMilliseconds() );

   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
* Хук принимает значение тпа Date [0]
* и затем передает его в функцию форматирования [1]
* из которой возвращается значение принадлежащее к
* типу number [2].
*/</span></code></pre>
</section><section id="Polzovatelskii-huk" name="Пользовательский хук" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Polzovatelskii-huk" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Пользовательский хук
            </h2>
        
<p>Помимо предопределенных хуков которые подробно были рассмотренны в предыдущей главе, <em>React</em> также позволяет определять пользовательские хуки, детальному рассмотрению которых будет посвящена текущая вся глава.</p>
<p>Чтобы стразу перейти к делу представьте что перед разработчиком встала задача реализовать эффект печатающегося текста с возможностью его запускать, останавливать и ставить на паузу при необходимости. Для этого потребуется рализовать пользовательский хук <code class="inline-code">usePrintText(text, interval)</code> который на вход будет принимать исходный текс и значение скорости с которой этот текст будет печатся. Поскольку печатающийся текст будет реализован за счет постепенного изменения состояния определенного внутри хука и выдоваемого наружу, начать стоит именно с описания его типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**описание объекта состояния */</span>
<span class="hljs-keyword">interface</span> TextPrintInfo {
    isDone: <span class="hljs-built_in">boolean</span>;
    status: TextPrintStatus;
    currentText: <span class="hljs-built_in">string</span>;
    sourceText: <span class="hljs-built_in">string</span>;
}</code></pre>
<p>Кроме состояние хук должен предоставлять функции выступающие в роли контролов предназначеных для управления анимацией печатанья. Поэтому вторым шагом потребуется описать тип представляющих контролы что совершенно не составит никакого труда, так как старт\пауза\стоп являются обычными функциями которые ничего не возвращают.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**описание типа контролов старт\пауза\стоп */</span>
<span class="hljs-keyword">type</span> ControlCallback = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;</code></pre>
<p>Осталось описать тип паредставляющий сам хук или если быть более точнее сигнатуры функции которой по сути является. Особое внимание стоит обратить на возвращаемый тип представленный размеченым кортежем, для которого несмотря на большое количество кода не был созда псевдоним. Такое решени было принято из-за того, что автокомплит <em>ide</em> указал бы возвращаемый тип как псевдоним, сделав тем самым подсказку малоинформативной лишив её информации доступной благодаря указанным меткам.</p>
<pre><code class="hljs language-typescript">        <span class="hljs-comment">/**[0]                                               [1] */</span>
<span class="hljs-keyword">type</span> UsePrintText = <span class="hljs-function">(<span class="hljs-params">sourceText: <span class="hljs-built_in">string</span>, interval?: <span class="hljs-built_in">number</span></span>) =></span> [
    textInfo: TextPrintInfo,
    start: ControlCallback,
    pause: ControlCallback,
    stop: ControlCallback
];

<span class="hljs-comment">/**
 * [0] тип представляющий пользовательский хук,
 * тип возвращаемого значения представлен размеченым кортежем [1]
 */</span></code></pre>
<p> Осталось лишь определить сам хук. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> TextPrintInfo {
    isDone: <span class="hljs-built_in">boolean</span>;
    status: TextPrintStatus;
    currentText: <span class="hljs-built_in">string</span>;
    sourceText: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">type</span> ControlCallback = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">type</span> UsePrintText = <span class="hljs-function">(<span class="hljs-params">sourceText: <span class="hljs-built_in">string</span>, interval?: <span class="hljs-built_in">number</span></span>) =></span> [
    textInfo: TextPrintInfo,
    start: ControlCallback,
    pause: ControlCallback,
    stop: ControlCallback
];



<span class="hljs-keyword">const</span> usePrintText: UsePrintText = <span class="hljs-function">(<span class="hljs-params">sourceText, interval = 200</span>) =></span> {
    <span class="hljs-comment">// определени состояния</span>
    <span class="hljs-keyword">let</span> [textInfo, setTextInfo] = useState({
        isDone: <span class="hljs-literal">false</span>,
        status: TextPrintStatus.Waiting,
        currentText: <span class="hljs-string">``</span>,
        sourceText,
    });


    <span class="hljs-comment">// определение контролов</span>
    <span class="hljs-keyword">const</span> start = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    }
    <span class="hljs-keyword">const</span> pause = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    }
    <span class="hljs-keyword">const</span> stop = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    }


    <span class="hljs-keyword">return</span> [textInfo, start, pause, stop];
}</code></pre>
<p>Поскольку логика работы хука не имеет никакого отношения её детального разбора не будет. Тем не менее полный код представлен и при желании испытать свои знания предлагается самостоятельно устно его прокоментировать. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">enum</span> TextPrintStatus {
    Print = <span class="hljs-string">`print`</span>,
    Waiting = <span class="hljs-string">`waiting`</span>,
    Pause = <span class="hljs-string">`pause`</span>,
    Done = <span class="hljs-string">`done`</span>
}

<span class="hljs-keyword">interface</span> TextPrintInfo {
    isDone: <span class="hljs-built_in">boolean</span>;
    status: TextPrintStatus;
    currentText: <span class="hljs-built_in">string</span>;
    sourceText: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">type</span> ControlCallback = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> UsePrintText = <span class="hljs-function">(<span class="hljs-params">sourceText: <span class="hljs-built_in">string</span>, interval?: <span class="hljs-built_in">number</span></span>) =></span> [
    textInfo: TextPrintInfo,
    start: ControlCallback,
    pause: ControlCallback,
    stop: ControlCallback
];

<span class="hljs-keyword">const</span> usePrintText: UsePrintText = <span class="hljs-function">(<span class="hljs-params">sourceText, interval = 200</span>) =></span> {
    <span class="hljs-keyword">let</span> [timeoutId, setTimeoutId] = useState(<span class="hljs-literal">NaN</span>);
    <span class="hljs-keyword">let</span> [textInfo, setTextInfo] = useState({
        isDone: <span class="hljs-literal">false</span>,
        status: TextPrintStatus.Waiting,
        currentText: <span class="hljs-string">``</span>,
        sourceText,
    });


    <span class="hljs-keyword">const</span> isDone = <span class="hljs-function"><span class="hljs-params">()</span> =></span> textInfo.currentText.length === sourceText.length;
    <span class="hljs-keyword">const</span> getNextText = <span class="hljs-function"><span class="hljs-params">()</span> =></span> textInfo.currentText.concat(sourceText.charAt(textInfo.currentText.length));

    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-keyword">if</span> (textInfo.status === TextPrintStatus.Print &#x26;&#x26; !textInfo.isDone) {
            print();
        }

    }, [textInfo]);

    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =></span> () => cancel(), []);


    <span class="hljs-keyword">const</span> print = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-keyword">let</span> timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
            setTextInfo({
                status: isDone() ? TextPrintStatus.Done : TextPrintStatus.Print,
                isDone: isDone(),
                currentText: getNextText(),
                sourceText
            });
        }, interval);

        setTimeoutId(timeoutId);
    }

    <span class="hljs-keyword">const</span> cancel = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Number</span>.isNaN(timeoutId)) {
            clearTimeout(timeoutId);
        }
    }
    <span class="hljs-keyword">const</span> start = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        setTextInfo({
            ...textInfo,
            status: TextPrintStatus.Print,
        });
    }
    <span class="hljs-keyword">const</span> pause = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        cancel();
        setTextInfo({
            ...textInfo,
            status: TextPrintStatus.Pause,
            isDone: <span class="hljs-literal">false</span>,
        });
        setTimeoutId(<span class="hljs-literal">NaN</span>);
    }
    <span class="hljs-keyword">const</span> stop = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
        cancel();
        setTextInfo({
            isDone: <span class="hljs-literal">false</span>,
            status: TextPrintStatus.Waiting,
            currentText: <span class="hljs-string">``</span>,
            sourceText
        });
        setTimeoutId(<span class="hljs-literal">NaN</span>);
    }


    <span class="hljs-keyword">return</span> [textInfo, start, pause, stop];
}



<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> [{currentText}, start, pause, stop] = usePrintText(<span class="hljs-string">`React + TypeScript = ♥`</span>);


    <span class="hljs-keyword">return</span> (
        &#x3C;>
            &#x3C;p>{currentText}&#x3C;<span class="hljs-regexp">/p>
            &#x3C;button onClick={() => start()}>start&#x3C;/</span>button>
            &#x3C;button onClick={<span class="hljs-function"><span class="hljs-params">()</span> =></span> pause()}>pause&#x3C;<span class="hljs-regexp">/button>
            &#x3C;button onClick={() => stop()}>stop&#x3C;/</span>button>
        &#x3C;<span class="hljs-regexp">/>
    )
}</span></code></pre>
</section>