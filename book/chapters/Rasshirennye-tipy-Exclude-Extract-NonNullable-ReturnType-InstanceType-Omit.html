<section id="Rasshirennye-tipy-Exclude-Extract-NonNullable-ReturnType-InstanceType-Omit" name="Расширенные типы — Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirennye-tipy-Exclude-Extract-NonNullable-ReturnType-InstanceType-Omit" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Расширенные типы — Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit
            </h2>
        
<hr>
<p>Чтобы сэкономить время разработчиков, в систему типов <em>TypeScript</em> были включены несколько часто требующихся условных типов, которые подробно будут рассмотрены в этой главе.</p>
</section><section id="Exclude" name="Exclude" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Exclude" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Exclude
            </h2>
        
<hr>
<p>В результате разрешения условный тип <code class="inline-code">Exclude&#x3C;T, U></code> будет представлять разницу типа <code class="inline-code">T</code> относительно типа <code class="inline-code">U</code>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Exclude&#x3C;T, U> = T <span class="hljs-keyword">extends</span> U ? never : T;</code></pre>
<p>В случае, если оба аргумента типа принадлежат к одному и тому же типу данных, <code class="inline-code">Exclude&#x3C;T, U></code> будет представлять тип <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v0: Exclude&#x3C;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>|object>; <span class="hljs-comment">// let v0: string|number</span>
<span class="hljs-keyword">let</span> v1: Exclude&#x3C;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>>; <span class="hljs-comment">// let v1: never</span>
<span class="hljs-keyword">let</span> v2: Exclude&#x3C;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>|<span class="hljs-built_in">boolean</span>>; <span class="hljs-comment">// let v2: string</span>

<span class="hljs-keyword">interface</span> IT0 { a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">interface</span> IT1 { a: <span class="hljs-built_in">number</span>; c: <span class="hljs-built_in">boolean</span>; }

<span class="hljs-keyword">let</span> v3: Exclude&#x3C;keyof IT0, keyof IT1>; <span class="hljs-comment">// let v3: "b"</span></code></pre>
<p>Его реальную пользу лучше всего продемонстрировать на реализации функции, которая на входе получает два разных объекта, а на выходе возвращает новый объект, состоящий из членов, присутствующих в первом объекте, но отсутствующих во втором. Аналог функции <code class="inline-code">difference</code> из широко известной библиотеки <em>lodash</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IA { a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">interface</span> IB { a: <span class="hljs-built_in">number</span>; c: <span class="hljs-built_in">boolean</span>; }

<span class="hljs-keyword">interface</span> IDifference { b: <span class="hljs-built_in">string</span>; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">difference</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params">a: T, b: U</span>): <span class="hljs-title">Pick</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">Exclude</span>&#x3C;<span class="hljs-title">keyof</span> <span class="hljs-title">T</span>, <span class="hljs-title">keyof</span> <span class="hljs-title">U</span>>> </span>{
  <span class="hljs-comment">// ... code</span>
}

<span class="hljs-keyword">let</span> a: IA = { a: <span class="hljs-number">5</span>, b: <span class="hljs-string">''</span> };
<span class="hljs-keyword">let</span> b: IB = { a: <span class="hljs-number">10</span>, c: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">let</span> v0: IDifference = difference(a, b); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: IA = difference(a, b); <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v2: IB = difference(a, b); <span class="hljs-comment">// Error</span></code></pre>
</section><section id="Extract" name="Extract" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Extract" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Extract
            </h2>
        
<hr>
<p>В результате разрешения условный тип <code class="inline-code">Extract&#x3C;T, U></code> будет представлять пересечение типа <code class="inline-code">T</code> относительно типа <code class="inline-code">U</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Extract&#x3C;T, U> = T <span class="hljs-keyword">extends</span> U ? T : never;</code></pre>
<p>Простыми словами, после разрешения <code class="inline-code">Extract&#x3C;T, U></code> будет принадлежать к типу, признаки которого присущи обоим аргументам типа. То есть, тип <code class="inline-code">Extract&#x3C;T, U></code> является противоположностью типа <code class="inline-code">Exclude&#x3C;T, U></code>. В случае, когда общие признаки отсутствуют, тип <code class="inline-code">Extract&#x3C;T, U></code> будет представлять тип <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v0 :Extract&#x3C;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>|object>; <span class="hljs-comment">// let v0: never</span>
<span class="hljs-keyword">let</span> v1 :Extract&#x3C;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>>; <span class="hljs-comment">// let v1: string | number</span>
<span class="hljs-keyword">let</span> v2 :Extract&#x3C;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>|<span class="hljs-built_in">boolean</span>>; <span class="hljs-comment">// let v2: number</span>

<span class="hljs-keyword">interface</span> IT0 { a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">interface</span> IT1 { a: <span class="hljs-built_in">number</span>; c: <span class="hljs-built_in">boolean</span>; }

<span class="hljs-keyword">let</span> v3 :Extract&#x3C;keyof IT0, keyof IT1>; <span class="hljs-comment">// let v3: "a"</span></code></pre>
<p>Условный тип <code class="inline-code">Extract&#x3C;T, U></code> стоит рассмотреть на примере реализации функции, которая принимает два разных объекта и возвращает новый объект, состоящий из членов первого объекта, которые также присутствуют и во втором объекте.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IA { a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">interface</span> IB { a: <span class="hljs-built_in">number</span>; c: <span class="hljs-built_in">boolean</span>; }

<span class="hljs-keyword">interface</span> IIntersection { a: <span class="hljs-built_in">number</span>; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params">a: T, b: U</span>): <span class="hljs-title">Pick</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">Extract</span>&#x3C;<span class="hljs-title">keyof</span> <span class="hljs-title">T</span>, <span class="hljs-title">keyof</span> <span class="hljs-title">U</span>>> </span>{
    <span class="hljs-comment">// ... code</span>
}

<span class="hljs-keyword">let</span> a: IA = { a: <span class="hljs-number">5</span>, b: <span class="hljs-string">''</span> };
<span class="hljs-keyword">let</span> b: IB = { a: <span class="hljs-number">10</span>, c: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">let</span> v0: IIntersection = intersection(a, b); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: IA = intersection(a, b); <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v2: IB = intersection(a, b); <span class="hljs-comment">// Error</span></code></pre>
</section><section id="NonNullable" name="NonNullable" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="NonNullable" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                NonNullable
            </h2>
        
<hr>
<p>Условный тип <code class="inline-code">NonNullable&#x3C;T></code> служит для исключения из типа признаков типов <code class="inline-code">Null</code> и <code class="inline-code">Undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> NonNullable&#x3C;T> = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? never : T;</code></pre>
<p>В случае, когда тип, выступающий в роли единственного аргумента типа, принадлежит только к типам <code class="inline-code">Null</code> и\или <code class="inline-code">Undefined</code>, <code class="inline-code">NonNullable&#x3C;T></code> представляет тип <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v0: NonNullable&#x3C;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>>; <span class="hljs-comment">// let v0: string</span>
<span class="hljs-keyword">let</span> v1: NonNullable&#x3C;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>>; <span class="hljs-comment">// let v1: string|number</span>
<span class="hljs-keyword">let</span> v2: NonNullable&#x3C;<span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>>; <span class="hljs-comment">// let v2: never</span></code></pre>
</section><section id="ReturnType" name="ReturnType" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="ReturnType" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                ReturnType
            </h2>
        
<hr>
<p>Условный тип <code class="inline-code">ReturnType&#x3C;T></code> служит для установления возвращаемого из функции типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ReturnType&#x3C;T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>[]) => <span class="hljs-built_in">any</span>> = T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>[]) => infer R ? R : <span class="hljs-built_in">any</span>;

<span class="hljs-keyword">let</span> v0: ReturnType&#x3C;<span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>>; <span class="hljs-comment">// let v0: void</span>
<span class="hljs-keyword">let</span> v1: ReturnType&#x3C;<span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>>; <span class="hljs-comment">// let v1: string|number</span>
<span class="hljs-keyword">let</span> v2: ReturnType&#x3C;&#x3C;T><span class="hljs-function"><span class="hljs-params">()</span> =></span> T>; <span class="hljs-comment">// let v2: {}</span>
<span class="hljs-keyword">let</span> v3: ReturnType&#x3C;&#x3C;T <span class="hljs-keyword">extends</span> U, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]><span class="hljs-function"><span class="hljs-params">()</span> =></span> T>; <span class="hljs-comment">// let v3: string[]</span>
<span class="hljs-keyword">let</span> v4: ReturnType&#x3C;<span class="hljs-built_in">any</span>>; <span class="hljs-comment">// let v4: any</span>
<span class="hljs-keyword">let</span> v5: ReturnType&#x3C;never>; <span class="hljs-comment">// let v5: never</span>
<span class="hljs-keyword">let</span> v6: ReturnType&#x3C;<span class="hljs-built_in">Function</span>>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v7: ReturnType&#x3C;<span class="hljs-built_in">number</span>>; <span class="hljs-comment">// Error</span></code></pre>
</section><section id="InstanceType" name="InstanceType" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="InstanceType" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                InstanceType
            </h2>
        
<hr>
<p>Условный тип <code class="inline-code">InstanceType&#x3C;T></code> предназначен для установления типа экземпляра.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> T {}

<span class="hljs-keyword">interface</span> IT { 
    <span class="hljs-keyword">new</span>(): T; 
}

<span class="hljs-keyword">let</span> v0: InstanceType&#x3C;<span class="hljs-keyword">typeof</span> T>; <span class="hljs-comment">// let v0: T</span>
<span class="hljs-keyword">let</span> v1: InstanceType&#x3C;IT>; <span class="hljs-comment">// let v1: never</span>
<span class="hljs-keyword">let</span> v2: InstanceType&#x3C;<span class="hljs-built_in">any</span>>; <span class="hljs-comment">// let v2: any</span>
<span class="hljs-keyword">let</span> v3: InstanceType&#x3C;never>; <span class="hljs-comment">// let v3: never</span>
<span class="hljs-keyword">let</span> v4: InstanceType&#x3C;<span class="hljs-built_in">number</span>>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v5: InstanceType&#x3C;<span class="hljs-built_in">Function</span>>; <span class="hljs-comment">// Error</span></code></pre>
</section><section id="Parameters" name="Parameters" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Parameters" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Parameters
            </h2>
        
<hr>
<p>Расширенный тип <code class="inline-code">Parameters&#x3C;T></code> предназначен для получения типов указанных в аннотации параметров функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Parameters&#x3C;T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>[]) => <span class="hljs-built_in">any</span>> = T <span class="hljs-keyword">extends</span> (...args: infer P) => <span class="hljs-built_in">any</span> ? P : never;</code></pre>
<p><code class="inline-code">Parameters&#x3C;T></code> возвращает типы параметров в виде кортежа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> f = &#x3C;T><span class="hljs-function">(<span class="hljs-params">p0:T, p1: <span class="hljs-built_in">number</span>, p2: <span class="hljs-built_in">string</span>, p3?: <span class="hljs-built_in">boolean</span>, p4: object = {}</span>) =></span> ({}); 

<span class="hljs-keyword">type</span> FunctionParams = Parameters&#x3C;<span class="hljs-keyword">typeof</span> f>; <span class="hljs-comment">// type FunctionParams = [{}, number, string, boolean?, object?]</span></code></pre>
</section><section id="ConstructorParameters" name="ConstructorParameters" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="ConstructorParameters" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                ConstructorParameters
            </h2>
        
<hr>
<p>Расширенный тип <code class="inline-code">ConstructorParameters&#x3C;T></code> предназначен для получения типов указанных в аннотации параметров конструктора.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ConstructorParameters&#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>[]) => <span class="hljs-built_in">any</span>> = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...args: infer P) => <span class="hljs-built_in">any</span> ? P : never;</code></pre>
<p><code class="inline-code">ConstructorParameters&#x3C;T></code> возвращает типы параметров в виде кортежа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Class&#x3C;T> {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p0: T, p1: <span class="hljs-built_in">number</span>, p2: <span class="hljs-built_in">string</span>, p3?: <span class="hljs-built_in">boolean</span>, p4: object = {}</span>) {}
}

<span class="hljs-keyword">type</span> ClassParams = ConstructorParameters&#x3C;<span class="hljs-keyword">typeof</span> Class>; <span class="hljs-comment">// type ClassParams = [{}, number, string, boolean?, object?]</span></code></pre>
</section><section id="Tip-Omit" name="Тип Omit" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tip-Omit" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Тип Omit
            </h2>
        
<hr>
<p>Расширенный тип <code class="inline-code">Omit&#x3C;T, K></code>предназначен для определения на основе существующего нового суженного типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.d.ts</span>

<span class="hljs-keyword">type</span> Omit&#x3C;T, K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | symbol> = { 
    [P <span class="hljs-keyword">in</span> Exclude&#x3C;keyof T, K>]: T[P];
}</code></pre>
<p>В качестве первого аргумента типа тип <code class="inline-code">Omit&#x3C;T, K></code> ожидает тип данных, из которого будут исключены признаки, связанные с ключами, переданными в качестве второго аргумента типа.</p>
<p>Простыми словами, к помощи <code class="inline-code">Omit&#x3C;T, K></code> следует прибегать в тех случаях, когда появляется потребность в определении типа, представляющего некоторую часть уже определенного в системе типов типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Person = {
    firstName: <span class="hljs-built_in">string</span>;
    lastName: <span class="hljs-built_in">string</span>;

    age: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">/**
 * Тип PersonName представляет только часть типа Person
 * 
 * type PersonName = {
 *  firstName: string;
 *  lastName: string;
 * }
 */</span>
<span class="hljs-keyword">type</span> PersonName = Omit&#x3C;Person, <span class="hljs-string">'age'</span>>; <span class="hljs-comment">// исключение признаков связанных с полем age из типа Person</span></code></pre>
</section>