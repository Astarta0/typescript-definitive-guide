<section id="Ekskurs-v-tipizaciu-Yavnaya-Neyavnaya-Tipizaciya" name="Экскурс в типизацию - Явная/Неявная Типизация" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Ekskurs-v-tipizaciu-Yavnaya-Neyavnaya-Tipizaciya" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Экскурс в типизацию - Явная/Неявная Типизация
            </h2>
        
<hr>
<p>Помимо разделения на <em>статическую</em>*динамическую<em> и </em>сильную<em>*слабую</em> типизацию, языки программирования разделяются на языки с <em>явной</em> типизацией и языки с <em>неявной</em> типизацией. </p>
</section><section id="Yavnaya-tipizaciya-explicit-typing" name="Явная типизация (explicit typing)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Yavnaya-tipizaciya-explicit-typing" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Явная типизация (explicit typing)
            </h2>
        
<hr>
<p>Язык с <em>явной типизацией</em> предполагает, что указание принадлежности к конкретному типу, при объявлении языковых элементов, возлагается на разработчика.</p>
<p>Явная типизация, за счет наличия типизированных параметров и возвращаемого типа у функций и методов, а также указания типов при объявлении переменных, свойств и полей, делает код более понятным (читабельным) и позволяет разработчикам не знакомым с кодом, быстрее включатся в процесс разработки, тем самым снижая время на модификацию программы.</p>
<p>Явная типизация,  обязывая явно указывать типы, способствует развитию у разработчика навыков необходимых при проектировании архитектуры программ.</p>
<p>В львиной доле языков с явной типизацией существует возможность указывать типы неявно.</p>
<p>Рассмотрим пример кода демонстрирующего явную типизацию. Класс <code class="inline-code">Controller</code> содержит метод <code class="inline-code">check</code>, который имеет один обязательный параметр eggs c типом массива <code class="inline-code">IEgg[ ]</code> и возвращающий тип <code class="inline-code">boolean</code>. Если бы не явно указанные типы параметров, то разработчикам пришлось бы только гадать, с чем  именно им предстоит работать. Это же относится и к возвращаемому типу.</p>
<p>В теле метода мы можем наблюдать передачу массива яиц, для валидации,
в метод <code class="inline-code">valid</code>, объекта валидатора <code class="inline-code">validator</code>, который в свою очередь возвращает результат проверки, который сохраняется в локальную переменную <code class="inline-code">isValid</code>, принадлежащую к типу <code class="inline-code">boolean</code>. Если бы переменная <code class="inline-code">isValid</code> не указывала тип при объявлении, то было бы невозможно, глядя на этот участок кода, догадаться, что же возвращает метод валид <code class="inline-code">valid</code>.</p>
<p>Разработчику впервые увидевшего этот код, или разработчику, который имел с ним дело очень давно, не составит труда, разобраться, за что отвечает данный участок кода.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Controller {
   <span class="hljs-keyword">public</span> check(eggs: IEgg[]): <span class="hljs-built_in">boolean</span> {
       <span class="hljs-keyword">const</span> isValid: <span class="hljs-built_in">boolean</span> = Validator.valid( eggs );

       <span class="hljs-keyword">return</span> isValid;
   }
}</code></pre>
<p>К языкам с явной типизацией относятся <em>С++</em>, <em>С#</em> и многие другие.</p>
</section><section id="Neyavnaya-tipizaciya-implicit-typing" name="Неявная типизация (implicit typing)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Neyavnaya-tipizaciya-implicit-typing" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Неявная типизация (implicit typing)
            </h2>
        
<hr>
<p>Язык с <em>неявной типизацией</em> при объявлении языковых элементов не требуют  от разработчика указания принадлежности к конкретному типу данных и возлагает определение типов на компилятор\интерпретатор.
За основу примера неявной типизации возьмем код из предыдущего примера
и лишим его всей атрибутики связанной с явной типизации. Как можно убедится, этот код стал занимать меньше места, а это один из нескольких доводов, которые можно услышать в пользу языков с неявной типизацией. Но на самом деле это не так.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Controller {
   check( eggs ) {
       <span class="hljs-keyword">const</span> isValid = Validator.valid( eggs );

       <span class="hljs-keyword">return</span> isValid;
   }
}</code></pre>
<p>..На практике, считается хорошим тоном, при объявлении языковых элементов
уделять особое-повышенное внимание именованию. Ведь именно от выбора
названия будет зависеть то время, которое уйдет у программиста на понимание участка кода, при отладке, рефакторинге или модернизации.</p>
<p>Те же рассуждения, в процессе которых происходит рождение более информационного названия, приводят к более детальному осмыслению кода.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> EggController {
   checkEgg( eggAll ) {
       <span class="hljs-keyword">const</span> isEggValid = EggValidator.qualityEggValid( eggAll );

       <span class="hljs-keyword">return</span> isEggValid;
   }
}</code></pre>
<p>Именно по этой причине правило именования распространяется и на языки с явной типизацией.</p>
<p>А тот факт, что неявная типизация позволяет реализовывать несложные алгоритмы с меньшими временными затратами, разбивается о возможность всех современных языков с явной типизацией с помощью вывода типов, указывать тип неявно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> EggController {
   <span class="hljs-keyword">public</span> checkEgg(eggAll: IEgg[]): <span class="hljs-built_in">boolean</span> {
       <span class="hljs-keyword">const</span> isEggValid: <span class="hljs-built_in">boolean</span> = EggValidator.qualityEggValid( eggAll );

       <span class="hljs-keyword">return</span> isEggValid;
   }
}</code></pre>
<p>К языкам с неявной типизацией относятся такие языки, как - <em>JavaScript</em>, <em>PHP</em> и другие.</p>
</section><section id="Itog" name="Итог" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itog" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итог
            </h2>
        
<p>Подведем итоги - </p>
<ul class="book__list">
<li class="book__list__item">Явная типизация возлагает указания типов на разработчика, развивая у него навыки требующиеся при проектировании программ и делает код более понятным-читаемым.</li>
<li class="book__list__item">Языки с явной типизацией, за счет вывода типов, имеют возможность указывать типы неявно.</li>
<li class="book__list__item">Неявная типизация возлагает определение типа на компилятор\интерпретатор.</li>
</ul>
</section>