<section id="Zashchitniki-Tipa" name="Защитники Типа" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Zashchitniki-Tipa" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Защитники Типа
            </h2>
        
<hr>
<p>Помимо того, что <em>TypeScript</em> имеет достаточно мощную систему выявления ошибок на этапе компиляции, разработчики не  останавливаясь на достигнутом, безостановочно работая над сведением их к нулю. Существенным шагом к достижению цели, было добавление компилятору возможности, активируемой при помощи флага <code class="inline-code">--strictNullChecks</code>, запрещающей неявные операции в которых участвует значение <code class="inline-code">null</code> и <code class="inline-code">undefined</code>. Простыми словами, компилятор научили во время анализа кода выявлять ошибки, которые могут возникнуть при выполнении операций, в которых фигурирует значения <code class="inline-code">null</code> или <code class="inline-code">undefined</code>.</p>
<p>Простейшим примером является операция получения элемента из dom-дерева, при помощи метода <code class="inline-code">querySelector</code>, который в обычном режиме (с неактивной опцией <code class="inline-code">--strictNullChecks</code>) возвращает значение, которое можно присвоить переменной с указанным типом <code class="inline-code">Element</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> stage: Element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);</code></pre>
<p>Но в строгом режиме (с активной опцией <code class="inline-code">--strictNullChecks</code>), метод <code class="inline-code">querySelector</code>, возвращает объединенный тип <code class="inline-code">Element | null</code>. Тем самым компилятор хочет напомнить разработчику, что в случае отсутствия элемента в dom-дереве, метод  <code class="inline-code">querySelector</code> возвратит <code class="inline-code">null</code>, который может привести к ошибке.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> stage: Element | <span class="hljs-literal">null</span> = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stage_clickHandler</span>(<span class="hljs-params"> event: MouseEvent </span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>Не будет лишнем напомнить, что на самом деле, метод <code class="inline-code">querySelector</code>, возвращает тип <code class="inline-code">Element | null</code>, независимо от режима. Дело в том, что в обычном режиме, тип <code class="inline-code">null</code> совместим с любыми типами. То есть, в случае отсутствия элемента в dom-дереве, операция присваивания значения <code class="inline-code">null</code> переменной с типом <code class="inline-code">Element</code>, не приведет к возникновению ошибки.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.es6.d.ts </span>
<span class="hljs-keyword">interface</span> NodeSelector {
  querySelector(selectors: <span class="hljs-built_in">string</span>): Element | <span class="hljs-literal">null</span>;
}</code></pre>
<p>Возвращаясь к примеру с получением элемента из dom-дерева стоит сказать, что если раскомментировать строчку кода, в котором происходит подписание элемента на событие, то даже в том случае, если элемент существует, все  равно возникнет ошибка на этапе компиляции. Все дело в том, что компилятор TypeScript не позволит вызвать метод <code class="inline-code">addEventListener</code> по той причине, что для него объект, на который ссылается переменная, принадлежит к типу <code class="inline-code">Element</code> ровно настолько же, насколько он принадлежит к типу <code class="inline-code">Null</code>. И это неудивительно, ведь у метода <code class="inline-code">querySelection</code> тип возвращаемого значения указан как тип объединение (<code class="inline-code">Union</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> stage: Element | <span class="hljs-literal">null</span> = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);
stage.addEventListener( <span class="hljs-string">'click'</span>, stage_clickHandler ); <span class="hljs-comment">// stage is type Element or Null?</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stage_clickHandler</span>(<span class="hljs-params"> event: MouseEvent </span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>Именно из-за этой особенности или другими словами, неоднозначности, которую вызывает тип <code class="inline-code">Union</code>, в <code class="inline-code">TypeScript</code> появился механизм, называемый защитниками типа (<code class="inline-code">Type Guards</code>).</p>
<p>Защитники типа, это правила, которые помогают выводу типов, определить суженный диапазон типов, для значения принадлежащего к типу <code class="inline-code">Union</code>. Другими словами, разработчику предоставлен механизм, позволяющий с помощью выражений, составить логические условия, проанализировав которые, вывод типов, сможет сузить диапазон типов до необходимого, для выполнения операций над значением.</p>
<p>Понятно, что ничего не понятно. Поэтому прежде чем продолжить разбирать определение по шагам, нужно рассмотреть простой пример, который поможет зафиксировать картинку в сознании.</p>
<p>Представим два класса, <code class="inline-code">Bird</code> и <code class="inline-code">Fish</code> в обоих из которых реализован метод <code class="inline-code">voice</code>. Кроме этого, в классе <code class="inline-code">Bird</code> реализован метод <code class="inline-code">fly</code>, а в классе <code class="inline-code">Fish</code>, метод <code class="inline-code">swim</code>. Далее представим функцию с единственным параметром, принадлежащему к объединению типов <code class="inline-code">Bird</code> и <code class="inline-code">Fish</code>.</p>
<p>В теле этой функции без труда получится выполнить операцию вызова метода <code class="inline-code">voice</code>, у её параметра, так как этот метод объявлен и в типе <code class="inline-code">Bird</code> и в типе <code class="inline-code">Fish</code>. Но при попытке вызвать метод <code class="inline-code">fly</code> или <code class="inline-code">swim</code>, возникает ошибка, так как эти методы не являются общими для обоих типов. Компилятор попросту находится в подвешенном состоянии и не способен самостоятельно определится.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
  <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
  <span class="hljs-keyword">public</span> voice(): <span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">class</span> Fish {
  <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
  <span class="hljs-keyword">public</span> voice(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"> animal: Bird | Fish </span>): <span class="hljs-title">void</span> </span>{
  animal.voice(); <span class="hljs-comment">// Ok</span>

  animal.fly(); <span class="hljs-comment">// Error</span>
  animal.swim(); <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Для того чтобы облегчить работу компилятору, <em>TypeScript</em> предлагает процесс,
который сужает множество типов указанных в типе <code class="inline-code">Union</code>, до заданного диапазона, а затем закрепляет его за конкретной областью кода. Таким образом, независимо от типа, к которому принадлежит значение, компилятор будет расценивать его, как если бы он принадлежал к диапазону, установленному текущей области.</p>
<p>Но прежде чем диапазон типов будет вычислен и ассоциирован с областью, разработчику необходимо составить условия, включающие в себя признаки, которые недвусмысленно указывают на принадлежность к нужным типам данных.</p>
<p>Из-за того, что анализ происходит на основе логических выражений, область, к которой применяется суженный диапазон типов данных, ограничивается областью, которая выполняется при истинности условия.</p>
<p>Стоит заметить, что от признаков зависит место в котором может находится выражение, а от типов, составляющих множество типа <code class="inline-code">Union</code>, зависит способ составления логического условия.</p>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-tipa-dannyh" name="Сужение диапазона множества типов на основе типа данных" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-tipa-dannyh" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе типа данных
            </h2>
        
<hr>
<p>В случаях, в которых для вывода типов, нужно составить условие на основе типов данных, прибегают к помощи, знакомых по <em>JavaScript</em>, операторам, <code class="inline-code">typeof</code> и <code class="inline-code">instanceof</code>.</p>
<p>К помощи оператора <code class="inline-code">typeof</code> прибегают тогда, когда хотят установить принадлежность к типам <code class="inline-code">number</code>, <code class="inline-code">string</code>, <code class="inline-code">boolean</code>, <code class="inline-code">object</code>, <code class="inline-code">function</code>, <code class="inline-code">symbol</code> или <code class="inline-code">undefined</code>.</p>
<p>Если же значение принадлежит к производному от объекта типу, то установить его принадлежность к типу данных, определяемого классом и находящегося в иерархии наследования, можно при помощи оператора <code class="inline-code">instanceof</code>.</p>
<p>Как уже было  сказано, с помощью операторов <code class="inline-code">typeof</code> и <code class="inline-code">instanceof</code> составляется условие, по которому компилятор может вычислить к какому конкретно типу или диапазону типов будет относится значение, в определяемой условием области.</p>
<p><em>Пример для оператора typeof</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ParamType = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> | object | <span class="hljs-built_in">Function</span> | symbol | <span class="hljs-literal">undefined</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params"> param: ParamType </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: number | string | boolean | object | Function | symbol | undefined</span>

  <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'number'</span> ){
      param; <span class="hljs-comment">// param: numer</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'string'</span> ){
      param; <span class="hljs-comment">// param: string</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'boolean'</span> ){
      param; <span class="hljs-comment">// param: boolean</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'object'</span> ){
      param; <span class="hljs-comment">// param: object</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'function'</span> ){
      param; <span class="hljs-comment">// param: Function</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'symbol'</span> ){
      param; <span class="hljs-comment">// param:symbol</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'undefined'</span> ){
      param; <span class="hljs-comment">// param: undefined</span>
  }

  param; <span class="hljs-comment">// param: number | string | boolean | object | Function | symbol | undefined</span>
}</code></pre>
<p><em>Пример для оператора instenceof</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) {} }
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">extends</span> Animal {}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> param: Animal | Bird | Fish | Insect </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect</span>

  <span class="hljs-keyword">if</span>( param <span class="hljs-keyword">instanceof</span> Bird ){
    param; <span class="hljs-comment">// param: Bird</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( param <span class="hljs-keyword">instanceof</span> Fish ){
    param; <span class="hljs-comment">// param: Fish</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( param <span class="hljs-keyword">instanceof</span> Insect ){
    param; <span class="hljs-comment">// param: Insect</span>
  }

  param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect</span>
}</code></pre>
<p>В случае, когда значение принадлежит к типу <code class="inline-code">Union</code>, а выражение состоит из двух операторов, <code class="inline-code">if</code> и <code class="inline-code">else</code>, значение находящиеся в операторе <code class="inline-code">else</code> будет принадлежать к диапазону типов не участвующих в условии <code class="inline-code">if</code>.</p>
<p><em>Пример для оператора typeof</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: number | string | boolean</span>

  <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'string'</span> ){
      param; <span class="hljs-comment">// param: number | string</span>
  }<span class="hljs-keyword">else</span>{
      param; <span class="hljs-comment">// param: boolean</span>
  }

  param; <span class="hljs-comment">// param: number | string | boolean</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: number | string | boolean</span>

  <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'number'</span> ){
      param; <span class="hljs-comment">// param: number</span>
  }<span class="hljs-keyword">else</span>{
      param; <span class="hljs-comment">// param: string | boolean</span>
  }

  param; <span class="hljs-comment">// param: number | string | boolean</span>
}</code></pre>
<p><em>Пример для оператора instanceof</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) {} }
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Bug <span class="hljs-keyword">extends</span> Insect {}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params">param: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Bird | Fish | Insect</span>

  <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Bird) {
    param; <span class="hljs-comment">// param: Bird</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Fish) {
    param; <span class="hljs-comment">// param: Fish</span>
  } <span class="hljs-keyword">else</span> {
    param; <span class="hljs-comment">// param: Insect</span>
  }

  param; <span class="hljs-comment">// param: Bird | Fish | Insect</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">param: Animal | Bird | Fish | Insect | Bug</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect | Bug</span>
  <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Bird) {
    param; <span class="hljs-comment">// param: Bird</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Fish) {
    param; <span class="hljs-comment">// param: Fish</span>
  } <span class="hljs-keyword">else</span> {
    param; <span class="hljs-comment">// param: Animal | Insect | Bug</span>
  }

  param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect | Bug</span>
}</code></pre>
<p>Кроме того, условия можно поместить в тернарный оператор. В этом случае, область на которую распространяется сужение диапазона типов, ограничивается областью, в которой выполняется, соответствующие условию, выражение.</p>
<p>В качестве примера, можно представить функцию, которой, в качестве единственного  аргумента, можно передать, как значение принадлежащего к типу <code class="inline-code">T</code>, так и функциональное выражение возвращающее значение принадлежащие к типу <code class="inline-code">T</code>. Для того, чтобы было проще работать со значением параметра, его нужно сохранить в локальную переменную, которой указан тип <code class="inline-code">T</code>. Но прежде, компилятору нужно помочь конкретизировать тип данных, к которому принадлежит значение. </p>
<p>Условие, как и раньше, можно было бы поместить в конструкцию <code class="inline-code">if</code>`else`, но в таких случаях, больше подходит тернарный условный оператор.</p>
<p>Создав условие, в котором значение проверяется на принадлежность к типу отличному от типа <code class="inline-code">T</code>, разработчик укажет компилятору, что при выполнении условия, тип параметра будет ограничен типом <code class="inline-code">Function</code>, что даст возможность вызвать параметр как функцию. Иначе, значение хранимое в параметре принадлежит к типу <code class="inline-code">T</code>.</p>
<p><em>Пример для оператора typeof</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: <span class="hljs-built_in">string</span> | (() => <span class="hljs-built_in">string</span>)</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: string | (() => string)</span>

  <span class="hljs-keyword">let</span> value: <span class="hljs-built_in">string</span> = <span class="hljs-keyword">typeof</span> param !== <span class="hljs-string">'string'</span> ? param() : param;

  param; <span class="hljs-comment">// param: string | (() => string)</span>
}</code></pre>
<p><em>Пример для оператора instanceof</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span> = '<span class="hljs-keyword">type</span>'</span>) {} }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param: Animal | (() => Animal)</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Animal | (() => Animal)</span>

  <span class="hljs-keyword">let</span> value: Animal = !(param <span class="hljs-keyword">instanceof</span> Animal) ? param() : param;

  param; <span class="hljs-comment">// param: Animal | (() => Animal)</span>
}</code></pre>
<p>Так как оператор <code class="inline-code">switch</code> логически похож на оператор <code class="inline-code">if</code> \ <code class="inline-code">else</code>, то может показаться, что механизм применимый к рассмотренным в этого главе логическим операторам, будет применим и к оператору <code class="inline-code">switch</code>. Но на самом деле это не так. Вывод типов, не умеет различать условия, составленные при помощи операторов <code class="inline-code">typeof</code> и <code class="inline-code">instanceof</code>, в конструкции <code class="inline-code">switch</code>.</p>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-priznakov-prisushchih-tipu-Tagged-Union" name="Сужение диапазона множества типов на основе признаков присущих типу Tagged Union" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-priznakov-prisushchih-tipu-Tagged-Union" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе признаков присущих типу Tagged Union
            </h2>
        
<hr>
<p>Помимо установления принадлежности к типу данных, диапазон типов, составляющих тип Union, можно сузить по признакам, характерных для типа <code class="inline-code">Tagged Union</code>.</p>
<p>Условия, составленные на основе идентификаторов варианта, можно использовать во всех условных операторах, включая <code class="inline-code">switch</code>.</p>
<p><em>Пример для оператора if\esle</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> AnimalTypes {
  Animal = <span class="hljs-string">"animal"</span>,
  Bird = <span class="hljs-string">"bird"</span>,
  Fish = <span class="hljs-string">"fish"</span>
}

<span class="hljs-keyword">class</span> Animal {
  readonly <span class="hljs-keyword">type</span>: AnimalTypes = AnimalTypes.Animal;
}
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
  readonly <span class="hljs-keyword">type</span>: AnimalTypes.Bird = AnimalTypes.Bird;

  <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
  readonly <span class="hljs-keyword">type</span>: AnimalTypes.Fish = AnimalTypes.Fish;

  <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">param: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Bird | Fish</span>

  <span class="hljs-keyword">if</span> (param.type === AnimalTypes.Bird) {
    param.fly();
  } <span class="hljs-keyword">else</span> {
    param.swim();
  }

  param; <span class="hljs-comment">// param: Bird | Fish</span>
}</code></pre>
<p><em>Пример для тернарного оператора ( ?: )</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">param: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Bird | Fish</span>

  param.type === AnimalTypes.Bird ? param.fly() : param.swim();

  param; <span class="hljs-comment">// param: Bird | Fish</span>
}</code></pre>
<p><em>Пример для оператора switch</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> AnimalTypes {
  Animal = <span class="hljs-string">"animal"</span>,
  Bird = <span class="hljs-string">"bird"</span>,
  Fish = <span class="hljs-string">"fish"</span>
}

<span class="hljs-keyword">class</span> Animal {
  readonly <span class="hljs-keyword">type</span>: AnimalTypes = AnimalTypes.Animal;
}
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
  readonly <span class="hljs-keyword">type</span>: AnimalTypes.Bird = AnimalTypes.Bird;

  <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
  readonly <span class="hljs-keyword">type</span>: AnimalTypes.Fish = AnimalTypes.Fish;

  <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">param: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: Bird | Fish</span>

  <span class="hljs-keyword">switch</span> (param.type) {
    <span class="hljs-keyword">case</span> AnimalTypes.Bird:
      param.fly(); <span class="hljs-comment">// Ok</span>
      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> AnimalTypes.Fish:
      param.swim(); <span class="hljs-comment">// Ok</span>
      <span class="hljs-keyword">break</span>;
  }

  param; <span class="hljs-comment">// param: Bird | Fish</span>
}</code></pre>
<p>В случаях, когда множество типа <code class="inline-code">Union</code> составляют тип <code class="inline-code">null</code> и/или <code class="inline-code">undefined</code>, а также только один конкретный тип, для вывода типа, будет достаточно условия, подтверждающего существование значения, отличного от <code class="inline-code">null</code> и/или <code class="inline-code">undefined</code>.</p>
<p>Это очень распространенный случай при активной опции <code class="inline-code">--strictNullChecks</code>. Условие, с помощью которого вывод типов сможет установить принадлежность значения к типам, отличными от <code class="inline-code">null</code> и/или <code class="inline-code">undefined</code>, может использоваться совместно с любыми условными операторами.</p>
<p><em>Пример с оператором if\else</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: number | null | undefined</span>
 
  <span class="hljs-keyword">if</span>( param !== <span class="hljs-literal">null</span> &#x26;&#x26; param !== <span class="hljs-literal">undefined</span> ){
    param; <span class="hljs-comment">// param: number</span>
  }

  <span class="hljs-comment">// or</span>
 
  <span class="hljs-keyword">if</span>( param ){
    param; <span class="hljs-comment">// Param: number</span>
  }

  param; <span class="hljs-comment">// param: number | null | undefined</span>
}</code></pre>
<p><em>Пример с тернарным оператором ( ?: )</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: number | null | undefined</span>

  <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">number</span> = param ? param : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">number</span> = param || <span class="hljs-number">0</span>;
 
  param; <span class="hljs-comment">// param: number | null | undefined</span>
}</code></pre>
<p><em>Пример с оператором switch</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> </span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: number | null | undefined</span>

  <span class="hljs-keyword">switch</span>(param){
      <span class="hljs-keyword">case</span> <span class="hljs-literal">null</span>:
          param; <span class="hljs-comment">// param: null</span>
          <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-literal">undefined</span>:
          param; <span class="hljs-comment">// param: undefined</span>
          <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">default</span>: {
          param; <span class="hljs-comment">// param: number</span>
      }
  }

  param; <span class="hljs-comment">// param: number | null | undefined</span>
}</code></pre>
<p>Кроме этого, при активной опции <code class="inline-code">--strictNullChecks</code>, в случаях, в которых значение принадлежит к объектному типу, вывод типов может заменить оператор <code class="inline-code">Not-Null Not-Undefined</code>. Для этого нужно составить условие, в котором будет проверяться обращение к членам, в случае отсутствия которых может возникнуть ошибка.</p>
<p><em>Пример с Not-Null Not-Undefined (с учетом активной опции --strictNullChecks)</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Ability {
  <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Bird {
  <span class="hljs-keyword">public</span> ability: Ability | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> Ability();
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> </span>): <span class="hljs-title">void</span> </span>{
  animal.ability <span class="hljs-comment">// Error, Object is possibly 'null' or 'undefined'</span>
  animal!.ability <span class="hljs-comment">// Ok</span>
  animal!.ability.fly(); <span class="hljs-comment">// Error, Object is possibly 'null' or 'undefined'</span>
  animal!.ability!.fly(); <span class="hljs-comment">// Ok</span>
}</code></pre>
<p><em>Пример с защитником типа (с учетом активной опции --strictNullChecks)</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Ability {
  <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Bird {
  <span class="hljs-keyword">public</span> ability: Ability | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> Ability();
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">if</span>( animal &#x26;&#x26; animal.ability ){
    animal.ability.fly(); <span class="hljs-comment">// Ok</span>
  }
}</code></pre>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-dostupnyh-chlenov-obekta" name="Сужение диапазона множества типов на основе доступных членов объекта" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-dostupnyh-chlenov-obekta" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе доступных членов объекта
            </h2>
        
<hr>
<p>Сужение диапазона типов также возможно на основе доступных (<code class="inline-code">public</code>) членов присущих типам составляющих диапазон (<code class="inline-code">Union</code>). Сделать это можно с помощью оператора <code class="inline-code">in</code>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A { <span class="hljs-keyword">public</span> a: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>; }
<span class="hljs-keyword">class</span> B { <span class="hljs-keyword">public</span> b: <span class="hljs-built_in">string</span> = <span class="hljs-string">'text'</span>; }
<span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> A {}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params">p: A | B</span>) </span>{
  <span class="hljs-keyword">if</span> ( <span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> p ) {
      <span class="hljs-keyword">return</span> p.a;  <span class="hljs-comment">// p: A</span>
  }

  <span class="hljs-keyword">return</span> p.b;  <span class="hljs-comment">// p: B</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">p: B | C </span>) </span>{
  <span class="hljs-keyword">if</span> ( <span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> p ) {
      <span class="hljs-keyword">return</span> p.a;  <span class="hljs-comment">// p: C</span>
  }

  <span class="hljs-keyword">return</span> p.b;  <span class="hljs-comment">// p: B</span>
}</code></pre>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-funkcii-opredelennoi-polzovatelem" name="Сужение диапазона множества типов на основе функции определенной пользователем" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-funkcii-opredelennoi-polzovatelem" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе функции определенной пользователем
            </h2>
        
<hr>
<p>Все перечисленные ранее способы работают только в том случае, если проверка происходит в месте, отведенном под условие. Другими словами, с помощью перечисленных до этого момента способов, условие проверки, нельзя вынести в отдельный блок кода (функцию). Это могло бы сильно ударить по семантической составляющей кода, а также нарушить принцип разработки программного обеспечения, который призван бороться с повторением кода (<em>Don’t repeat yourself, DRY</em> (не повторяйся)). Но к счастью для разработчиков, создатели <em>TypeScript</em> реализовали возможность определять пользовательские защитники типа.</p>
<p>В роли пользовательского защитника может выступать функция, функциональное выражение или метод, которая обязательно должна возвращать значение принадлежащие к типу <code class="inline-code">boolean</code>. Для того чтобы вывод типов понял, что вызываемая функция не является обычной функцией, которая возвращает значение булева типа, у функции вместо типа возвращаемого значения указывают предикат (предикат, это логическое выражение, значение которого может быть либо истинным (<code class="inline-code">true</code>), либо ложным (<code class="inline-code">false</code>)).</p>
<p>Выражение предиката состоит из трех частей и имеет следующий вид <code class="inline-code">identifier is Type</code>. </p>
<p>Первым  членом выражения является идентификатор, который обязан совпадать с идентификатором одного из параметров, объявленных в сигнатуре функции. В случае, когда предикат указан методу экземпляра класса, в качестве идентификатора может быть указано ключевое слово <code class="inline-code">this</code>. </p>
<p>Стоит отдельно упомянуть, что ключевое слово <code class="inline-code">this</code> можно указывать только методам, объявленным в конструкциях объявленных при помощи ключевых слов <code class="inline-code">class</code> и <code class="inline-code">interface</code>. При попытке указать ключевое слово <code class="inline-code">this</code> в предикате функционального выражения, ссылку на которое присваивается свойству <code class="inline-code">prototype</code>, функции конструктора, либо же в методе объявленного в объекте созданного с помощью литерала объекта, возникнет ошибка.</p>
<p><em>Пример с функцией конструктором</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constructor</span>(<span class="hljs-params"></span>)</span>{}

Constructor.prototype.validator = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>): <span class="hljs-title">this</span> <span class="hljs-title">is</span> <span class="hljs-title">Object</span> </span>{ <span class="hljs-comment">// Error</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};</code></pre>
<p><em>Пример с литералом объекта</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IPredicat {
  validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// Ok</span>
}

<span class="hljs-keyword">var</span> object: IPredicat = { <span class="hljs-comment">// Ok</span>
  validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span> { <span class="hljs-comment">// Error</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
};

<span class="hljs-keyword">var</span> object: {validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span>} = { <span class="hljs-comment">// Error</span>
  validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span> { <span class="hljs-comment">// Error</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
};</code></pre>
<p>Ко второму члену выражения относится ключевое слово <code class="inline-code">is</code> которое служит в качестве утверждения.</p>
<p>В качестве третьего члена выражения может выступать любой тип данных.</p>
<p><em>Пример предиката функции (function)</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isT1</span>(<span class="hljs-params"> p1: T1 | T2 | T3 </span>): <span class="hljs-title">p1</span> <span class="hljs-title">is</span> <span class="hljs-title">T1</span> </span>{
  <span class="hljs-keyword">return</span> p1 <span class="hljs-keyword">instanceof</span> T1;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1 | T2 | T3 </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">if</span>( isT1( p1 ) ){
    p1; <span class="hljs-comment">// p1: T1</span>
  }
}</code></pre>
<p><em>Пример предиката функционального выражения (functional expression)</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> isT2 = ( p1: T1 | T2 | T3 ): p1 is T2 => p1 <span class="hljs-keyword">instanceof</span> T2;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1 | T2 | T3 </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">if</span>( isT2( p1 ) ){
      p1; <span class="hljs-comment">// p1: T2</span>
  }
}</code></pre>
<p><em>Пример предиката метода класса (static method)</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Validator {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isT3( p1: T1 | T2 | T3 ): p1 is T3 {
    <span class="hljs-keyword">return</span> p1 <span class="hljs-keyword">instanceof</span> T3;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1 | T2 | T3 </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">if</span>( Validator.isT3( p1 ) ){
    p1; <span class="hljs-comment">// p1: T3</span>
  }
}</code></pre>
<p>Условие, на основании которого, разработчик определяет принадлежность одного из параметров к конкретному типу данных, не ограничено никакими конкретными правилами. Исходя из результата выполнения условия, истина (<code class="inline-code">true</code>) или ложь (<code class="inline-code">false</code>), вывод типов сможет установить принадлежность указанного параметра к указанному типу данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {}
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
  <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
  <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">extends</span> Animal {
  <span class="hljs-keyword">public</span> crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> AnimalValidator {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isBird( animal: Animal ): animal is Bird {
    <span class="hljs-keyword">return</span> animal <span class="hljs-keyword">instanceof</span> Bird;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isFish( animal: Animal ): animal is Fish {
    <span class="hljs-keyword">return</span> (animal <span class="hljs-keyword">as</span> Fish).swim !== <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isInsect( animal: Animal ): animal is Insect {
    <span class="hljs-keyword">let</span> isAnimalIsNotUndefinedValid: <span class="hljs-built_in">boolean</span> = animal !== <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">let</span> isInsectValid: <span class="hljs-built_in">boolean</span> = animal <span class="hljs-keyword">instanceof</span> Insect;

    <span class="hljs-keyword">return</span> isAnimalIsNotUndefinedValid &#x26;&#x26; isInsectValid;
  }
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"> animal: Animal </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">if</span>( AnimalValidator.isBird( animal ) ){
    animal.fly();
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( AnimalValidator.isFish( animal ) ){
    animal.swim();
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( AnimalValidator.isInsect( animal ) ){
    animal.crawl();
  }
}</code></pre>
<p>Последнее о чем осталось упомянуть, что в случае, если по условию значение не подойдет не по одному из признаков, то вывод типов установит ему принадлежность к типу данных <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) {} }
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">if</span>( animal <span class="hljs-keyword">instanceof</span> Bird ){
    animal; <span class="hljs-comment">// animal: Bird</span>
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( animal <span class="hljs-keyword">instanceof</span> Fish ){
    animal; <span class="hljs-comment">// animal: Fish</span>
  }<span class="hljs-keyword">else</span>{
    animal; <span class="hljs-comment">// animal: never</span>
  }
}</code></pre>
</section>