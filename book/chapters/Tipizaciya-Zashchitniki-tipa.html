<h1>Защитники типа</h1>
<p>Понимание механизмов рассматриваемых в этой главе научит определять конструкции, которые часто применяются на практике и способны сделать код более понятным и выразительным.</p><section id="Zashchitniki-Tipa-obshchee" name="Защитники Типа - общее" class="subchapter">

            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Zashchitniki-Tipa-obshchee" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Защитники Типа - общее
            </h2>
        
<hr>
<p>Помимо того, что <em>TypeScript</em> имеет достаточно мощную систему выявления ошибок на этапе компиляции, разработчики языка, не останавливаясь на достигнутом, безостановочно работают над сведением их к нулю. Существенным шагом к достижению цели было добавление компилятору возможности активируемой при помощи флага <code class="inline-code">--strictNullChecks</code>, запрещающей неявные операции в которых участвует значение <code class="inline-code">null</code> и <code class="inline-code">undefined</code>. Простыми словами, компилятор научили во время анализа кода выявлять ошибки способные возникнуть при выполнении операций в которых фигурируют значения <code class="inline-code">null</code> или <code class="inline-code">undefined</code>.</p>
<p>Простейшим примером является операция получения элемента из dom-дерева при помощи метода <code class="inline-code">querySelector()</code>, который в обычном <em>нерекомендуемом</em> режиме (с неактивной опцией <code class="inline-code">--strictNullChecks</code>) возвращает значение совместимое с типом <code class="inline-code">Element</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> stage: Element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);</code></pre>
<p>Но в строгом <em>рекомендуемом</em> режиме (с активной опцией <code class="inline-code">--strictNullChecks</code>) метод <code class="inline-code">querySelector()</code> возвращает объединенный тип <code class="inline-code">Element | null</code>, поскольку искомое значение может попросту не существовать.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> stage: Element | <span class="hljs-literal">null</span> = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stage_clickHandler</span>(<span class="hljs-params">event: MouseEvent</span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>Не будет лишним напомнить, что на самом деле метод <code class="inline-code">querySelector</code> возвращает тип <code class="inline-code">Element | null</code> независимо от режима. Дело в том, что в обычном режиме тип <code class="inline-code">null</code> совместим с любыми типами. То есть, в случае отсутствия элемента в dom-дереве операция присваивания значения <code class="inline-code">null</code> переменной с типом <code class="inline-code">Element</code> не приведет к возникновению ошибки.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.es6.d.ts</span>
<span class="hljs-keyword">interface</span> NodeSelector {
    querySelector(selectors: <span class="hljs-built_in">string</span>): Element | <span class="hljs-literal">null</span>;
}</code></pre>
<p>Возвращаясь к примеру с получением элемента из dom-дерева стоит сказать, что если раскомментировать строчку кода в которой происходит подписка элемента на событие, то даже в том случае, если элемент существует, на этапе компиляции все равно возникнет ошибка. Все дело в том что компилятор <em>TypeScript</em> не позволит вызвать метод <code class="inline-code">addEventListener</code> по той причине, что для него объект на который ссылается переменная, принадлежит к типу <code class="inline-code">Element</code> ровно настолько же, насколько он принадлежит к типу <code class="inline-code">null</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> stage: Element | <span class="hljs-literal">null</span> = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);
stage.addEventListener(<span class="hljs-string">'click'</span>, stage_clickHandler); <span class="hljs-comment">// тип переменной stage Element или Null?</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stage_clickHandler</span>(<span class="hljs-params">event: MouseEvent</span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>Именно из-за этой особенности или другими словами, неоднозначности, которую вызывает тип <code class="inline-code">Union</code>, в <em>TypeScript</em> появился механизм называемый <em>защитниками типа</em> (<code class="inline-code">Type Guards</code>).</p>
<p>Защитники типа — это правила, которые помогают выводу типов определить суженный диапазон типов для значения, принадлежащего к типу <code class="inline-code">Union</code>. Другими словами, разработчику предоставлен механизм, позволяющий с помощью выражений составить логические условия, проанализировав которые вывод типов сможет сузить диапазон типов до указанного и выполнить над ним требуемые операции.</p>
<p>Понятно, что ничего не понятно. Поэтому прежде чем продолжить разбирать определение по шагам, нужно рассмотреть простой пример, который поможет зафиксировать картинку в сознании.</p>
<p>Представим два класса, <code class="inline-code">Bird</code> и <code class="inline-code">Fish</code>, в обоих из которых реализован метод <code class="inline-code">voice</code>. Кроме этого, в классе <code class="inline-code">Bird</code> реализован метод <code class="inline-code">fly</code>, а в классе <code class="inline-code">Fish</code> — метод <code class="inline-code">swim</code>. Далее представим функцию с единственным параметром, принадлежащему к объединению типов <code class="inline-code">Bird</code> и <code class="inline-code">Fish</code>.</p>
<p>В теле этой функции без труда получится выполнить операцию вызова метода <code class="inline-code">voice</code> у её параметра, так как этот метод объявлен и в типе <code class="inline-code">Bird</code>, и в типе <code class="inline-code">Fish</code>. Но при попытке вызвать метод <code class="inline-code">fly</code> или <code class="inline-code">swim</code> возникает ошибка, так как эти методы не являются общими для обоих типов. Компилятор попросту находится в подвешенном состоянии и не способен самостоятельно определится.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
    <span class="hljs-keyword">public</span> voice(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
    <span class="hljs-keyword">public</span> voice(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    animal.voice(); <span class="hljs-comment">// Ok</span>

    animal.fly(); <span class="hljs-comment">// Error</span>
    animal.swim(); <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Для того чтобы облегчить работу компилятору, <em>TypeScript</em> предлагает процесс сужения множества типов составляющих тип <code class="inline-code">Union</code> до заданного диапазона, а затем закрепляет его за конкретной областью видимости в коде. Но прежде чем диапазон типов будет вычислен и ассоциирован с областью, разработчику необходимо составить условия, включающие в себя признаки которые недвусмысленно указывают на принадлежность к нужным типам.</p>
<p>Из-за того, что анализ происходит на основе логических выражений, область за которой закрепляется суженный диапазон типов, ограничивается областью выполняемой при истинности условия.</p>
<p>Стоит заметить, что от признаков участвующих в условии зависит место в котором может находится выражение, а от типов составляющих множество типа <code class="inline-code">Union</code>, зависит способ составления логического условия.</p>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-tipa-dannyh" name="Сужение диапазона множества типов на основе типа данных" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-tipa-dannyh" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе типа данных
            </h2>
        
<hr>
<p>При необходимости составления условия в основе которого лежат валидные с точки зрения <em>JavaScript</em> типы, прибегают к помощи знакомых таких операторов как <code class="inline-code">typeof</code> и <code class="inline-code">instanceof</code>.</p>
<p>К помощи оператора <code class="inline-code">typeof</code> прибегают тогда, когда хотят установить принадлежность к типам <code class="inline-code">number</code>, <code class="inline-code">string</code>, <code class="inline-code">boolean</code>, <code class="inline-code">object</code>, <code class="inline-code">function</code>, <code class="inline-code">symbol</code> или <code class="inline-code">undefined</code>.</p>
<p>Если же значение принадлежит к производному от объекта типу, то установить его принадлежность к типу определяемого классом и находящегося в иерархии наследования можно при помощи оператора <code class="inline-code">instanceof</code>.</p>
<p>Как уже было сказано, с помощью операторов <code class="inline-code">typeof</code> и <code class="inline-code">instanceof</code> составляется условие, по которому компилятор может вычислить к какому конкретно типу или диапазону типов будет относится значение в определяемой условием области.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора typeof</span>


<span class="hljs-keyword">type</span> ParamType = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> | object | <span class="hljs-built_in">Function</span> | symbol | <span class="hljs-literal">undefined</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param: ParamType</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: number | string | boolean | object | Function | symbol | undefined</span>

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'number'</span>) {
      param; <span class="hljs-comment">// param: numer</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'string'</span>) {
      param; <span class="hljs-comment">// param: string</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'boolean'</span>) {
      param; <span class="hljs-comment">// param: boolean</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'object'</span>) {
      param; <span class="hljs-comment">// param: object</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'function'</span>) {
      param; <span class="hljs-comment">// param: Function</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'symbol'</span>) {
      param; <span class="hljs-comment">// param:symbol</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'undefined'</span>) {
      param; <span class="hljs-comment">// param: undefined</span>
    }

    param; <span class="hljs-comment">// param: number | string | boolean | object | Function | symbol | undefined</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора instenceof</span>


<span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">extends</span> Animal {}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: Animal | Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect</span>

    <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Bird) {
        param; <span class="hljs-comment">// param: Bird</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Fish) {
        param; <span class="hljs-comment">// param: Fish</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Insect) {
        param; <span class="hljs-comment">// param: Insect</span>
    }

    param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect</span>
}</code></pre>
<p>В случае, когда значение принадлежит к типу <code class="inline-code">Union</code>, а выражение состоит из двух операторов, <code class="inline-code">if</code> и <code class="inline-code">else</code>, значение находящиеся в операторе <code class="inline-code">else</code> будет принадлежать к диапазону типов не участвующих в условии <code class="inline-code">if</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора typeof</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: number | string | boolean</span>

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'string'</span>) {
        param; <span class="hljs-comment">// param: number | string</span>
    } <span class="hljs-keyword">else</span> {
        param; <span class="hljs-comment">// param: boolean</span>
    }

    param; <span class="hljs-comment">// param: number | string | boolean</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: number | string | boolean</span>

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">'number'</span>) {
        param; <span class="hljs-comment">// param: number</span>
    } <span class="hljs-keyword">else</span> {
        param; <span class="hljs-comment">// param: string | boolean</span>
    }

    param; <span class="hljs-comment">// param: number | string | boolean</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора instanceof</span>


<span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Bug <span class="hljs-keyword">extends</span> Insect {}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params">param: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Bird | Fish | Insect</span>

    <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Bird) {
        param; <span class="hljs-comment">// param: Bird</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Fish) {
        param; <span class="hljs-comment">// param: Fish</span>
    } <span class="hljs-keyword">else</span> {
        param; <span class="hljs-comment">// param: Insect</span>
    }

    param; <span class="hljs-comment">// param: Bird | Fish | Insect</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">param: Animal | Bird | Fish | Insect | Bug</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect | Bug</span>
    <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Bird) {
        param; <span class="hljs-comment">// param: Bird</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Fish) {
        param; <span class="hljs-comment">// param: Fish</span>
    } <span class="hljs-keyword">else</span> {
        param; <span class="hljs-comment">// param: Animal | Insect | Bug</span>
    }

    param; <span class="hljs-comment">// param: Animal | Bird | Fish | Insect | Bug</span>
}</code></pre>
<p>Кроме того, условия можно поместить в тернарный оператор. В этом случае область на которую распространяется сужение диапазона типов ограничивается областью, в которой выполняется соответствующие условию выражение.</p>
<p>В качестве примера можно представить функцию, которой в качестве единственного аргумента можно передать как значение принадлежащее к типу <code class="inline-code">T</code>, так и функциональное выражение возвращающее значение принадлежащие к типу <code class="inline-code">T</code>. Для того чтобы было проще работать со значением параметра, его нужно сохранить в локальную переменную которой указан тип <code class="inline-code">T</code>. Но прежде компилятору нужно помочь конкретизировать тип данных к которому принадлежит значение.</p>
<p>Условие как и раньше можно было бы поместить в конструкцию <code class="inline-code">if</code>/<code class="inline-code">else</code>, но в таких случаях больше подходит тернарный условный оператор.</p>
<p>Создав условие в котором значение проверяется на принадлежность к типу отличному от типа <code class="inline-code">T</code>, разработчик укажет компилятору, что при выполнении условия тип параметра будет ограничен типом <code class="inline-code">Function</code>, тем самым создав возможность вызвать параметр как функцию. Иначе значение хранимое в параметре принадлежит к типу <code class="inline-code">T</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора typeof</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: <span class="hljs-built_in">string</span> | (() => <span class="hljs-built_in">string</span>)</span>): <span class="hljs-title">void</span> </span>{
  param; <span class="hljs-comment">// param: string | (() => string)</span>

  <span class="hljs-keyword">let</span> value: <span class="hljs-built_in">string</span> = <span class="hljs-keyword">typeof</span> param !== <span class="hljs-string">'string'</span> ? param() : param;

  param; <span class="hljs-comment">// param: string | (() => string)</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора instanceof</span>


<span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span> = '<span class="hljs-keyword">type</span>'</span>) {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param: Animal | (() => Animal)</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Animal | (() => Animal)</span>

    <span class="hljs-keyword">let</span> value: Animal = !(param <span class="hljs-keyword">instanceof</span> Animal) ? param() : param;

    param; <span class="hljs-comment">// param: Animal | (() => Animal)</span>
}</code></pre>
<p>Так как оператор <code class="inline-code">switch</code> логически похож на оператор <code class="inline-code">if</code>/<code class="inline-code">else</code>, то может показаться, что механизм рассмотренныq в этой главе будет применим и к нему. Но это не так. Вывод типов не умеет различать условия составленные при помощи операторов <code class="inline-code">typeof</code> и <code class="inline-code">instanceof</code> в конструкции <code class="inline-code">switch</code>.</p>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-priznakov-prisushchih-tipu-Tagged-Union" name="Сужение диапазона множества типов на основе признаков присущих типу Tagged Union" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-priznakov-prisushchih-tipu-Tagged-Union" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе признаков присущих типу Tagged Union
            </h2>
        
<hr>
<p>Помимо определения принадлежности к единичному типу, диапазон типов составляющих тип <code class="inline-code">Union</code> можно сузить по признакам характерным для типа <code class="inline-code">Tagged Union</code>.</p>
<p>Условия составленные на основе идентификаторов варианта можно использовать во всех условных операторах включая <code class="inline-code">switch</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора if\esle</span>


<span class="hljs-keyword">enum</span> AnimalTypes {
    Animal = <span class="hljs-string">"animal"</span>,
    Bird = <span class="hljs-string">"bird"</span>,
    Fish = <span class="hljs-string">"fish"</span>
}

<span class="hljs-keyword">class</span> Animal {
    readonly <span class="hljs-keyword">type</span>: AnimalTypes = AnimalTypes.Animal;
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    readonly <span class="hljs-keyword">type</span>: AnimalTypes.Bird = AnimalTypes.Bird;

    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
    readonly <span class="hljs-keyword">type</span>: AnimalTypes.Fish = AnimalTypes.Fish;

    <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">param: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Bird | Fish</span>

    <span class="hljs-keyword">if</span> (param.type === AnimalTypes.Bird) {
        param.fly();
    } <span class="hljs-keyword">else</span> {
        param.swim();
    }

    param; <span class="hljs-comment">// param: Bird | Fish</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для тернарного оператора (?:)</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">param: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Bird | Fish</span>

    param.type === AnimalTypes.Bird ? param.fly() : param.swim();

    param; <span class="hljs-comment">// param: Bird | Fish</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример для оператора switch</span>


<span class="hljs-keyword">enum</span> AnimalTypes {
    Animal = <span class="hljs-string">"animal"</span>,
    Bird = <span class="hljs-string">"bird"</span>,
    Fish = <span class="hljs-string">"fish"</span>
}

<span class="hljs-keyword">class</span> Animal {
    readonly <span class="hljs-keyword">type</span>: AnimalTypes = AnimalTypes.Animal;
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    readonly <span class="hljs-keyword">type</span>: AnimalTypes.Bird = AnimalTypes.Bird;

    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
    readonly <span class="hljs-keyword">type</span>: AnimalTypes.Fish = AnimalTypes.Fish;

    <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">param: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: Bird | Fish</span>

    <span class="hljs-keyword">switch</span> (param.type) {
        <span class="hljs-keyword">case</span> AnimalTypes.Bird:
            param.fly(); <span class="hljs-comment">// Ok</span>
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> AnimalTypes.Fish:
            param.swim(); <span class="hljs-comment">// Ok</span>
            <span class="hljs-keyword">break</span>;
    }

    param; <span class="hljs-comment">// param: Bird | Fish</span>
}</code></pre>
<p>В случаях, когда множество типа <code class="inline-code">Union</code> составляют тип <code class="inline-code">null</code> и/или <code class="inline-code">undefined</code>, а также только один конкретный тип, выводу типов будет достаточно условия подтверждающего существование значения отличного от <code class="inline-code">null</code> и/или <code class="inline-code">undefined</code>.</p>
<p>Это очень распространенный случай при активной опции <code class="inline-code">--strictNullChecks</code>. Условие с помощью которого вывод типов сможет установить принадлежность значения к типам, отличными от <code class="inline-code">null</code> и/или <code class="inline-code">undefined</code>, может использоваться совместно с любыми условными операторами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с оператором if\else</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: number | null | undefined</span>

    <span class="hljs-keyword">if</span> (param !== <span class="hljs-literal">null</span> &#x26;&#x26; param !== <span class="hljs-literal">undefined</span>) {
        param; <span class="hljs-comment">// param: number</span>
    }

    <span class="hljs-comment">// or</span>

    <span class="hljs-keyword">if</span> (param) {
        param; <span class="hljs-comment">// Param: number</span>
    }

    param; <span class="hljs-comment">// param: number | null | undefined</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с тернарным оператором (?:)</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: number | null | undefined</span>

    <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">number</span> = param ? param : <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">number</span> = param || <span class="hljs-number">0</span>;

    param; <span class="hljs-comment">// param: number | null | undefined</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с оператором switch</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">void</span> </span>{
    param; <span class="hljs-comment">// param: number | null | undefined</span>

    <span class="hljs-keyword">switch</span>(param) {
        <span class="hljs-keyword">case</span> <span class="hljs-literal">null</span>:
            param; <span class="hljs-comment">// param: null</span>
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-literal">undefined</span>:
            param; <span class="hljs-comment">// param: undefined</span>
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>: {
            param; <span class="hljs-comment">// param: number</span>
        }
    }

    param; <span class="hljs-comment">// param: number | null | undefined</span>
}</code></pre>
<p>Кроме этого, при активной опции <code class="inline-code">--strictNullChecks</code>, в случаях со значением принадлежащем к объектному типу, вывод типов может заменить оператор <code class="inline-code">Not-Null Not-Undefined</code>. Для этого нужно составить условие в котором будет проверяться обращение к членам в случае отсутствия которых может возникнуть ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с Not-Null Not-Undefined (с учетом активной опции --strictNullChecks)</span>


<span class="hljs-keyword">class</span> Ability {
    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">public</span> ability: Ability | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> Ability();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">void</span> </span>{
    animal.ability <span class="hljs-comment">// Error, Object is possibly 'null' or 'undefined'</span>
    animal!.ability <span class="hljs-comment">// Ok</span>
    animal!.ability.fly(); <span class="hljs-comment">// Error, Object is possibly 'null' or 'undefined'</span>
    animal!.ability!.fly(); <span class="hljs-comment">// Ok</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с защитником типа (с учетом активной опции --strictNullChecks)</span>


<span class="hljs-keyword">class</span> Ability {
    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">public</span> ability: Ability | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> Ability();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (animal &#x26;&#x26; animal.ability) {
        animal.ability.fly(); <span class="hljs-comment">// Ok</span>
    }
}</code></pre>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-dostupnyh-chlenov-obekta" name="Сужение диапазона множества типов на основе доступных членов объекта" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-dostupnyh-chlenov-obekta" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе доступных членов объекта
            </h2>
        
<hr>
<p>Сужение диапазона типов также возможно на основе доступных (<code class="inline-code">public</code>) членов, присущих типам составляющим диапазон (<code class="inline-code">Union</code>). Сделать это можно с помощью оператора <code class="inline-code">in</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A { <span class="hljs-keyword">public</span> a: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>; }
<span class="hljs-keyword">class</span> B { <span class="hljs-keyword">public</span> b: <span class="hljs-built_in">string</span> = <span class="hljs-string">'text'</span>; }
<span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> A {}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params">p: A | B</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> p) {
        <span class="hljs-keyword">return</span> p.a;  <span class="hljs-comment">// p: A</span>
    }

    <span class="hljs-keyword">return</span> p.b;  <span class="hljs-comment">// p: B</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">p: B | C</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> p) {
        <span class="hljs-keyword">return</span> p.a;  <span class="hljs-comment">// p: C</span>
    }

    <span class="hljs-keyword">return</span> p.b;  <span class="hljs-comment">// p: B</span>
}</code></pre>
</section><section id="Sujenie-diapazona-mnojestva-tipov-na-osnove-funkcii-opredelennoi-polzovatelem" name="Сужение диапазона множества типов на основе функции, определенной пользователем" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sujenie-diapazona-mnojestva-tipov-na-osnove-funkcii-opredelennoi-polzovatelem" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сужение диапазона множества типов на основе функции, определенной пользователем
            </h2>
        
<hr>
<p>Все перечисленные ранее способы работают только в том случае, если проверка происходит в месте отведенном под условие. Другими словами, с помощью перечисленных до этого момента способов, условие проверки нельзя вынести в отдельный блок кода (функцию). Это могло бы сильно ударить по семантической составляющей кода, а также нарушить принцип разработки программного обеспечения, который призван бороться с повторением кода (<em>Don’t repeat yourself, DRY</em> (не повторяйся)). Но, к счастью для разработчиков, создатели <em>TypeScript</em> реализовали возможность определять пользовательские защитники типа.</p>
<p>В роли пользовательского защитника может выступать функция, функциональное выражение или метод, которые обязательно должны возвращать значения принадлежащие к типу <code class="inline-code">boolean</code>. Для того, чтобы вывод типов понял что вызываемая функция не является обычной функцией, у функции вместо типа возвращаемого значения указывают предикат (предикат — это логическое выражение, значение которого может быть либо истинным <code class="inline-code">true</code>, либо ложным <code class="inline-code">false</code>).</p>
<p>Выражение предиката состоит из трех частей и имеет следующий вид <code class="inline-code">identifier is Type</code>.</p>
<p>Первым членом выражения является идентификатор, который обязан совпадать с идентификатором одного из параметров объявленных в сигнатуре функции. В случае, когда предикат указан методу экземпляра класса, в качестве идентификатора может быть указано ключевое слово <code class="inline-code">this</code>.</p>
<p>Стоит отдельно упомянуть, что ключевое слово <code class="inline-code">this</code> можно указать только в сигнатуре метода, который либо определяется в классе, либо описывается в интерфейсе. При попытке указать ключевое слово <code class="inline-code">this</code> в предикате функционального выражения не получится избежать ошибки если это выражение определяется непосредственно в <code class="inline-code">prototype</code>, функции конструкторе, либо методе объекта созданного с помощью литерала.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с функцией конструктором</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constructor</span>(<span class="hljs-params"></span>) </span>{}

Constructor.prototype.validator = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>): <span class="hljs-title">this</span> <span class="hljs-title">is</span> <span class="hljs-title">Object</span> </span>{ <span class="hljs-comment">// Error</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример с литералом объекта</span>


<span class="hljs-keyword">interface</span> IPredicat {
    validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// Ok</span>
}

<span class="hljs-keyword">var</span> object: IPredicat = { <span class="hljs-comment">// Ok</span>
    validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span> { <span class="hljs-comment">// Error</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
};

<span class="hljs-keyword">var</span> object: {validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span>} = { <span class="hljs-comment">// Error</span>
    validator(): <span class="hljs-keyword">this</span> is <span class="hljs-built_in">Object</span> { <span class="hljs-comment">// Error</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
};</code></pre>
<p>Ко второму члену выражения относится ключевое слово <code class="inline-code">is</code> которое служит в качестве утверждения.</p>
<p>В качестве третьего члена выражения может выступать любой тип данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример предиката функции (function)</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isT1</span>(<span class="hljs-params">p1: T1 | T2 | T3</span>): <span class="hljs-title">p1</span> <span class="hljs-title">is</span> <span class="hljs-title">T1</span> </span>{
    <span class="hljs-keyword">return</span> p1 <span class="hljs-keyword">instanceof</span> T1;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1 | T2 | T3</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (isT1(p1)) {
        p1; <span class="hljs-comment">// p1: T1</span>
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример предиката функционального выражения (functional expression)</span>


<span class="hljs-keyword">const</span> isT2 = (p1: T1 | T2 | T3): p1 is T2 => p1 <span class="hljs-keyword">instanceof</span> T2;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1 | T2 | T3</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (isT2(p1)) {
        p1; <span class="hljs-comment">// p1: T2</span>
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Пример предиката метода класса (static method)</span>


<span class="hljs-keyword">class</span> Validator {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isT3(p1: T1 | T2 | T3): p1 is T3 {
        <span class="hljs-keyword">return</span> p1 <span class="hljs-keyword">instanceof</span> T3;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1 | T2 | T3</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (Validator.isT3(p1)) {
        p1; <span class="hljs-comment">// p1: T3</span>
    }
}</code></pre>
<p>Условие, на основании которого разработчик определяет принадлежность одного из параметров к конкретному типу данных не ограничено никакими конкретными правилами. Исходя из результата выполнения условия <code class="inline-code">true</code> или <code class="inline-code">false</code>, вывод типов сможет установить принадлежность указанного параметра к указанному типу данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {}
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">public</span> crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> AnimalValidator {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isBird(animal: Animal): animal is Bird {
        <span class="hljs-keyword">return</span> animal <span class="hljs-keyword">instanceof</span> Bird;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isFish(animal: Animal): animal is Fish {
        <span class="hljs-keyword">return</span> (animal <span class="hljs-keyword">as</span> Fish).swim !== <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> isInsect(animal: Animal): animal is Insect {
        <span class="hljs-keyword">let</span> isAnimalIsNotUndefinedValid: <span class="hljs-built_in">boolean</span> = animal !== <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">let</span> isInsectValid: <span class="hljs-built_in">boolean</span> = animal <span class="hljs-keyword">instanceof</span> Insect;

        <span class="hljs-keyword">return</span> isAnimalIsNotUndefinedValid &#x26;&#x26; isInsectValid;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Animal</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (AnimalValidator.isBird(animal)) {
        animal.fly();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (AnimalValidator.isFish(animal)) {
        animal.swim();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (AnimalValidator.isInsect(animal)) {
        animal.crawl();
    }
}</code></pre>
<p>Последнее, о чем осталось упомянуть, что в случае когда по условию значение не подходит ни по одному из признаков, вывод типов установит его принадлежность к типу <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Bird) {
        animal; <span class="hljs-comment">// animal: Bird</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Fish) {
        animal; <span class="hljs-comment">// animal: Fish</span>
    } <span class="hljs-keyword">else</span> {
        animal; <span class="hljs-comment">// animal: never</span>
    }
}</code></pre>
</section>