<section id="Klassy-Definite-Assignment-Assertion-Modifier" name="Классы - Definite Assignment Assertion Modifier" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Klassy-Definite-Assignment-Assertion-Modifier" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Классы - Definite Assignment Assertion Modifier
            </h2>
        
<hr>
<p>Для того, чтобы повысить типобезопасность программы, рекомендуют вести разработку с активной опцией <code class="inline-code">--strict</code> (глава <a class="book__chapter__chapter-link" href="/book/contents/Opcii-kompilyatora" title="Опции компилятора" target="_blank">Опции компилятора</a>), которая активирует множество других опций, изменяющих поведение компилятора, заставляя разработчиков писать код сводящий к минимуму ошибки на этапе выполнения. Это привело к созданию такой опции, как <code class="inline-code">--strictPropertyInitialization</code>, которая при активной опции <code class="inline-code">--strictNullChecks</code>, запрещает классу иметь поля, типам которых явно не указана принадлежность к типу Undefined и которые не были  инициализированы в момент его создания. Таким образом предотвращается обращение к полям, которые могут иметь значение <code class="inline-code">undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Identifier {
  <span class="hljs-keyword">public</span> a: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// Ok, инициализация при объявлении</span>
  <span class="hljs-keyword">public</span> b: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Ok, инициализация в конструкторе</span>
  <span class="hljs-keyword">public</span> c: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Ok, явное указание принадлежности к типу Undefined</span>
  <span class="hljs-keyword">public</span> d: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error, инициализация отсутствует</span>

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">this</span>.b = <span class="hljs-number">0</span>;
  }
}</code></pre>
<p>Но бывают случаи, при которых условия, устанавливаемые опцией <code class="inline-code">--strictPropertyInitialization</code>, не могут быть удовлетворены в полной мере. К самым распространенным случаям, можно отнести установку значений полей с помощью <em>DI</em> (dependency injection), инициализация вынесенная в методы, так называемого, жизненного цикла, а также методы инициализации, выполняемые из конструктора класса. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// инициализация с помощью DI</span>
<span class="hljs-keyword">class</span> A {
  <span class="hljs-meta">@Inject</span>( Symbol.for( <span class="hljs-string">'key'</span> ) )
  <span class="hljs-keyword">public</span> field: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// метод жизненного цикла из angular</span>
<span class="hljs-keyword">class</span> B {
  <span class="hljs-keyword">private</span> field: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error</span>

  <span class="hljs-keyword">public</span> ngOnInit(): <span class="hljs-built_in">void</span> {
      <span class="hljs-keyword">this</span>.field = <span class="hljs-number">0</span>;
  }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// инициализация вне конструктора</span>
<span class="hljs-keyword">class</span> C {
  <span class="hljs-keyword">private</span> field: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error</span>

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
      <span class="hljs-keyword">this</span>.init();
  }


  <span class="hljs-keyword">private</span> init(): <span class="hljs-built_in">void</span> {
      <span class="hljs-keyword">this</span>.field = <span class="hljs-number">0</span>;
  }
}</code></pre>
<p>Для таких случаев синтаксис <em>TypeScript</em> был введен модификатор <em>definite assignment assertion modifier</em>, который указывается с помощью символа восклицательного знака (<code class="inline-code">!</code>), располагаемого после идентификатора поля или переменной.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Identifier {
  <span class="hljs-keyword">public</span> identifier!: Type;
}

<span class="hljs-comment">//or</span>

<span class="hljs-keyword">let</span> identifier!: Type;</code></pre>
<p>Применяя модификатор <em>definite assignment assertion modifier</em>, разработчик сообщает компилятору, что берет ответственность за инициализацию поля на себя.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// инициализация с помощью DI</span>
<span class="hljs-keyword">class</span> A {
  <span class="hljs-meta">@Inject</span>( Symbol.for( <span class="hljs-string">'key'</span> ) )
  <span class="hljs-keyword">public</span> field!: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Ok</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// метод жизненного цикла из angular</span>
<span class="hljs-keyword">class</span> B {
  <span class="hljs-keyword">private</span> field!: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Ok</span>

  <span class="hljs-keyword">public</span> ngOnInit(): <span class="hljs-built_in">void</span> {
      <span class="hljs-keyword">this</span>.field = <span class="hljs-number">0</span>;
  }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// инициализация вне конструктора</span>
<span class="hljs-keyword">class</span> C {
  <span class="hljs-keyword">private</span> field!: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Ok</span>

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
      <span class="hljs-keyword">this</span>.init();
  }


  <span class="hljs-keyword">private</span> init(): <span class="hljs-built_in">void</span> {
      <span class="hljs-keyword">this</span>.field = <span class="hljs-number">0</span>;
  }
}</code></pre>
</section>