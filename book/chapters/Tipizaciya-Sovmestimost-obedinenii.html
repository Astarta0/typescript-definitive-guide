<h1>Совместимость объединений (Union Types)</h1>
<p>Поскольку понимание поведения типа <code class="inline-code">Union</code> при проверке на совместимость может вызывать противоречия, эта совсем крохотная глава, будет посвящена этому механизму.</p><section id="Sovmestimost" name="Совместимость" class="subchapter">

            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sovmestimost" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Совместимость
            </h2>
        
<p>Чтобы было проще понять суть противоречий возникающих у разработчиков при понимании механизма совместимости типов объединение, стоит начать с повторения совместимости объектных типов.</p>
<p>Как известно к данному моменту, объектный тип <code class="inline-code">A</code> совместим с объектным типом <code class="inline-code">B</code>, если первый содержит все обязательные признаки второго. Кроме того члены участвующие в проверке на совместимость не обязаны принадлежать к идентичным типам, достаточно чтобы они также были совместимы. Утрированно всё сказанное можно перефразировать как - тип обладающий большим количеством совместимых признаков совместим с типом обладающим меньшим количеством признаков. Или даже - больший тип совместим с меньшим типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Smaller {
    a: <span class="hljs-built_in">number</span>;
    b: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> Bigger {
    a: <span class="hljs-built_in">number</span>;
    b: <span class="hljs-built_in">string</span>;
    c: <span class="hljs-built_in">boolean</span>;
}


<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> small: Smaller;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> big: Bigger;

<span class="hljs-keyword">let</span> s: Smaller = big; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> b: Bigger = small; <span class="hljs-comment">// Error</span></code></pre>
<p>Любому разработчику начавшему свою карьеру с языка реализующего <em>ооп</em> парадигму, подобное поведение кажется само сабой разумеющимся. Так вот с типами объединение (<code class="inline-code">Union</code>) все в точности наоборот. Точнее может показаться что наоборот, хотя на самом деле это совершенно другой случай.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Smaller = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">type</span> Bigger = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>;

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> small: Smaller;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> big: Bigger;

<span class="hljs-keyword">let</span> s: Smaller = big; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> b: Bigger = small; <span class="hljs-comment">// Ok</span></code></pre>
<p>В лучае с совеместимостью объекта значение принадлежащие к <em>большему типу</em> обладает всеми необходимыми признаками требующихся для успешного выполнения операций предназначеных для <em>меньшего типа</em>. В случае с типом объединением чем больше типов его определяют, тем больше шансов что значение будет принадлежать к типу отсутствующему в <em>меньшем типе</em>.</p>
<p>В нашем примере переменная с типом <code class="inline-code">Bigger</code> помимо прочего может быть ассоциированна со значение принадлежащем к типу <code class="inline-code">boolean</code>, который не определяет множество типа <code class="inline-code">Smaller</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Smaller = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">type</span> Bigger = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>;


<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> small: Smaller;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> big: Bigger;

<span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">let</span> s: Smaller = big; <span class="hljs-comment">// Error</span>
<span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">let</span> b: Bigger = small; <span class="hljs-comment">// Ok</span>

<span class="hljs-comment">/**
 * [0] переменная big может иметь значение принадлежащие
 * к типу boolean которое отсутствует в типе Smaller. Поэтому
 * переменная big не может быть присвоенна переменной с Smaller.
 * 
 * [1] И наоборот. Поскольку переменная small может иметь значение
 * принадлежащие либо к number либо string, её можно присвоить пепеменной
 * с типом Bigger поскольку множество определяющее его включает данные типы.
 */</span></code></pre>
</section>