<section id="Zakrytye-polya-opredelennye-specifikaciei-ECMAScript" name="Закрытые поля определенные спецификацией ECMAScript" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Zakrytye-polya-opredelennye-specifikaciei-ECMAScript" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Закрытые поля определенные спецификацией ECMAScript
            </h2>
        
<hr>
<p>Помимо сокрытия полей класса от внешней среды с помощью модификатора доступа <code class="inline-code">private</code>, присущего исключительно <em>TypeScript</em>, существует возможность прибегнуть к механизму предусмотренному спецификацией <em>ECMAScript</em>. Для того чтобы воспользоваться им, идентификаторы скрываемых полей должны начинаться с символа решетки <code class="inline-code">#</code>.</p>
<p>Доступ к защищенному полю класса ограничивается областью видимости класса в котором оно объявлено, а при обращении к нему необходимо также указывать символ решетки. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// защищенное поле класса</span>

    <span class="hljs-keyword">get</span> isLife() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#isLife;
    }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();
<span class="hljs-built_in">console</span>.log(animal.isLife); <span class="hljs-comment">// обращение к аксессору, а не защищенному полю</span></code></pre>
<p>Поскольку доступ ограничивается областью видимости класса, потомки не могут обращаться к защищенным полям своих предков.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// защищенное поле класса</span>
}

<span class="hljs-comment">/**
 * Error!
 * 
 * Class 'Bird' incorrectly extends base class 'Animal'.
 * Property '#isLife' is not accessible outside class 'Animal' because
 * it has a private identifier.ts(18013)
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.#isLife; 
    }
}</code></pre>
<p>В отличие от модификатора доступа <code class="inline-code">private</code>, этот механизм не может быть применён к методам класса, но так как за его появлением стоит спецификация <em>ECMAScript</em>, то он продолжает действовать в скомпилированной программе. Именно поэтому, в отличие от сценария с модификатором доступа <code class="inline-code">private</code>, <em>потомки</em> могут без страха нарушить ожидаемый ход выполнения программы и объявлять защищенные поля, чьи идентификаторы идентичны объявлениям в их <em>супер-классах</em>. </p>
<p>Сценарий с модификатором доступа private:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">private</span> _isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">/**
 * Error!
 * 
 * Class 'Bird' incorrectly extends base class 'Animal'.
 * Types have separate declarations of a private property '_isLife'.ts(2415)
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">private</span> _isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;
}</code></pre>
<p>Сценарий с защищенными полями предусмотренными спецификацией ECMAScript:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">/**
 * Ok!
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    #isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;
}</code></pre>
<p>И в заключение, стоит упомянуть что существует несколько нюансов — один из них заключается в том, что закрытые поля нельзя объявлять непосредственно в конструкторе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-comment">// Parameter declaration expected.ts(1138)</span>
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">#isLife = <span class="hljs-literal">true</span></span>) {}
}</code></pre>
<p>Другой нюанс связан с тем, что код содержащий закрытые поля класса может быть скомпилирован исключительно в версии <code class="inline-code">es6</code> и выше.</p>
</section>