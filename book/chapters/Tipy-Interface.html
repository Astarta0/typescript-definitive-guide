<section id="Tipy-Interfaces" name="Типы — Interfaces" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipy-Interfaces" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типы — Interfaces
            </h2>
        
<hr>
<p><em>TypeScript</em> предлагает новый тип данных, определяемый с помощью синтаксической конструкции под названием <em>интерфейс</em> (<code class="inline-code">interface</code>). </p>
<p><code class="inline-code">Interface</code> — это синтаксическая конструкция, определяющая характеристики объектов. Другими словами, интерфейс — это тип, который содержит описание состояния и поведения объекта без реализации. Класс, реализующий интерфейс, обязан реализовать все его члены. Поэтому интерфейс является гарантией наличия всех характеристик описанных в нем у реализующего его объекта. Все члены, описанные в интерфейсе, неявно имеют модификатор доступа <code class="inline-code">public</code>. Интерфейс предназначен для описания открытого <code class="inline-code">api</code> объекта. То есть, с его помощью декларируют те члены, которые объект предоставляет программе.</p>
<p>Кроме того, интерфейсы являются фундаментальной составляющей идеологии как типизированных языков, так и объектно-ориентированного программирования.</p>
<p>Такая известная группа программистов, как <em>“Банда четырех”</em> (Gang of Four, сокращённо GoF), в своей книге, положившей начало популяризации шаблонов проектирования, описывали интерфейс как ключевую концепцию объектно-ориентированного программирования. Понятие интерфейса является настолько важным, что в книге был сформулирован принцип объектно-ориентированного проектирования, который звучит так: <em>Программируйте в соответствии с интерфейсом, а не с реализацией.</em></p>
<p>Другими словами, авторы советуют создавать систему, которой вообще ничего не будет известно о реализации. Проще говоря, создаваемая система должна быть построена на типах, определяемых интерфейсами, а не на типах, определяемых классами.</p>
</section><section id="Obyavlenie-declaration" name="Объявление (declaration)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Obyavlenie-declaration" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Объявление (declaration)
            </h2>
        
<hr>
<p>В <em>TypeScript</em> интерфейс объявляется с помощью ключевого слова <code class="inline-code">interface</code> с последующим идентификатором, после которых начинается тело интерфейса, заключенное в фигурные скобки. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier {
    <span class="hljs-comment">// тело интерфейса </span>
}</code></pre>
<p>Объявление интерфейса возможно как в контексте модуля, так и в контексте функции или метода.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier {} <span class="hljs-comment">// контекст модуля</span>

<span class="hljs-keyword">class</span> T {
    <span class="hljs-keyword">public</span> method(): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">interface</span> Identifier {} <span class="hljs-comment">// контекст метода</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{
   <span class="hljs-keyword">interface</span> Identifier {} <span class="hljs-comment">// контекст функции</span>
}</code></pre>
</section><section id="Konvencii-imenovaniya-interfeisov" name="Конвенции именования интерфейсов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Konvencii-imenovaniya-interfeisov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Конвенции именования интерфейсов
            </h2>
        
<hr>
<p>Прежде чем продолжить, нужно обратить внимание на такой аспект, как конвенции именования интерфейсов. Существует два вида именования. </p>
<p>Первый вид конвенций родом из языка <em>Java</em> — они предлагают именовать интерфейсы точно так же, как и классы. Допускаются имена прилагательные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier {}</code></pre>
<p>Второй вид предлагает использовать конвенции языка <em>C#</em>, по которым интерфейсы именуются так же как классы, но с префиксом <code class="inline-code">I</code>, что в сокращении означает <em>Interface</em>. Такой вид записи получил название “венгерская нотация” в честь программиста венгерского происхождения, работавшего в компании <em>MicroSoft</em>. Допускаются имена прилагательные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIdentifier {}</code></pre>
<p>Чтобы сразу расставить все точки над i, стоит заметить, что в дальнейшем идентификаторы интерфейсов будут указываться по конвенциям <code class="inline-code">C#</code>.</p>
</section><section id="Realizaciya-interfeisa-implements" name="Реализация интерфейса (implements)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Realizaciya-interfeisa-implements" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Реализация интерфейса (implements)
            </h2>
        
<hr>
<p>Как уже было сказано в самом начале, все члены интерфейса являются открытыми (<code class="inline-code">public</code>) и не могут быть объявлены с модификатором <code class="inline-code">static</code>. Кроме того, в <em>TypeScript</em> интерфейсы не могут содержать реализацию.</p>
<p>Класс, реализующий интерфейс, обязан реализовывать его в полной мере. Любой класс, который хочет реализовать интерфейс, должен указать это с помощью ключевого слова <code class="inline-code">implements</code>, после которого следует идентификатор реализуемого интерфейса. Указание реализации классом интерфейса располагается между идентификатором класса и его телом. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;
    
    execute(command: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;
    
    execute(command: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {}
}</code></pre>
<p>Один класс может реализовывать сколько угодно интерфейсов. В этом случае реализуемые интерфейсы должны быть перечислены через запятую.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {}
<span class="hljs-keyword">interface</span> IOviparous {} <span class="hljs-comment">// указывает на возможность откладывать яйца</span>

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal, IOviparous {} </code></pre>
<p>В случае, когда класс расширяет другой класс, декларация реализации (<code class="inline-code">implements</code>) следует после декларации расширения (<code class="inline-code">extends</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {}
<span class="hljs-keyword">interface</span> IOviparous {} 

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal, IOviparous {} 

<span class="hljs-keyword">interface</span> IFlyable {}

<span class="hljs-keyword">class</span> Eagle <span class="hljs-keyword">extends</span> Bird <span class="hljs-keyword">implements</span> IFlyable {}</code></pre>
</section><section id="Deklaraciya-svoistv-get-i-set-accessors" name="Декларация свойств get и set (accessors)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Deklaraciya-svoistv-get-i-set-accessors" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Декларация свойств get и set (accessors)
            </h2>
        
<hr>
<p>Несмотря на то, что в интерфейсе можно декларировать поля и методы, в нем нельзя декларировать свойства <code class="inline-code">get</code> и <code class="inline-code">set</code> (аксессоры). Но, несмотря на это, задекларированное в интерфейсе поле может быть совместимо не только с полем, но и аксессорами. При этом нет разницы, будет в объекте объявлен <em>getter</em>, <em>setter</em> или оба одновременно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    id: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// только get</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
    <span class="hljs-keyword">get</span> id(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'bird'</span>;
    }
}

<span class="hljs-comment">// только set</span>
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">implements</span> IAnimal {
    <span class="hljs-keyword">set</span> id(value: <span class="hljs-built_in">string</span>) {}
}

<span class="hljs-comment">// и get и set</span>
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">implements</span> IAnimal {
    <span class="hljs-keyword">get</span> id(): <span class="hljs-built_in">string</span> {
     <span class="hljs-keyword">return</span> <span class="hljs-string">'insect'</span>;
    }

    <span class="hljs-keyword">set</span> id(value: <span class="hljs-built_in">string</span>) {}
}</code></pre>
</section><section id="Ukazanie-interfeisa-v-kachestve-tipa-interface-types" name="Указание интерфейса в качестве типа (interface types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Ukazanie-interfeisa-v-kachestve-tipa-interface-types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Указание интерфейса в качестве типа (interface types)
            </h2>
        
<hr>
<p>Класс, реализующий интерфейс, принадлежит к типу этого интерфейса. Класс, унаследованный от класса, реализующего интерфейс, также принадлежит к типу интерфейса. В таких случаях говорят, что класс наследует интерфейс.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {}

<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird();
<span class="hljs-keyword">let</span> raven: IAnimal = <span class="hljs-keyword">new</span> Raven();</code></pre>
<p>Класс, реализующий множество интерфейсов, принадлежит к типу каждого из них. Когда экземпляру класса (который сам по себе является типом), реализующего интерфейс, присваивают ссылки с типом интерфейса, говорят, что ссылку ограничивают типом интерфейса. То есть, функционал экземпляра класса урезается до описанного в интерфейсе (подробнее об этом речь пойдет в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Sovmestimost-obektov" title="Типизация - Совместимость объектов" target="_blank">Типизация - Совместимость объектов</a> и <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Sovmestimost-funkcii" title="Типизация - Совместимость функций" target="_blank">Типизация - Совместимость функций</a>). </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IFlyable {
    flightHeight: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> IIdentifiable {
    id: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal <span class="hljs-keyword">implements</span> IFlyable {
    <span class="hljs-keyword">public</span> flightHeight: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;
}

<span class="hljs-keyword">var</span> animal: IAnimal = <span class="hljs-keyword">new</span> Bird(<span class="hljs-string">'bird'</span>); <span class="hljs-comment">// принадлежит к типу IAnimal</span>
<span class="hljs-keyword">var</span> fly: IFlyable = <span class="hljs-keyword">new</span> Bird(<span class="hljs-string">'bird'</span>); <span class="hljs-comment">// принадлежит к типу IFlyable</span></code></pre>
<p>Несмотря на то, что интерфейс является синтаксической конструкцией и может указываться в качестве типа, после компиляции от него не остается и следа. Это в свою очередь означает, что интерфейс, как тип данных, может использоваться только на этапе компиляции. Другими словами, компилятор сможет предупредить об ошибках несоответствия объекта описанному интерфейсу, но проверить на принадлежность к типу интерфейса с помощью таких операторов, как <code class="inline-code">typeof</code> или <code class="inline-code">instanceof</code>,  во время выполнения не получится. Но в <em>TypeScript</em> существует механизм (который будет рассмотрен далее в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Zashchitniki-tipa" title="Типизация - Защитники типа" target="_blank">Типизация - Защитники типа</a>), позволяющий в некоторой мере решить эту проблему.</p>
</section><section id="Rasshirenie-interfeisov-extends-interface" name="Расширение интерфейсов (extends interface)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirenie-interfeisov-extends-interface" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Расширение интерфейсов (extends interface)
            </h2>
        
<hr>
<p>Если множество логически связанных интерфейсов требуется объединить в один тип, то нужно воспользоваться механизмом расширения интерфейсов. Наследование интерфейсов осуществляется с помощью ключевого слова <code class="inline-code">extends</code>, после которого через запятую идет один или несколько идентификаторов расширяемых интерфейсов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIdentifiable {}
<span class="hljs-keyword">interface</span> ILiving {}

<span class="hljs-comment">// интерфейсы IIdentifiable и ILiving вместе образуют логически связанную композицию, </span>
<span class="hljs-comment">// которую можно выделить в тип интерфейс IAnimal</span>
<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> IIdentifiable, ILiving {}</code></pre>
<p>Для тех кто только знакомится с таким понятием как интерфейсы, будет не лишним узнать о <em>“Принципе разделения интерфейсов”</em> (Interface Segregation Principle или сокращенно ISP). Этот принцип гласит, что более крупные интерфейсы нужно “дробить” на более мелкие интерфейсы. Но нужно понимать, что условия дробления диктуются конкретным приложением. Если во всех случаях руководствоваться только принципами, то можно раздуть небольшое приложение до масштабов вселенной.</p>
<p>Для примера представьте приложение, которое только выводит в консоль информацию о животных. Так как над объектом <code class="inline-code">Animal</code> будет выполняться только одна операция, то можно не бояться разгневать богов объектно-ориентированного проектирования и включить все нужные характеристики прямо в интерфейс <code class="inline-code">IAnimal</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    id: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {
    <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly id: <span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-keyword">class</span> AnimalUtil {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> print(animal: IAnimal): <span class="hljs-built_in">void</span> {
        <span class="hljs-built_in">console</span>.log(animal);
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">super</span>(<span class="hljs-string">'raven'</span>);
    }
}

<span class="hljs-keyword">let</span> raven: Raven = <span class="hljs-keyword">new</span> Raven();

AnimalUtil.print(raven);</code></pre>
<p>В такой программе, кроме интересов архитектора, ничего пострадать не может, так как она выполняет только одну операцию вывода информации о животном.</p>
<p>Но если переписать программу, чтобы она выполняла несколько, не связанных логически операций над одним типом, в данном случае <code class="inline-code">IAnimal</code>, то ситуация изменится на противоположную.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> AnimalUtil {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printId(animal: IAnimal): <span class="hljs-built_in">void</span> {
        <span class="hljs-built_in">console</span>.log(animal.id); <span class="hljs-comment">// вывод  id</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printAge(animal: IAnimal): <span class="hljs-built_in">void</span> {
        <span class="hljs-built_in">console</span>.log(animal.age); <span class="hljs-comment">// вывод age</span>
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">let</span> raven: Raven = <span class="hljs-keyword">new</span> Raven();

AnimalUtil.printId(raven);
AnimalUtil.printAge(raven);</code></pre>
<p>В этом случае программа нарушает принцип <em>ISP</em>, так как статические методы <code class="inline-code">printId</code> и <code class="inline-code">printAge</code> получили доступ к данным, которые им не требуются для успешного выполнения. Это может привести к намеренной или по неосторожности порче данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> AnimalUtil {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printId(animal: IAnimal): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// для успешного выполнения этого метода </span>
        <span class="hljs-comment">// не требуется доступ к данным о animal.age</span>
        <span class="hljs-built_in">console</span>.log(animal.id);
    }

 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printAge(animal: IAnimal): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// для успешного выполнения этого метода </span>
        <span class="hljs-comment">// не требуется доступ к данным о animal.id</span>
        <span class="hljs-built_in">console</span>.log(animal.age);
    }
}</code></pre>
<p>Поэтому в подобных ситуациях настоятельно рекомендуется “дробить” типы интерфейсов на меньшие составляющие, а затем с их помощью ограничивать доступ к данным в тех местах, где это требуется принципом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIdentifiable {}
<span class="hljs-keyword">interface</span> ILiving {}

<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> IIdentifiable, ILiving {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> AnimalUtil {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printId(animal: IIdentifiable): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// параметр animal ограничен типом IIdentifiable</span>
        <span class="hljs-built_in">console</span>.log(animal.id);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printAge(animal: ILiving): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// параметр animal ограничен типом ILiving</span>
        <span class="hljs-built_in">console</span>.log(animal.age);
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">let</span> raven: Raven = <span class="hljs-keyword">new</span> Raven();

AnimalUtil.printId(raven);
AnimalUtil.printAge(raven);</code></pre>
</section><section id="Rasshirenie-interfeisom-klassa-extends-class" name="Расширение интерфейсом класса (extends class)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirenie-interfeisom-klassa-extends-class" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Расширение интерфейсом класса (extends class)
            </h2>
        
<hr>
<p>В случаях, когда нужно создать интерфейс для уже имеющегося класса, больше не нужно тратить силы на перечисление членов класса в интерфейсе. В <em>TypeScript</em> интерфейсу достаточно расширить класс.</p>
<p>Когда интерфейс расширяет класс, он наследует описание членов, но не их реализацию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    nickname: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
    nickname:<span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird();</code></pre>
<p>Но с расширением класса интерфейсом существует один нюанс.</p>
<p>Наравне с публичными (<code class="inline-code">public</code>) членами класса, интерфейс также наследует закрытые (<code class="inline-code">private</code>) и защищенные (<code class="inline-code">protected</code>) члены класса. Подобный интерфейс может быть реализован только самим классом или его потомками.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">private</span> uid: <span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">protected</span> maxAge: <span class="hljs-built_in">number</span>;
    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal <span class="hljs-keyword">implements</span> IAnimal { <span class="hljs-comment">// Ok</span>
    <span class="hljs-comment">// private uid: string = ''; // Error, private</span>
    <span class="hljs-keyword">protected</span> maxAge: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// Ok, protected</span>
    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bird'</span>; <span class="hljs-comment">// Ok,  public</span>
}

<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">implements</span> IAnimal { <span class="hljs-comment">// Error</span>
    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'fish'</span>;
}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird(); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> fish: IAnimal = <span class="hljs-keyword">new</span> Fish(); <span class="hljs-comment">// Error</span></code></pre>
</section><section id="Opisanie-klassa-funkcii-konstruktora" name="Описание класса (функции-конструктора)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opisanie-klassa-funkcii-konstruktora" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Описание класса (функции-конструктора)
            </h2>
        
<hr>
<p>Известный факт, что в <em>JavaScript</em>, а следовательно и в TypeScript, конструкция <code class="inline-code">class</code> - это лишь <em>“синтаксический сахар”</em> над старой доброй функцией-конструктором. Эта особенность позволяет описывать интерфейсы не только для экземпляров класса, но и для самих классов (функций-конструкторов). Другими словами, в интерфейсе можно описать конструктор, а также статические члены класса, но с одной оговоркой — этот интерфейс можно использовать только в качестве типа. То есть класс не может указывать реализацию такого интерфейса с помощью ключевого слова <code class="inline-code">implements</code>.</p>
<p>Описывать интерфейс для функции конструктора может потребоваться тогда, когда в качестве значения выступает сам класс.</p>
<p>Конструктор указывается с помощью ключевого слова <code class="inline-code">new</code>, затем открываются фигурные скобки в которых, при наличии, указываются параметры. В конце указывается тип возвращаемого значения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">new</span>(p1: <span class="hljs-keyword">type</span>, p2: <span class="hljs-keyword">type</span>): <span class="hljs-keyword">type</span>;</code></pre>
<p>Статические члены описываются также, как и обычные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">nickname: <span class="hljs-built_in">string</span></span>) { 
        <span class="hljs-keyword">this</span>.nickname = nickname;
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">static</span> DEFAULT_NAME: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bird'</span>;

    <span class="hljs-keyword">static</span> create(): IAnimal {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bird( Bird.DEFAULT_NAME);
    }
}

<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">static</span> DEFAULT_NAME: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bird'</span>;
    
    <span class="hljs-keyword">static</span> create(): IAnimal {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bird( Bird.DEFAULT_NAME);
    }
}

<span class="hljs-keyword">const</span> bird: Bird = <span class="hljs-keyword">new</span> Bird(<span class="hljs-string">'bird'</span>);
<span class="hljs-keyword">const</span> fish: Fish = <span class="hljs-keyword">new</span> Fish(<span class="hljs-string">'fish'</span>);

<span class="hljs-keyword">let</span> a: IAnimal[] = [bird, fish]; <span class="hljs-comment">// Ok, массив экземпляров классов реализующих интерфейс IAnimal</span>
<span class="hljs-keyword">let</span> b: IAnimal[] = [Bird, Fish]; <span class="hljs-comment">// Error, массив классов</span>

<span class="hljs-keyword">interface</span> IAnimalConstructor { <span class="hljs-comment">// декларация интерфейса для класса</span>
    create(): IAnimal; <span class="hljs-comment">// static method</span>
    <span class="hljs-keyword">new</span> (nickname: <span class="hljs-built_in">string</span>): IAnimal; <span class="hljs-comment">// конструктор</span>
}

<span class="hljs-keyword">let</span> c: IAnimalConstructor[] = [Bird, Fish]; <span class="hljs-comment">// Ok, массив классов</span>
<span class="hljs-keyword">let</span> d: IAnimal[] = c.map(<span class="hljs-function"><span class="hljs-params">item</span> =></span> item.create()); <span class="hljs-comment">// Ok, массив экземпляров классов реализующих интерфейс IAnimal</span></code></pre>
</section><section id="Opisanie-funkcionalnogo-vyrajeniya" name="Описание функционального выражения" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opisanie-funkcionalnogo-vyrajeniya" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Описание функционального выражения
            </h2>
        
<hr>
<p>Помимо экземпляров и самих классов, интерфейсы можно описывать для функциональных выражений. Это очень удобно, когда функциональный тип имеет очень большую сигнатуру, которая делает код менее читабельным. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;</span>
<span class="hljs-keyword">var</span> callback: <span class="hljs-function">(<span class="hljs-params">previusValue: <span class="hljs-built_in">number</span>, currentValue: <span class="hljs-built_in">number</span>, currentIndex: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">number</span>[]</span>) =></span> <span class="hljs-built_in">number</span>;</code></pre>
<p>В большинство подобных случаев, можно прибегнуть к помощи вывода типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;</span>

<span class="hljs-keyword">var</span> callback: <span class="hljs-function">(<span class="hljs-params">previusValue: <span class="hljs-built_in">number</span>, currentValue: <span class="hljs-built_in">number</span>, currentIndex: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">number</span>[]</span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">var</span> callback = <span class="hljs-function">(<span class="hljs-params">previusValue: <span class="hljs-built_in">number</span>, currentValue: <span class="hljs-built_in">number</span>, currentIndex: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">number</span>[]</span>) =></span> previusValue + currentValue;

<span class="hljs-keyword">let</span> numberAll: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>];

<span class="hljs-keyword">let</span> sum: <span class="hljs-built_in">number</span> = numberAll.reduce(callback); <span class="hljs-comment">// 50</span></code></pre>
<p>Но в случае, если функциональное выражение является параметром функции, как например метод массива <code class="inline-code">reduce</code>, то решением может служить только явная декларация типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Collection&#x3C;T> {
    reduce(callbackfn: <span class="hljs-function">(<span class="hljs-params">previousValue: T, currentValue: T, currentIndex: <span class="hljs-built_in">number</span>, array: T[]</span>) =></span> T, initialValue?: T): T {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}</code></pre>
<p>Поэтому тогда, когда необходимо указать тип явно, помимо рассмотренного в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Type-Queries-zaprosy-tipa-Alias-psevdonimy-tipa" title="Типы - Type Queries (запросы типа), Alias (псевдонимы типа)" target="_blank">Типы - Type Queries (запросы типа), Alias (псевдонимы типа)</a> механизма создания псевдонимов типа (<code class="inline-code">type</code>), можно описать функциональное выражение с помощью интерфейса.</p>
<p>Для этого, в теле интерфейса декларируется сигнатура функции без указания идентификатора.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> ISumAll {
    (...valueAll: <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> sumAll: ISumAll = <span class="hljs-function">(<span class="hljs-params">...valueAll: <span class="hljs-built_in">number</span>[]</span>) =></span>
    valueAll.reduce(<span class="hljs-function">(<span class="hljs-params">result, value</span>) =></span> result += value, <span class="hljs-number">0</span>);


<span class="hljs-keyword">let</span> numberAll: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>];

<span class="hljs-keyword">let</span> sum: <span class="hljs-built_in">number</span> = sumAll(...numberAll);</code></pre>
</section><section id="Opisanie-indeksnyh-chlenov-v-obektnyh-tipov" name="Описание индексных членов в объектных типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opisanie-indeksnyh-chlenov-v-obektnyh-tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Описание индексных членов в объектных типов
            </h2>
        
<hr>
<p>Индексные члены подробно будут рассматриваться в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Obektnye-tipy-s-indeksnymi-chlenami-obektnyi-tip-s-dinamicheskimi-kluchami" title="Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)" target="_blank">Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)</a>, но не будет лишним и здесь просто указать способ их декларации в типе интерфейсе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIndentifier  {
    [BindingIdentifier: <span class="hljs-built_in">string</span>]: Type;
    [BindingIdentifier: <span class="hljs-built_in">number</span>]: Type;
}</code></pre>
</section><section id="Inlain-interfeisy-Inline-Interface" name="Инлайн интерфейсы (Inline Interface)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Inlain-interfeisy-Inline-Interface" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Инлайн интерфейсы (Inline Interface)
            </h2>
        
<hr>
<p>Помимо описания объекта, в конструкции объявляемой с помощью ключевого слова <code class="inline-code">interface</code>, тип объекта можно описать прямо в месте указания типа. Такой способ объявления типа данных, неформально называют <em>инлайн интерфейс</em> (inline interface). Всё ранее описанное для типов определяемых интерфейсами, полностью верно для типов определяемых инлайн интерфейсами.</p>
<p>Различие между обычным интерфейсом и инлайн интерфейсом в том, что второй имеет только тело и объявляется прямо в аннотации типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> identifier: { p1: <span class="hljs-keyword">type</span>, p2: <span class="hljs-keyword">type</span> };</code></pre>
<p>Интерфейс, объявленный с помощью ключевого слова <code class="inline-code">interface</code>, считается идентичным инлайн интерфейсу, если их описание совпадает. Но стоит обратить внимание, что это возможно благодаря структурной типизации, которая рассматривается в главе <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-vida-tipizacii" title="Экскурс в типизацию - Совместимость типов на основе вида типизации" target="_blank">Экскурс в типизацию - Совместимость типов на основе вида типизации</a>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">implements</span> IAnimal {
    nickname: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird(); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> fish: { nickname: <span class="hljs-built_in">string</span> } = <span class="hljs-keyword">new</span> Fish(); <span class="hljs-comment">// Ok</span></code></pre>
<p>Как было сказано ранее, инлайн интерфейс можно объявлять в тех местах, в которых допускается указание типа. Тем не менее реализовывать (<code class="inline-code">implements</code>) и расширять (<code class="inline-code">extends</code>) инлайн интерфейс нельзя. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IT1{}
<span class="hljs-keyword">interface</span> IT2{}

<span class="hljs-keyword">interface</span> IT3 <span class="hljs-keyword">extends</span> { f1: IT1, f2: IT2 } { <span class="hljs-comment">// Error</span>

}

<span class="hljs-keyword">class</span> T4 <span class="hljs-keyword">implements</span> { f1: T1, f2: T2 } { <span class="hljs-comment">// Error</span>

}</code></pre>
<p>Хотя последнее утверждение и не совсем верно. В дальнейшем будет рассказано о такой замечательной конструкции, как обобщения (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Obobshcheniya-Generics" title="Типы - Обобщения (Generics)" target="_blank">Типы - Обобщения (Generics)</a>), в которых, как раз таки возможно расширять (<code class="inline-code">extends</code>) инлайн интерфейсы.</p>
</section><section id="Sliyanie-interfeisov" name="Слияние интерфейсов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sliyanie-interfeisov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Слияние интерфейсов
            </h2>
        
<hr>
<p>В случае, если в одной области видимости объявлено несколько одноимённых интерфейсов, то они будут объединены в один.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// так видят разработчики</span>
<span class="hljs-keyword">interface</span> IAnimal {
    name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IAnimal {
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">//так видит компилятор</span>
<span class="hljs-comment">/**
interface IAnimal {
    name: string;
    age: number;
}
*/</span>

<span class="hljs-comment">// разработчики получают то, что видит компилятор</span>
<span class="hljs-keyword">let</span> animal: IAnimal;
animal.name = <span class="hljs-string">'animal'</span>; <span class="hljs-comment">// Ok</span>
animal.age = <span class="hljs-number">0</span>; <span class="hljs-comment">// Ok</span></code></pre>
<p>При попытке переопределить тип поля, возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
    name: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> IAnimal {
    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok</span>
    age: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Если в нескольких одноимённых интерфейсах будут описаны одноимённые методы с разными сигнатурами, то они будут расценены, как описание перегрузки. К тому же, интерфейсы, которые описывают множество одноимённых методов, сохраняют свой внутренний порядок.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IBird {}
<span class="hljs-keyword">interface</span> IFish {}
<span class="hljs-keyword">interface</span> IInsect {}
<span class="hljs-keyword">interface</span> IReptile {}

<span class="hljs-comment">// до компиляции</span>
<span class="hljs-keyword">interface</span> IAnimalFactory { 
    getAnimalByID(id: <span class="hljs-built_in">number</span>): IBird;
}

<span class="hljs-keyword">interface</span> IAnimalFactory {
    getAnimalByID(id: <span class="hljs-built_in">string</span>): IFish;
}

<span class="hljs-keyword">interface</span> IAnimalFactory {
    getAnimalByID(id: <span class="hljs-built_in">boolean</span>): IInsect;
    getAnimalByID(id: object): IReptile;
}

<span class="hljs-comment">/** при компиляции
interface IAnimalFactory { 
    getAnimalByID(id: string): IInsect;
    getAnimalByID(id: string): IReptile;
    getAnimalByID(id: string): IFish;
    getAnimalByID(id: string): IBird;
}
*/</span>
<span class="hljs-keyword">let</span> animal: IAnimalFactory;
<span class="hljs-keyword">let</span> v1 = animal.getAnimalByID(<span class="hljs-number">0</span>); <span class="hljs-comment">// Ok -> v1: IBird</span>
<span class="hljs-keyword">let</span> v2 = animal.getAnimalByID(<span class="hljs-string">'5'</span>); <span class="hljs-comment">// Ok -> v2: IFish</span>
<span class="hljs-keyword">let</span> v3 = animal.getAnimalByID(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Ok -> v3: IInsect</span>
<span class="hljs-keyword">let</span> v4 = animal.getAnimalByID({}); <span class="hljs-comment">// Ok -> v4: IReptile</span></code></pre>
<p>Исключением из этого правила являются сигнатуры, которые имеют в своем описании литеральные строковые типы данных (<code class="inline-code">literal String Types</code>). Дело в том, что сигнатуры содержащие в своем описании литеральные строковые типы, всегда размещаются перед сигнатурами, у которых нет в описании литеральных строковых типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IBird {}
<span class="hljs-keyword">interface</span> IFish {}
<span class="hljs-keyword">interface</span> IInsect {}
<span class="hljs-keyword">interface</span> IReptile {}

<span class="hljs-comment">// до компиляции</span>
<span class="hljs-keyword">interface</span> IAnimalFactory { 
    getAnimalByID(id: <span class="hljs-built_in">string</span>): IBird;
}

<span class="hljs-keyword">interface</span> IAnimalFactory {
    getAnimalByID(id: <span class="hljs-string">'fish'</span>): IFish;
}

<span class="hljs-keyword">interface</span> IAnimalFactory {
    getAnimalByID(id: <span class="hljs-string">'insect'</span>): IInsect;
    getAnimalByID(id: <span class="hljs-built_in">number</span>): IReptile;
}

<span class="hljs-comment">/** при компиляции
interface IAnimalFactory {
    getAnimalByID(id: 'fish'): IFish;
    getAnimalByID(id: 'insect'): IInsect;
    getAnimalByID(id: number): IReptile;
    getAnimalByID(id: string): IBird;
}
*/</span></code></pre>
</section>