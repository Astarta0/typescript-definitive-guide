<section id="Diskriminantnoe-Obedineniya-Discriminated-Union" name="Дискриминантное Объединения (Discriminated Union)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Diskriminantnoe-Obedineniya-Discriminated-Union" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Дискриминантное Объединения (Discriminated Union)
            </h2>
        
<hr>
<p>Тип <code class="inline-code">Discriminated Unions</code> (<em>дискриминантное объединение</em>), часто обозначаемое как <code class="inline-code">Tagged Union</code> (<em>размеченное объединение</em>), так же как и тип <code class="inline-code">Union</code> (объединение), представляет собой множество типов данных,  значение которого может принадлежать к одному конкретному типу. Размеченные объединения указывается с помощью оператора прямой черты <code class="inline-code">|</code>, по обе стороны которой располагаются типы данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v1: T1 | T2 | T3;</code></pre>
<p>Из-за того, что все описанное ранее для типа <code class="inline-code">Union</code> (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Union-Intersection" title="Типы - Union, Intersection" target="_blank">Типы - Union, Intersection</a>) идентично и для <code class="inline-code">Tagged Union</code>, будет более разумно не повторяться, а сделать упор на различия. Но так как полное погружение, которое сможет приоткрыть завесу тайны <code class="inline-code">Tagged Union</code>, выходит за рамки темы, или, точнее, будет преждевременным, остается лишь описать детали, к которым рекомендуется вернуться, как только наступит время. Итак…</p>
<p>Несмотря на то, что <code class="inline-code">Discriminated Union</code> в большей степени идентичен типу <code class="inline-code">Union</code>, все же существует два отличия. Первое отличие заключается в том, что к типу <code class="inline-code">Discriminated Union</code> могут принадлежать только ссылочные типы данных. Второе отличие в том, что каждому объектному типу, которые ещё называют варианты, составляющему <code class="inline-code">Discriminated Union</code>, указывается идентификатор варианта - <em>дискриминант</em>.</p>
<p>Помните ли вы что компилятор без помощи разработчика способен работать лишь с общими для всех типов признаками?</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    fly(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'bird'</span>;
    }
}

<span class="hljs-keyword">class</span> Fish {
    swim(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'fish'</span>;
    }
}
<span class="hljs-keyword">class</span> Insect {
    crawl(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'insect'</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
    animal.fly(); <span class="hljs-comment">// Error -> [*]</span>
    animal.swim(); <span class="hljs-comment">// Error -> [*]</span>
    animal.crawl(); <span class="hljs-comment">// Error -> [*]</span>

    animal.toString(); <span class="hljs-comment">// Ok -> [*]</span>

    <span class="hljs-comment">/**
     * [*]
     * 
     * Поскольку вывод типо не может
     * определить к какому конкретно
     * из трех типов принадлежит параметр
     * animal он не позволяет обращатся к
     * уникальным для каждого типа членам
     * коими являются методы fly, swim, crawl.
     * 
     * В отличии от этих методов, метод toString
     * определен в каждом из возможных типов,
     * поэтому при его вызове ошибки не возникает. 
     */</span>
    
}</code></pre>
<p>Так вот, чтобы компилятор смог работать с членами, характерных конкретным типам составляющих дискриминантное объединение, одним из способов является сужение диапазона типов с помощью <em>дискриминанта</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>; <span class="hljs-comment">// дискриминант</span>

    fly(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'bird'</span>;
    }
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>; <span class="hljs-comment">// дискриминант</span>

    swim(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'fish'</span>;
    }
}

<span class="hljs-keyword">class</span> Insect {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'insect'</span> = <span class="hljs-string">'insect'</span>; <span class="hljs-comment">// дискриминант</span>

    crawl(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'insect'</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'bird'</span>) {
        animal.fly(); <span class="hljs-comment">// Ok</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'fish'</span>) {
        animal.swim(); <span class="hljs-comment">// Ok</span>
    } <span class="hljs-keyword">else</span> {
        animal.crawl(); <span class="hljs-comment">// Ok</span>
    }

    animal.toString(); <span class="hljs-comment">// Ok</span>
}</code></pre>
<p>Механизм, с помощью которого разработчик помогает выводу типов, называется <em>защитники типа</em>, и  будет рассмотрен позднее в одноимённой главе  (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Zashchitniki-tipa" title="Типизация - Защитники типа" target="_blank">Типизация - Защитники типа</a>). А пока стоит сосредоточиться на самих идентификаторах вариантов.</p>
<p>Прежде всего стоит пояснить, что дискриминант это одноименные поля присущие каждому типу составляющему <em>дискриминантное объединение</em> тип которых обязательно должен принадлежать только к литеральным типам, таким как <code class="inline-code">Literal Number</code>, <code class="inline-code">Literal String</code>, <code class="inline-code">Literal Boolean</code>, <code class="inline-code">Literal Enum</code>. Кроме того, поля обязательно должны быть инициализированы при объявлении или в конструкторе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>; <span class="hljs-comment">// инициализация в момент объявления поля</span>

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>; <span class="hljs-comment">// инициализация в момент объявления поля</span>

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'insect'</span>;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'insect'</span>; <span class="hljs-comment">// инициализация в конструкторе</span>
    }

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>В случае, когда типы полей являются уникальными для всего множества, они идентифицируют только свой тип.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    groupID: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    groupID: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    groupID: <span class="hljs-number">2</span> = <span class="hljs-number">2</span>;

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-comment">// groupID 0 === Bird</span>
<span class="hljs-comment">// groupID 1 === Fish</span>
<span class="hljs-comment">// groupID 2 === Insect</span></code></pre>
<p>Тогда, когда тип поля не является уникальным, он идентифицирует множество типов, у которых совпадают типы одноимённых идентификаторов вариантов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    groupID: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    groupID: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    groupID: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-comment">// groupID 0 === Bird | Fish</span>
<span class="hljs-comment">// groupID 1 === Insect</span></code></pre>
<p>Количество полей, которые служат идентификаторами вариантов, может быть любым.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> AnimalTypes {
    Bird = <span class="hljs-string">'bird'</span>,
    Fish = <span class="hljs-string">'fish'</span>,
}


<span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: AnimalTypes.Bird = AnimalTypes.Bird;

    fly(): <span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">class</span> Robin <span class="hljs-keyword">extends</span> Bird {
    id: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">class</span> Starling <span class="hljs-keyword">extends</span> Bird {
    id: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;
}


<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: AnimalTypes.Fish = AnimalTypes.Fish;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Shark <span class="hljs-keyword">extends</span> Fish {
    id: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">class</span> Barracuda <span class="hljs-keyword">extends</span> Fish {
    id: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;
}



<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> animal: Robin | Starling | Shark | Barracuda;



<span class="hljs-keyword">if</span>(animal.type === AnimalTypes.Bird){
    <span class="hljs-comment">/**
     * В области вижимости этого блока if
     * константа animal принадлежит к типу Bird или Starling
     */</span>
    animal; <span class="hljs-comment">// const animal: Robin | Starling</span>

    <span class="hljs-keyword">if</span>(animal.id === <span class="hljs-number">0</span>){
        <span class="hljs-comment">/**
         * В области вижимости этого блока if
         * константа animal принадлежит к типу Robin
         */</span>
        animal; <span class="hljs-comment">// const animal: Robin</span>
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">/**
         * В области вижимости этого блока else
         * константа animal принадлежит к типу Starling
         */</span>

        animal; <span class="hljs-comment">// const animal: Starling</span>
    }
}<span class="hljs-keyword">else</span>{
    <span class="hljs-comment">/**
     * В области вижимости этого блока if
     * константа animal принадлежит к типу Shark или Barracuda
     */</span>

    animal; <span class="hljs-comment">// const animal: Shark | Barracuda</span>

    <span class="hljs-keyword">if</span>(animal.id === <span class="hljs-number">0</span>){
        <span class="hljs-comment">/**
         * В области вижимости этого блока if
         * константа animal принадлежит к типу Shark
         */</span>
        animal; <span class="hljs-comment">// const animal: Shark</span>
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">/**
         * В области вижимости этого блока else
         * константа animal принадлежит к типу Barracuda
         */</span>

        animal; <span class="hljs-comment">// const animal: Barracuda</span>
    }
}</code></pre>
</section>