<section id="Razmechennye-Obedineniya-Tagged-Union" name="Размеченные Объединения (Tagged Union)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Razmechennye-Obedineniya-Tagged-Union" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Размеченные Объединения (Tagged Union)
            </h2>
        
<hr>
<p>Тип <code class="inline-code">Tagged Union</code> (размеченное объединение), ещё известный как <code class="inline-code">Discriminated Unions</code>, так же как и тип <code class="inline-code">Union</code> (объединение), представляет собой множество типов данных,  значение которого может принадлежать к одному конкретному типу. Размеченные объединения указывается с помощью оператора прямой черты <code class="inline-code">|</code>, по обе стороны которой располагаются типы данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v1: T1 | T2 | T3;</code></pre>
<p>Из-за того, что все описанное ранее для типа <code class="inline-code">Union</code> (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Union-Intersection" title="Типы - Union, Intersection" target="_blank">Типы - Union, Intersection</a>) идентично и для <code class="inline-code">Tagged Union</code>, будет более разумно не повторяться, а сделать упор на различия. Но так как полное погружение, которое сможет приоткрыть завесу тайны <code class="inline-code">Tagged Union</code>, выходит за рамки темы, или, точнее, будет преждевременным, остается лишь описать детали, к которым рекомендуется вернуться, как только наступит время. Итак…</p>
<p>Несмотря на то, что <code class="inline-code">Tagged Union</code> в большей степени идентичен типу <code class="inline-code">Union</code>, все же существует два отличия. Первое отличие заключается в том, что к типу <code class="inline-code">Tagged Union</code> могут принадлежать только ссылочные типы данных. Второе отличие в том, что каждому объектному типу, которые ещё называют варианты, составляющему <code class="inline-code">Tagged Union</code>, указывается идентификатор варианта.</p>
<p>Помните ли вы что компилятор без помощи разработчика способен работать лишь с общими для всех типов признаками?</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    fly(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'bird'</span>;
    }
}

<span class="hljs-keyword">class</span> Fish {
    swim(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'fish'</span>;
    }
}
<span class="hljs-keyword">class</span> Insect {
    crawl(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'insect'</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
    animal.fly(); <span class="hljs-comment">// Error</span>
    animal.swim(); <span class="hljs-comment">// Error</span>
    animal.crawl(); <span class="hljs-comment">// Error</span>

    animal.toString(); <span class="hljs-comment">// Ok</span>
}</code></pre>
<p>Так вот, чтобы компилятор смог работать с членами, характерными для конкретных типов, одним из способов является указание ему конкретного диапазона типов с помощью идентификатора варианта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>;

    fly(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'bird'</span>;
    }
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>;

    swim(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'fish'</span>;
    }
}

<span class="hljs-keyword">class</span> Insect {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'insect'</span> = <span class="hljs-string">'insect'</span>;

    crawl(): <span class="hljs-built_in">void</span> {}

    toString(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'insect'</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'bird'</span>) {
        animal.fly(); <span class="hljs-comment">// Ok</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'fish'</span>) {
        animal.swim(); <span class="hljs-comment">// Ok</span>
    } <span class="hljs-keyword">else</span> {
        animal.crawl(); <span class="hljs-comment">// Ok</span>
    }

    animal.toString(); <span class="hljs-comment">// Ok</span>
}</code></pre>
<p>Механизм, с помощью которого разработчик помогает выводу типов, называется <em>“защитники типа”</em>, и  будет рассмотрен позднее в одноимённой главе  (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Zashchitniki-tipa" title="Типизация - Защитники типа" target="_blank">Типизация - Защитники типа</a>). А пока стоит сосредоточиться на самих идентификаторах вариантов.</p>
<p>Прежде всего стоит пояснить, что идентификаторы вариантов это обычные поля объекта, которые имеют одинаковые имена и которые обязательно должны присутствовать в каждом типе множества, составляющего <code class="inline-code">Tagged Union</code>. Помимо этого, поля обязательно должны принадлежать только к литеральным типам, таким как <code class="inline-code">Literal Number</code>, <code class="inline-code">Literal String</code>, <code class="inline-code">Literal Boolean</code>, <code class="inline-code">Literal Enum</code>. Кроме того, поля обязательно должны быть инициализированы при объявлении или в конструкторе. Но если быть до конца откровенным, то нет разницы, в каком месте и в какое время полю будет присвоено значение. Главное, чтобы оно было присвоено раньше, чем наступит момент использовать его в условии, на основе которого будет определяться его принадлежность к конкретному типу данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>;

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'insect'</span>;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'insect'</span>;
    }

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish | Insect</span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>В случае, когда типы полей являются уникальными для всего множества, они идентифицируют только свой тип.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    groupID: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    groupID: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    groupID: <span class="hljs-number">2</span> = <span class="hljs-number">2</span>;

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-comment">// groupID 0 === Bird</span>
<span class="hljs-comment">// groupID 1 === Fish</span>
<span class="hljs-comment">// groupID 2 === Insect</span></code></pre>
<p>Тогда, когда тип поля не является уникальным, он идентифицирует множество типов, у которых совпадают типы одноимённых идентификаторов вариантов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    groupID: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    groupID: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    groupID: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-comment">// groupID 0 === Bird | Fish</span>
<span class="hljs-comment">// groupID 1 === Insect</span></code></pre>
<p>Количество полей, которые служат идентификаторами вариантов, может быть любым.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> AnimalTypes {
    Bird = <span class="hljs-string">'bird'</span>,
    Fish = <span class="hljs-string">'fish'</span>,
    Insect = <span class="hljs-string">'insect'</span>
}

<span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: AnimalTypes.Bird = AnimalTypes.Bird;
    uid: <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;
    name: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>;

    fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: AnimalTypes.Fish = AnimalTypes.Fish;
    uid: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;
    name: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>;

    swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Insect {
    <span class="hljs-keyword">type</span>: AnimalTypes.Insect = AnimalTypes.Insect;
    uid: <span class="hljs-number">2</span> = <span class="hljs-number">2</span>;
    name: <span class="hljs-string">'insect'</span> = <span class="hljs-string">'insect'</span>;

    crawl(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-comment">// type AnimalTypes.Bird === Bird</span>
<span class="hljs-comment">// type AnimalTypes.Fish === Fish</span>
<span class="hljs-comment">// type AnimalTypes.Insect === Insect</span>

<span class="hljs-comment">// uid 0 === Bird</span>
<span class="hljs-comment">// uid 1 === Fish</span>
<span class="hljs-comment">// uid 2 === Insect</span>

<span class="hljs-comment">// name 'bird' === Bird</span>
<span class="hljs-comment">// name 'fish' === Fish</span>
<span class="hljs-comment">// name 'insect' === Insect</span></code></pre>
<p>Если по какой-либо причине разработчик забудет присвоить идентификатору вариантов значение, то для того, чтобы компиляция завершилась успехом, выводу типов достаточно литерального типа данных, указанного в качестве типа поля.</p>
<p><em>Пример с неправильным исходным кодом</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span>;
}

<span class="hljs-keyword">class</span> Fish {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'bird'</span>) { <span class="hljs-comment">// эквивалентно undefined === 'bird'</span>
        <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'fish'</span>) { <span class="hljs-comment">// эквивалентно undefined === 'fish'</span>
        <span class="hljs-comment">// ...</span>
    }
}</code></pre>
<p>Однако в скомпилированном коде от типов не останется и следа. Таким образом, в условие вместо значения будет находиться значение <code class="inline-code">undefined</code>, что сделает условия неверными.</p>
<p><em>Пример с неправильным скомпилированным кодом</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {} <span class="hljs-comment">// missing field type</span>
<span class="hljs-keyword">class</span> Fish {} <span class="hljs-comment">// missing field type</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal</span>) </span>{
    <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'bird'</span>) {
        <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'fish'</span>) {
        <span class="hljs-comment">// ...</span>
    }
}</code></pre>
<p>Поэтому очень важно не забыть присвоить значение идентификаторам вариантов, иначе может возникнуть трудно выявляемая ошибка.</p>
<p><em>Пример с правильным исходным кодом</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>;
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span> (animal.type === <span class="hljs-string">'bird'</span>) { <span class="hljs-comment">// эквивалентно 'bird' === 'bird'</span>
        <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(animal.type === <span class="hljs-string">'fish'</span>) { <span class="hljs-comment">// эквивалентно 'fish' === 'fish'</span>
        <span class="hljs-comment">// ...</span>
    }
}</code></pre>
<p><em>Пример с правильным скомпилированным кодом</em></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'bird'</span> = <span class="hljs-string">'bird'</span>;
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'fish'</span> = <span class="hljs-string">'fish'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">animal: Bird | Fish</span>): <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">if</span>(animal.type === <span class="hljs-string">'bird'</span>) { <span class="hljs-comment">// эквивалентно 'bird' === 'bird'</span>
        <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(animal.type === <span class="hljs-string">'fish'</span>) { <span class="hljs-comment">// эквивалентно 'fish' === 'fish'</span>
        <span class="hljs-comment">// ...</span>
    }
}</code></pre>
</section>