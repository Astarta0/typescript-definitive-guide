<section id="Zakrytye-polya-opredelennye-specifikaciei-ECMSript" name="Закрытые поля определенные спецификацией ECMSript" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Zakrytye-polya-opredelennye-specifikaciei-ECMSript" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Закрытые поля определенные спецификацией ECMSript
            </h2>
        
<p>Помимо сокрытия полей класса от внешней среды с помощью модификатора доступа <code class="inline-code">private</code>, присущего исключительно <em>TypeScript</em>, также существует возможность прибегнуть механизмом предусмотренного спецификацией <em>ECMScript</em>. Для того чтобы воспользоваться данным механизмом идентификаторы скрываемых полей должны начинаться с символа решетка <code class="inline-code">#</code>.
Доступ к защещенному полю класса ограничивается областью видимости класса в котором оно объявленно, а при обращении к нему необходимо также указывать символ решетка. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// защищенное поле класса</span>

    <span class="hljs-keyword">get</span> isLife(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#isLife;
    }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();
<span class="hljs-built_in">console</span>.log(animal.isLife); <span class="hljs-comment">// обращение к аксессору, а не защищенному полю</span></code></pre>
<p>Поскольку доступ ограничивается областью видимости класса, потомки не могут обращаться к защищенным полям своих предков.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// защищенное поле класса</span>
}
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.#isLife; <span class="hljs-comment">// Error! > Property '#isLife' is not accessible outside class 'Animal' because it has a private identifier.ts(18013)</span>
    }
}</code></pre>
<p>В отличии от модификатора доступа <code class="inline-code">private</code> данный механизм не может быть применен к методам класса, но так как за его появлением стоит спецификация <em>ECMScript</em>, он продолжает действовать в скомпилированной программе. Именно поэтому, в отличии от сценария с модификатором доступа <code class="inline-code">private</code>, <em>потомки</em> могут без страха нарушить ожидаемый ход выполнения программы объявлять защищенные поля чьи идентификаторы идентичны объявлениям в их <em>супер-классах</em>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// сценарий с модификатором доступа private</span>

<span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">private</span> _isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
    
}
<span class="hljs-comment">/**
 * Error!
 * 
 * Class 'Bird' incorrectly extends base class 'Animal'.
  Types have separate declarations of a private property '_isLife'.ts(2415)
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">private</span> _isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;

}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// сценарий с защищенными полями предусмотренными спецификацией ECMScript</span>

<span class="hljs-keyword">class</span> Animal {
    #isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
    
}
<span class="hljs-comment">/**
 * Ok!
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    #isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;

}</code></pre>
<p>И в заклчение стоит упомянуть что существует несколько нюансов. Один из них заключается в том, что закрытые поля нельзя объявлять непосредственно в конструкторе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-comment">// Parameter declaration expected.ts(1138)</span>
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">#isLife=<span class="hljs-literal">true</span></span>){}
    
}</code></pre>
<p>Другой нюанс связан с тем, что код содержащий закрытые поля класса может быть скомпилирован исключительно в версии <code class="inline-code">es6</code> и выше.</p>
</section>