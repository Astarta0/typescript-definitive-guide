<section id="Import-i-eksport-tolko-tipa" name="Импорт и экспорт только типа" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Import-i-eksport-tolko-tipa" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Импорт и экспорт только типа
            </h2>
        
<hr>
<p>Механизм уточнения импорта и экспорта (<code class="inline-code">import\export</code>) выступает в качестве указаний компилятору что данную конструкцию следует воспринимать исключительно как тип. Форма уточняющего импорта и экспорта включает в себя ключевое слово <code class="inline-code">type</code> идущее следом за ключевым словом <code class="inline-code">import</code> либо <code class="inline-code">export</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Type } <span class="hljs-keyword">from</span> <span class="hljs-string">'./type'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> { Type };</code></pre>
<p>Уточнению могут подвергаться только конструкции расцениваемые исключительно как типы (<code class="inline-code">interface</code>, <code class="inline-code">type alias</code> и <code class="inline-code">class</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IInterfaceType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AliasType = {};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { ClassType, IInterfaceType, AliasType } <span class="hljs-keyword">from</span> <span class="hljs-string">'./types'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> { ClassType, IInterfaceType, AliasType };</code></pre>
<p>Значения к которым можно отнести как экземпляры объектов, так и функции (<code class="inline-code">function expression</code> и <code class="inline-code">function declaration</code>) уточнятся, как в отдельности так и в одной форме с типами, не могут.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IInterfaceType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AliasType = {};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> o = {};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fe = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {};
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fd</span>(<span class="hljs-params"></span>) </span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">// import type { o, fe, fd } from './types'; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-comment">// import type { o, fe, fd, ClassType, IInterfaceType, AliasType } from './types'; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-keyword">import</span> { o, fe, fd } <span class="hljs-keyword">from</span> <span class="hljs-string">'./types'</span>; <span class="hljs-comment">// Ok!</span>

<span class="hljs-comment">// export type { o, fe, fd }; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-comment">// export type { o, fe, fd, ClassType, IInterfaceType, AliasType } from './types'; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-keyword">export</span> { o, fe, fd }; <span class="hljs-comment">// Ok!</span></code></pre>
<p>Кроме того, уточнённая форма импорта и экспорта не может одновременно содержать импорт\экспорт по умолчанию и не по умолчанию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> DefaultExportType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ExportType {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 * Error!
 * All imports in import declaration are unused.ts(6192)
 * A type-only import can specify a default import or named bindings, but not both.ts(1363)
 */</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> DefaultType, { ExportType } <span class="hljs-keyword">from</span> <span class="hljs-string">'./types'</span>;</code></pre>
<p>Будет не лишним оговорить, что классы экспортированные как уточнённые, не могут участвовать в механизме наследования.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file Base.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Base {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Base } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Base'</span>;

<span class="hljs-keyword">class</span> Derivied <span class="hljs-keyword">extends</span> Base {}; <span class="hljs-comment">// 'Base' only refers to a type, but is being used as a value here.ts(2693)</span></code></pre>
<p>В дополнение механизму уточнения формы импорта\экспорта был добавлен флаг <code class="inline-code">--importsNotUsedAsValues</code> ожидаемый одно из трех значений. Но прежде чем познакомится с каждым, предлагаю поглубже погрузится в природу возникновения необходимости в данном механизме.</p>
<p>Большинство разработчиков используя в повседневной работе механизм импорта\экспорта даже не подозревают что с ним связанно немало различных трудностей, которые возникают из-за механизмов призванных оптимизировать код. Но для начала рассмотрим несколько простых вводных примеров.</p>
<p>Представьте ситуацию, при которой один модуль импортирует необходимый ему тип представленный конструкцией <code class="inline-code">interface</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file IPerson.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPerson {
    name: <span class="hljs-built_in">string</span>;
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> { IPerson } <span class="hljs-keyword">from</span> <span class="hljs-string">'./IPerson'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person: IPerson</span>) </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Поскольку интерфейс является конструкцией присущей исключительно <em>TypeScript</em>, то не удивительно что после компиляции от неё не останется и следа.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>) </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Теперь представьте что один модуль импортирует конструкцию представленную классом, который задействован в логике уже знакомой нам функции <code class="inline-code">action()</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file IPerson.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPerson {
    name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Person {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name: <span class="hljs-built_in">string</span></span>) {}

    toString() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`[person <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>]`</span>;
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> { IPerson } <span class="hljs-keyword">from</span> <span class="hljs-string">'./IPerson'</span>;
<span class="hljs-keyword">import</span> { Person } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Person'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:IPerson</span>) </span>{
    <span class="hljs-keyword">new</span> Person(person);
}</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-keyword">import</span> { Person } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Person'</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>) </span>{
    <span class="hljs-keyword">new</span> Person(person);
}</code></pre>
<p>В этом случае класс <code class="inline-code">Person</code> был включён в скомпилированный файл поскольку необходим для правильного выполнения программы.</p>
<p>А теперь представьте ситуацию когда класс <code class="inline-code">Person</code> задействован в том же модуле <code class="inline-code">action.ts</code>, но исключительно в качестве типа. Другими словами он не задействован в логике работы модуля.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file Person.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Person {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name:<span class="hljs-built_in">string</span></span>) {}

    toString() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`[person <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>]`</span>;
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> { Person } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Person'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person: Person</span>) </span>{
    <span class="hljs-comment">//...</span>
}</code></pre>
<p>Подумайте, что должна включать в себя итоговая сборка? Если вы выбрали вариант идентичный первому, то вы совершенно правы! Поскольку класс <code class="inline-code">Person</code> используется в качестве типа то нет смысла включать его в результирующий файл.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>) </span>{
    <span class="hljs-comment">//...</span>
}</code></pre>
<p>Подобное поведение кажется логичным и возможно благодаря механизму называемому <em>import elision</em>. Этот механизм определяет что конструкции которые теоретически могут быть включены в скомпилированный модуль требуются ему исключительно в качестве типа. И как уже можно было догадаться именно с этим механизмом и связанны моменты мешающие оптимизации кода. Тут-то и вступает в дело механизм уточнения формы импорта\экспорта.</p>
<p>Механизм уточнения способен разрешить возникающие перед <em>import-elision</em> трудности при ре-экспорте модулей предотвращению которых способствует установленный в значение <code class="inline-code">true</code> флаг <code class="inline-code">--isolatedModules</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IActionParams {}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">params: IActionParams</span>) </span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file re-export.ts</span>

<span class="hljs-keyword">import</span> { IActionParams, action } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;

<span class="hljs-comment">/**
 * [Error! ts &#x3C;3.8] > Cannot re-export a type when the '--isolatedModules' flag is provided.ts(1205)
 *
 * [Error! ts >=3.8] > Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'.ts(1205)
 */</span>
<span class="hljs-keyword">export</span> { IActionParams, action };</code></pre>
<p>Поскольку компиляторы как TypeScript, так и Babel неспособны определить является ли конструкция IActionParams допустимой для JavaScript в контексте файла, существует вероятность возникновения ошибки. Простыми словами, механизмы обоих компиляторов не знают нужно ли удалять следы связанные с IActionParams из скомпилированного js-кода или нет. Именно поэтому был добавлен флаг --isolatedModules который предупреждает об опасной ситуации.</p>
<p>Рассмотренный выше случай можно разрешить с помощью явного уточнения формы импорта\экспорта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file re-export.ts</span>

<span class="hljs-keyword">import</span> { IActionParams, action } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;

<span class="hljs-comment">/**
 * Явно указываем что IActionParams это тип.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> { IActionParams };
<span class="hljs-keyword">export</span> { action };</code></pre>
<p>Специально введенный и ранее упомянутый флаг <code class="inline-code">--importsNotUsedAsValues</code>, как уже было сказано, ожидает одно из трех возможных на данный момент значений - <code class="inline-code">remove</code>, <code class="inline-code">preserve</code> или <code class="inline-code">error</code>.</p>
<p>Значение <code class="inline-code">remove</code> активирует, или другими словами, оставляет поведение реализуемое до версии <code class="inline-code">3.8</code>.
Значения <code class="inline-code">preserve</code> способно разрешить проблему возникающую при экспорте так называемых сайд-эффектов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-with-side-effects.ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementVisitCounterLocalStorage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// увеличиваем счетчик посещаемости в localStorage</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithSideEffects {};

incrementVisitCounterLocalStorage(); <span class="hljs-comment">// ожидается что вызов произойдет в момент подключения модуля</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> { IDataFromModuleWithSideEffects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;

<span class="hljs-keyword">let</span> data: IDataFromModuleWithSideEffects = {};</code></pre>
<p>Несмотря на то что модуль module-with-side-effects.ts задействован в коде, его содержимое не будет включено в скомпилированную программу, поскольку компилятор исключает импорты конструкций не участвующих в её логике. Таким образом функция incrementVisitCounterLocalStorage() никогда не будет вызвана, а значит программа не будет работать корректно!</p>
<p>В итоге программе ничего не известно о модуле module-with-side-effects.ts</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">let</span> data = {};</code></pre>
<p>Решение проблемы в ситуации описанной выше заключается в повторном указании импорта всего модуля. Но не всем такое решение кажется очевидным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-with-side-effects'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./module-with-side-effects'</span>; <span class="hljs-comment">// импорт всего модуля</span>

<span class="hljs-keyword">let</span> data:IDataFromModuleWithSideEffects = {};</code></pre>
<p> Теперь программа выполнится так как и ожидалось. То есть модуль module-with-side-effects.ts включен в её состав.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'./module-with-side-effects.js'</span>;

<span class="hljs-keyword">let</span> data = {};</code></pre>
<p>Поэтому прежде всего начиная с версии <code class="inline-code">3.8</code> сама <code class="inline-code">IDE</code> укажет на возможность уточнения импорта исключительно типов, что в свою очередь должно подтолкнуть на размышление об удалении импорта при компиляции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { IDataFromModuleWithSideEffects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-with-side-effects'</span>; <span class="hljs-comment">// This import may be converted to a type-only import.ts(1372)</span></code></pre>
<p>Кроме того флаг <code class="inline-code">preserve</code> в отсутствие уточнения поможет избавиться от повторного указания импорта. Простыми словами значение <code class="inline-code">preserve</code> указывает компилятору импортировать все модули полностью.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-with-side-effects.ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementVisitCounterLocalStorage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// увеличиваем счетчик посещаемости в localStorage</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithSideEffects {};

incrementVisitCounterLocalStorage();</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-without-side-effects.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithoutSideEffects {};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">// Без уточнения</span>
<span class="hljs-keyword">import</span> { IDataFromModuleWithSideEffects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-with-side-effects'</span>;
<span class="hljs-keyword">import</span> { IDataFromModuleWithoutSideEffects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-without-side-effects'</span>;

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects: IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects: IDataFromModuleWithoutSideEffects = {};</code></pre>
<p>Несмотря на то что импортировались исключительно конструкции-типы, модули были импортированны полностью:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'./module-with-side-effects'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./module-without-side-effects'</span>;

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects = {};</code></pre>
<p>В случае уточнения поведение при компиляции останется прежнем. То есть в импорты в скомпилированный файл включены не будут.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">// С уточнением</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { IDataFromModuleWithSideEffects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-with-side-effects'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { IDataFromModuleWithoutSideEffects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-without-side-effects'</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects: IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects: IDataFromModuleWithoutSideEffects = {};</code></pre>
<p>Импорты модулей будут отсутствовать.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects = {};</code></pre>
<p>Если же флагу <code class="inline-code">--importsNotUsedAsValues</code> задано значение <code class="inline-code">error</code>, то при импортировании типов без явного уточнения будет считаться ошибочным поведением.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 *
 * [0][1] Error > This import is never used as a value and must use 'import type' because the 'importsNotUsedAsValues' is set to 'error'.ts(1371)
 */</span>

<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-with-side-effects'</span>;
<span class="hljs-keyword">import</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">'./module-without-side-effects'</span>;

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects: IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects: IDataFromModuleWithoutSideEffects = {};</code></pre>
<p>Скомпилированный код выше после устранения ошибок, то есть после уточнения, включать в себя импорты не будет.</p>
<p>В заключение стоит заметить что теоретически, уточнение такой конструкции как класс, способно ускорить компиляцию, поскольку это избавляет компилятор от ненужных проверок на вовлечении его в логику работы модуля. Кроме того, уточнение формы импорта\экспорта, это ещё один способ сделать код более информативным.</p>
</section>