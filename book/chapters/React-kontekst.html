<h1>Контекст (Context)</h1>
<p>Пришло время рассмотреть влияние типизации на такой механизм как контекст, который хотя и не привносит ничего что на текущий момент было бы не понятно, все же имеет один не очевидный момент.</p><section id="Opredelenie-konteksta" name="Определение контекста" class="subchapter">

            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opredelenie-konteksta" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Определение контекста
            </h2>
        
<p>Определение контекста осуществляется при помощи универсальной функции определяющей один обязательный параметр выступающий в качестве инициализационного значения и возвращающей объект контекста <code class="inline-code">createContext&#x3C;T>(initialValue: T): Context&#x3C;T></code>. В случаях когда инициализационное значение в полной мере соответствует предполагаемому типу, чьё описание не включает необязательных членов, то аргументы типа можно или даже нужно не указывать. В остальных случаях это становится необходимостью.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;


<span class="hljs-comment">/**Аргумента типа не требуется */</span>

<span class="hljs-keyword">interface</span> AContext {
    a: <span class="hljs-built_in">number</span>;
    b: <span class="hljs-built_in">string</span>;
}

         <span class="hljs-comment">/**[0]             [1][2] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> A = createContext({
    a: <span class="hljs-number">0</span>,
    b: <span class="hljs-string">``</span>
});

<span class="hljs-comment">/**
 * Поскольку при определении контекста [0]
 * в качестве обязательного аргумента было
 * установлено значение [2] полностью соответствующее
 * предполагаемому типу AContext, аргумент типа
 * универсальной функции можно опустить [1].
 * 
 */</span>


 <span class="hljs-comment">/**Требуется аргумент типа */</span>

<span class="hljs-keyword">interface</span> BContext <span class="hljs-keyword">extends</span> AContext {
    c?: <span class="hljs-built_in">boolean</span>;
}

                               <span class="hljs-comment">/**[0]     [1] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> B = createContext&#x3C;BContext>({
    a: <span class="hljs-number">0</span>,
    b: <span class="hljs-string">``</span>
});


<span class="hljs-comment">/**
 * Так как инициализационное значение [1]
 * лишь частично соответствует предполагаемому
 * типу BContext тип объякта контекста необходимо
 * конкретизировать при помощью аргументов типа [0]
 */</span>


<span class="hljs-comment">/**Требуется аргумент типа */</span>

                                    <span class="hljs-comment">/**[0]       [1] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> C = createContext&#x3C;BContext | <span class="hljs-literal">null</span>>(<span class="hljs-literal">null</span>);

<span class="hljs-comment">/**
 * По причине отсутствия на момент определения 
 * инициализационного значения оно замененно на null [1],
 * что требует упомянуть при конкретизации типа значения [0].
 */</span></code></pre>
</section><section id="Ispolzovanie-konteksta" name="Использование контекста" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Ispolzovanie-konteksta" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Использование контекста
            </h2>
        
<p>Поскольку функциональные и классовые компоненты подразумевают различные подходы для взаимодействия с одними и теме же механизмами реализуемыми <em>React</em>, после регистрации контекста в <em>react дереве</em> работа с ним зависит от вида комопнента нуждающегося в поставляемых им данных. </p>
<p>После определения контекста необходимо зарегистрировать в <em>react дереве</em> предоставляемого им <code class="inline-code">Provider</code> установив ему необходимые данные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, {createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">/**0 */</span>
<span class="hljs-keyword">const</span> Context = createContext({
    status: <span class="hljs-string">``</span>,
    message: <span class="hljs-string">``</span>
});

<span class="hljs-comment">/**
 * [0] определение контекста.
 */</span>

   <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =></span> (
        <span class="hljs-comment">/**[2]                                 [3] */</span>
    &#x3C;Context.Provider value={{status: <span class="hljs-string">`init`</span>, message: <span class="hljs-string">`React Context!`</span>}}>

    &#x3C;<span class="hljs-regexp">/Context.Provider>
)

/</span>**
 * [<span class="hljs-number">1</span>] определяем компонент представляющий точку входа
 * в приложение и регистрируем в его корне Provider [<span class="hljs-number">2</span>]
 * которму при инициализации устанавливаем необходимое значение [<span class="hljs-number">3</span>].
 *<span class="hljs-regexp">/</span></code></pre>
<p>На следующем шаге определим классовый компонент и добавим его в ветку корнем которой является определенный на предыдущем шаге <code class="inline-code">Provider</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =></span> (
    &#x3C;Context.Provider value={{status: <span class="hljs-string">`init`</span>, message: <span class="hljs-string">`React Context!`</span>}}>
        &#x3C;ClassComponent /> 
    &#x3C;<span class="hljs-regexp">/Context.Provider>
)

class ClassComponent extends Component {
    render(){
        return (
        );
    }
}</span></code></pre>
<p>Поскольку компонент является классовым, единственный способ добраться до предоставляемых контекстом данных заключается в создании экземпляра <code class="inline-code">Consumer</code>, который в качестве <code class="inline-code">children</code> ожидает функциюю обозначаемую как <code class="inline-code">render callback</code>. Данная функция определяет единственный параметр которойпринадлежащий к типу данных передаваемых с помощью контекста, а возвращаемое ею значение должно принадлежать к любому допустимому типу представляющему эдемент <em>React дерева</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> ClassComponent <span class="hljs-keyword">extends</span> Component {
    render(){
        <span class="hljs-keyword">return</span> (
                  <span class="hljs-comment">/**[0]        [1]               [2] */</span>
            &#x3C;Context.Consumer >{<span class="hljs-function"><span class="hljs-params">data</span> =></span> &#x3C;span>{data.message}&#x3C;<span class="hljs-regexp">/span>}&#x3C;/</span>Context.Consumer>
        );
    }
}

<span class="hljs-comment">/**
 * Поскольку компонент ClassComponent явялется
 * классовым, единственный вариант получить в нем
 * данные предоставляемые контекстом заключается
 * в создании экземпляра Consumer, который в качестве
 * children ожидает функцию обозначаемую как render callback
 * единственный параметр которой принадлежит к типу данных, а
 * возвращаемое значение должно принадлежать к одному из допустимых
 * типов предполагаемых React.
 */</span></code></pre>
<p>Для случаев требующих определения <code class="inline-code">render callback</code> вне <code class="inline-code">Consumer</code>, его параметру потребуется добавить аннотацию типа, который придется объявить в месте определения контекста. Если инициализационные данные в полной мере соответствуют ожидаемому типу, то его получение проще выполнить с помощью механизма <em>запроса типа</em>, чем описывать вручную. В остальных случаях описание потребуется выполнять самостоятельно.</p>
<pre><code class="hljs language-typescript">        <span class="hljs-comment">/**0 */</span>
<span class="hljs-keyword">let</span> initialValue = {
    status: <span class="hljs-string">``</span>,
    message: <span class="hljs-string">``</span>
};
<span class="hljs-keyword">const</span> Context = createContext(initialValue);

      <span class="hljs-comment">/**[1]         [2] */</span>
<span class="hljs-keyword">type</span> ContextType = <span class="hljs-keyword">typeof</span> initialValue;

<span class="hljs-comment">/**
 * [0] определение инициализационного значения,
 * на основе которого при помощи запроса типа [2]
 * будет получен его тип [1].
 */</span></code></pre>
<p>Полученный тип необходимо будет указать в аннотации единственного параметра <code class="inline-code">render callback</code> при его определении.</p>
<pre><code class="hljs language-typeScript"><span class="hljs-keyword">class</span> ClassComponent <span class="hljs-keyword">extends</span> Component {
    <span class="hljs-comment">/**[0]                      [1] */</span>
    renderCallback = <span class="hljs-function">(<span class="hljs-params">data: ContextType</span>) =></span> (
        &#x3C;span>{data.message}&#x3C;<span class="hljs-regexp">/span>
    );


    render(){
        return (
                                    /</span>**[<span class="hljs-number">2</span>] *<span class="hljs-regexp">/
            &#x3C;Context.Consumer >{this.renderCallback}&#x3C;/</span>Context.Consumer>
        );
    }
}

<span class="hljs-comment">/**
 * При внешнем [2] определении render callback как поля класса [0]
 * в аннотации тип его единственного параметра указан тип данных [1]
 * предоставляемых контекстом. 
 * 
 */</span></code></pre>
<p>Если данные предоставляемые контекстом принадлежать к более общему типу, то параметр <code class="inline-code">render callback</code> можно конкретизировать.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> Message {
    message: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> Status {
    status: <span class="hljs-built_in">string</span>;
}

      <span class="hljs-comment">/**[1]             [2] */</span>
<span class="hljs-keyword">type</span> ContextType = Message &#x26; Status;


<span class="hljs-keyword">let</span> initialValue = {
    status: <span class="hljs-string">``</span>,
    message: <span class="hljs-string">``</span>
};
<span class="hljs-keyword">const</span> Context = createContext(initialValue);



<span class="hljs-comment">/**
 * [0] объявление конкретных типов
 * определяющих тип пересечение [2]
 * на который ссылается преждний псевдоним [1].
 * 
 * Поскольку инициализационное значение в полной
 * мере соответствует предполагаемому типу, переменную
 * initialValue и универсальную функцию можно избавить от
 * явной и излишней конкретизации.
 */</span>


 <span class="hljs-keyword">class</span> ClassComponent <span class="hljs-keyword">extends</span> Component {
                           <span class="hljs-comment">/**[3] */</span>
    renderCallback = <span class="hljs-function">(<span class="hljs-params">data: Message</span>) =></span> (
        &#x3C;span>{data.message}&#x3C;<span class="hljs-regexp">/span>
    );


    render(){
        return (
            &#x3C;Context.Consumer >{this.renderCallback}&#x3C;/</span>Context.Consumer>
        );
    }
}

<span class="hljs-comment">/**
 * [3] параметр render callback теперь ограничен типом
 * Message.
 */</span></code></pre>
<p>Для получения данных распространяемых контекстом внутри тела функционального компонента, помимо варианта с <code class="inline-code">Consumer</code>, который ничем не отличается от рассмотренного в этой теме ранее, предусмотрен более предпочтительный способ предполагающий использование предопределенного хука <code class="inline-code">useContext&#x3C;T>(context)</code>.</p>
<p>Универсальная функция <code class="inline-code">useContext</code> ожидает в качестве своего единственного аргумента объект контекста, конкретизировать который с помощью аргумента типа не имеет никакого смысла.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> FunctionComponent = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
    <span class="hljs-keyword">let</span> {message, status} = useContext(Context);


    <span class="hljs-keyword">return</span> (
        &#x3C;span>{message}&#x3C;<span class="hljs-regexp">/span>
    );
}

const App = () => (
    &#x3C;Context.Provider value={{status: `init`, message: `React Context!`}}>
        &#x3C;FunctionComponent /</span>> 
    &#x3C;<span class="hljs-regexp">/Context.Provider>
)</span></code></pre>
<p>При попытке с помощью аргумента типа ограничить более общий тип данных возникнет ошибка, поскольку в действие включаются правила контрвариантности параметров функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> FunctionComponent = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {
                              <span class="hljs-comment">/**[0]      [1] */</span>
    <span class="hljs-keyword">let</span> {message} = useContext&#x3C;Message>(Context); <span class="hljs-comment">// Error</span>


    <span class="hljs-keyword">return</span> (
        &#x3C;span>{message}&#x3C;<span class="hljs-regexp">/span>
    );
}

/</span>**
 * При попке ограничить тип с помощью аргумента типа [<span class="hljs-number">0</span>]
 * из-за контрвариантности параметров функции возникнет ошибка [<span class="hljs-number">1</span>]. 
 *<span class="hljs-regexp">/</span></code></pre>
</section>