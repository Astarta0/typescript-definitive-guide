<section id="React-Functional-Component" name="React - Functional Component" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="React-Functional-Component" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                React - Functional Component
            </h2>
        
<hr>
<p>Поскольку создавать <em>React</em> приложения рекомендуется на основе функциональных компонентов, то именно с них и начнется погружение в типизирование <code class="inline-code">.tsx</code> конструкций.</p>
<p>Всем известно что <em>React</em> компоненты обозначаемые как <em>функциональные</em> представляют из себя самые обычные функции. И как все функции в <em>JavaScript</em> они также мгут быть определены двумя способами — в виде обычной функции (<em>Function Declaration</em>) и в виде функционального выражения (<em>Function Expression</em>) тоящего один неочевидный нюанс, который подробно будет рассмотрен по ходу знакомства с ним.</p>
</section><section id="Opredelenie-komponenta-kak-Function-Declaration" name="Определение компонента как Function Declaration" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opredelenie-komponenta-kak-Function-Declaration" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Определение компонента как Function Declaration
            </h2>
        
<p>Факт что функциональный компонент является обычной функций предполагает необходимость в типизировании её сигнатуры. Точнее её параметров при условии их необходимости, так как указание типа возвращаемого значения не просто можно, а даже рекоментдуется опустить, возложив эту работу на вывод типов. Также необходимо всегда помнить что независимо от того используется пространство имен <code class="inline-code">React</code> непосредственно или нет, модули определяющие <em>React</em> компоненты обязанны его импортировать. В противном случае компилятор напомнит об этом с помощью ошибки.</p>
<pre><code class="hljs language-typescript">      <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">/**[1] */</span> 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Timer</span>(<span class="hljs-params"><span class="hljs-comment">/**[2] */</span></span>) /**[3] */ </span>{
  <span class="hljs-keyword">return</span> &#x3C;div>Is Timer!&#x3C;<span class="hljs-regexp">/div>;
}

export default Timer;

/</span>**
 * [<span class="hljs-number">1</span>] функциональный компонент
 * определенный как <span class="hljs-built_in">Function</span> Declaration.
 * [<span class="hljs-number">2</span>] отсутствующие параметры.
 * [<span class="hljs-number">3</span>] отсутствие явного указания типа
 * возвращаемого типа.
 * [<span class="hljs-number">0</span>] все компоненты обязаны импортировать
 * пространство имен React.
 *<span class="hljs-regexp">/</span></code></pre>
<p>При определении первого параметра функционального компонента <code class="inline-code">props</code> появляется потребность в типе описывающем их. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> Props {
  message?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">/**[1] */</span>
  duration: <span class="hljs-built_in">number</span>; <span class="hljs-comment">/**[2] */</span>
}

                                            <span class="hljs-comment">/**[3] */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Timer</span>(<span class="hljs-params">{duration, message = `Done!`}: Props</span>) </span>{
  <span class="hljs-keyword">return</span> &#x3C;div>&#x3C;<span class="hljs-regexp">/div>;
}

/</span>**
 * [<span class="hljs-number">0</span>] определения типа интерфейса
 * который будет указан в аннотации
 * первого параметра функционального
 * компонента [<span class="hljs-number">3</span>] и чье описание 
 * включает необязательное поле message [<span class="hljs-number">1</span>]
 *  и обязательного duration [<span class="hljs-number">2</span>] 
 *<span class="hljs-regexp">/</span></code></pre>
<p>Поскольку идеология <em>React</em> подразумевает <em>прокидование пропсов</em> из одного компонента в другой, то компоненту выступающему в роли провайдера помимо своих пропсов необходимо описывать пропсы своих детей. В случаях когда в проброске нуждаются только несколько значений принадлежащих к типам из системы типов <em>TypeScript</em>, декларирование их в пропсах провайдера не будет выглядеть удручающе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// file Informer.tsx</span>

<span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> Props {
    message: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/**
 * [0] описание пропсов компонента Informer
 */</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Informer</span>(<span class="hljs-params">{message}: Props</span>)</span>{
  <span class="hljs-keyword">return</span> &#x3C;h1>{message}&#x3C;<span class="hljs-regexp">/h1>
}



/</span><span class="hljs-regexp">/ file InformerDecorator.tsx

import Informer from "./</span>Informer<span class="hljs-string">";


/**[0] */
interface Props {
    decor: number; /**[1] */
    message: string; /**[2] */
}

/**
 * [0] описание пропсов компонента InformerDecorator
 * [1] значение предназначаемое непосредственно текущему компоненту
 * [2] значение предназначаемое компоненту Informer
 */

export default function InformerDecorator({decor, message}: Props){
  return &#x3C;Informer message={message + decor}/>;
}</span></code></pre>
<p>Но в случае когда пропсы представлены множеством значений которые к тому же могут принадлежать к типам определенных разработчиками, то более целесообразно включить в описание типа пропсов компонента-провайдера тип описывающий пропсы компонента которому они предназначаются. Поэтому тип описывающий пропсы необходимо экспортировать. Кроме того чтобы избежать коллизий именнования типов представляющих пропсы их идентификаторы необходимо конкретизировать, то есть давать более уникальные имена. Поэтому принято имени <code class="inline-code">Props</code> добавлять префикс идентичный названию самого компонента.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// file Informer.tsx</span>

<span class="hljs-comment">/**[0] */</span>           <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> InformerProps {
    message: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/**
 * [0] экспорт типа
 * [1] уточнение идентификатора (имени)
 */</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Informer</span>(<span class="hljs-params">{message}: InformerProps</span>)</span>{
  <span class="hljs-keyword">return</span> &#x3C;h1>{message}&#x3C;<span class="hljs-regexp">/h1>
}



/</span><span class="hljs-regexp">/ file InformerDecorator.tsx
                    /</span>**[<span class="hljs-number">0</span>] *<span class="hljs-regexp">/
import Informer, {InformerProps} from "./</span>Informer<span class="hljs-string">";

/**
 * [0] импорти типа пропсов
 */

/**[1] */               /**[2] */                   /**[3] */
export interface InformerDecoratorProps extends InformerProps {
    decor: number;
    /**[4] */
}

/**
 * [1] экспорт типа
 * [2] уточнение идентификатора (имени)
 * [3] расширение типа пропсов другого компонента
 * позволяет не рописывать необходимые ему поля [4]
 */


export default function InformerDecorator({decor, message}: InformerDecoratorProps){
  return &#x3C;Informer message={message + decor}/>;
}</span></code></pre>
<p>В случаях когда компонент-провайдер нуждается только в части пропсов определенных в типе представляющих их, ненужную часть можно исключить с помощью типа <code class="inline-code">Omit&#x3C;T, K></code> или <code class="inline-code">Exclude&#x3C;T, U></code>.</p>
<p>Не будет лишним напомнить, что при помощи модификатора <code class="inline-code">readonly</code> не удастся избежать изменений переменных ссылки на которые были получены с помощью механизма деструктуризации.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> InformerProps {
    <span class="hljs-comment">/**[0] */</span>
    readonly message: <span class="hljs-built_in">string</span>;
};

                                            <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Informer</span>(<span class="hljs-params">{message} : Readonly&#x3C;InformerProps></span>)</span>{
    message = <span class="hljs-string">'new value'</span>; <span class="hljs-comment">/**[2] */</span>

    <span class="hljs-keyword">return</span> &#x3C;h1>{message}&#x3C;<span class="hljs-regexp">/h1>
}

/</span>**
 * [<span class="hljs-number">0</span>] добавление модификатора readonly вручную,
 * а затем ещё тоже самое с помощью тип Readonly&#x3C;T> [<span class="hljs-number">1</span>]
 * и тем не менее переменная message изменяема [<span class="hljs-number">2</span>].
 *<span class="hljs-regexp">/</span></code></pre>
<p>Такое поведение является причиной того что идентификаторы являются определением новой переменной, а переменные не могут иметь модификатор <code class="inline-code">readonly</code>.</p>
<pre><code class="hljs language-typescript">                  <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">let</span> o: Readonly&#x3C;{f: <span class="hljs-built_in">number</span>}> = {f: <span class="hljs-number">0</span>};
o.f = <span class="hljs-number">1</span>; <span class="hljs-comment">// Error -> [1]</span>

<span class="hljs-keyword">let</span> {f} = o;
f = <span class="hljs-number">1</span>; <span class="hljs-comment">// Ok -> [2]</span>

<span class="hljs-comment">/**
 * Определение переменной o с типом инлайн интерфейса [0]
 * поля которого модифицированны с помощью типа Readonly&#x3C;T>.
 * При попытке изменить член o.f с модификатором readonly
 * возникает ошибка [1] ->
 * Cannot assign to 'f' because it is a read-only property.
 * Чего не происходит при изменении переменной определенной
 * в процессе деструктуризации.
 * 
 * Механизм деструктуризации предполагает создание новой
 * переменной со значением одноименного члена объекта указанного
 * в качестве правого операнда выражения.
 * Выражение let {f} = o; эквивалентно выражению let f = o.f;
 * В этом случае создается новая переменная тип которой устанавливается
 * выводом типов. А вот модификатор readonly не применим к переменным.
 */</span></code></pre>
<p>При необходимости декларирования <code class="inline-code">children</code> можно выбрать несколько путей. Первый из них подразумевает использование обобщенного типа <code class="inline-code">PropsWithChildren&#x3C;P></code> ожидающего в качестве аргумента типа тип представляющий пропсы. Данный тип определяет <code class="inline-code">children</code> как необязательное поле с типом <code class="inline-code">ReactNode</code>. При отсутствии продуманного плана на счёт <code class="inline-code">children</code> или необходимости их принадлежности к любому допустимому типу, данный тип будет как нильзя к месту.</p>
<pre><code class="hljs language-typescript">                    <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, {PropsWithChildren} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> LabelProps {

}

                                                <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Label</span>(<span class="hljs-params">{children}: PropsWithChildren&#x3C;LabelProps></span>)</span>{
    <span class="hljs-keyword">return</span> (
        &#x3C;span>{children}&#x3C;<span class="hljs-regexp">/span>
    );
}

/</span>**
 * [<span class="hljs-number">0</span>] импорт типа PropsWithChildren&#x3C;T>
 * для указания его в аннотации типа параметров [<span class="hljs-number">1</span>].
 *<span class="hljs-regexp">/


&#x3C;Label>{"label"}&#x3C;/</span>Label>; <span class="hljs-comment">// string as children -> Ok [2]</span>
&#x3C;Label>{<span class="hljs-number">1000</span>}&#x3C;<span class="hljs-regexp">/Label>; /</span><span class="hljs-regexp">/ number as children -> Ok [3]
&#x3C;Label>&#x3C;/</span>Label>; <span class="hljs-comment">// undefined as chiildren -> Ok [4]</span>

 <span class="hljs-comment">/**
  * При создании экземпляров компонента Label
  * допустимо указывать в качестве children
  * как строку [2], так и числа [3] и кроме
  * того не указывать значения вовсе [4]
  */</span></code></pre>
<p>Если логика компонента предолагает обязательную установку <code class="inline-code">children</code> или уточнение типа к которому они принадлежат, то появляется необходимость их непосредственной декларации в типе представляющем пропсы этого компонента.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * [0] children определены как 
 * обязятельное пренадлежащие к
 * типу string поле.
 */</span>
<span class="hljs-keyword">interface</span> LabelProps {
    children: <span class="hljs-built_in">string</span>; <span class="hljs-comment">/**[0] */</span>
}


<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Label</span>(<span class="hljs-params">{children}: LabelProps</span>)</span>{
    <span class="hljs-keyword">return</span> (
        &#x3C;span>{children}&#x3C;<span class="hljs-regexp">/span>
    );
}


&#x3C;Label>{`label`}&#x3C;/</span>Label>; <span class="hljs-comment">// Ok</span>
&#x3C;Label>{<span class="hljs-number">1000</span>}&#x3C;<span class="hljs-regexp">/Label>; /</span><span class="hljs-regexp">/ Error -> number не совместим со string
&#x3C;Label>&#x3C;/</span>Label>; <span class="hljs-comment">// Error -> children обязательны</span></code></pre>
<p>Может показатся что конкретизация типа <code class="inline-code">children</code> будет полезна при создании собственных <code class="inline-code">ui</code> компонентов. К примеру при создании компонента <code class="inline-code">List</code> отрисовывающего элемент <code class="inline-code">ul</code>, было бы здорого определить <code class="inline-code">children</code> как массив компонентов <code class="inline-code">ListItem</code> отрисовывающих элемент <code class="inline-code">li</code>.</p>
<p>Для этого понадобится импортировать обощенный тип <code class="inline-code">ReactElement&#x3C;P, T></code> первый параметр типа которого ожидает тип пропсов, а второй строку или конструктор компонента для указания его в качестве типа поля <code class="inline-code">type</code> необходимого для идентификации. По факту тип <code class="inline-code">ReactElement&#x3C;P, T></code> представляет экземпляр любого компонента в системе типов <em>React</em>. После определения компонентов <code class="inline-code">List</code> и <code class="inline-code">ListItem</code>, нам понадобится для первого переопределить поле <code class="inline-code">children</code> указав ему тип <code class="inline-code">ReactElement&#x3C;ListItemProps></code>, что буквально означает экземпляр компонента пропсы которого принадлеат к типу указанному в качестве первого аргумента типа.</p>
<pre><code class="hljs language-typescript">                  <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, { ReactElement, ReactNode } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">/**
 * [0] импорт типа представляющего
 * экземпляр любого компонента.
 */</span>

<span class="hljs-keyword">interface</span> ListItemProps {
    children: ReactNode; <span class="hljs-comment">/**[1] */</span>
}

<span class="hljs-comment">/**
 * [1] для примера определим тип children
 * как ReactNode представляющего любой
 * допустимый тип.
 */</span>

 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListItem</span>(<span class="hljs-params">{children}: ListItemProps</span>)</span>{
 <span class="hljs-keyword">return</span> &#x3C;li>{children}&#x3C;<span class="hljs-regexp">/li>;
 }



interface ListProps {
    children: ReactElement&#x3C;ListItemProps>; /</span>**[<span class="hljs-number">2</span>] *<span class="hljs-regexp">/
}

/</span>**
 * [<span class="hljs-number">2</span>] при определении children
 * указываем тип ReactElement&#x3C;ListItemProps>
 * что стоит понимать как - экземпляр компонента
 * пропсы которого совм<span class="hljs-number">6</span>естимы с типом ListItemProps.
 *<span class="hljs-regexp">/

function List({children}: ListProps) {
    return &#x3C;ul>{children}&#x3C;/u</span>l>;
}

<span class="hljs-comment">/**[3] */</span>
&#x3C;List>
    &#x3C;ListItem>first&#x3C;<span class="hljs-regexp">/ListItem>
&#x3C;/</span>List>

<span class="hljs-comment">/**
 * [3] создаем экземпляр List
 * и указываем ему в качестве children
 * один экземпляр ListItem.
 */</span></code></pre>
<p>Если кажется просто, то не стоит сомневатся, оно так и есть. Совершенно ничего сложного. Единственное стоит уточнить два важных момента. </p>
<p>Первый момент заключается в том, что конкретизация типа <code class="inline-code">children</code> для <em>React</em> элементов не работает. Проще говоря, если определить новый компонент <code class="inline-code">Label</code> и указать ему в качестве пропсов тип определяющий единственное поле <code class="inline-code">type</code>, то его экземпляр без возникновения ошибки можно будет указать в качестве <code class="inline-code">children</code> компоненту <code class="inline-code">List</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">interface</span> ListItemProps {
    children: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/**
 * [0] оставляем тип пропсов,
 * но для упрощения удаляем компонент
 * нуждающийся в нем.
 */</span>

<span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">interface</span> LabelProps {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'danger'</span> | <span class="hljs-string">`error`</span>;
    children: ReactNode;
}

<span class="hljs-comment">/**[1] */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Label</span>(<span class="hljs-params">{<span class="hljs-keyword">type</span>, children}: LabelProps</span>)</span>{
    <span class="hljs-keyword">return</span> &#x3C;span className={<span class="hljs-keyword">type</span>}>{children}&#x3C;<span class="hljs-regexp">/span>
}

/</span>**
 * [<span class="hljs-number">1</span>] определяем компонент Label
 * и описываем его пропсы.
 *<span class="hljs-regexp">/



interface ListProps {
    children: ReactElement&#x3C;ListItemProps>; /</span>**[<span class="hljs-number">2</span>] *<span class="hljs-regexp">/
}

/</span>**
 * Тип children по прежнему указан
 * как ReactElement&#x3C;ListItemProps>.
 *<span class="hljs-regexp">/

/</span><span class="hljs-regexp">/ компонент List удален для упрощения

/</span>**[<span class="hljs-number">3</span>] *<span class="hljs-regexp">/
&#x3C;List>
    &#x3C;Label type={'danger'}>Hello World!&#x3C;/</span>Label>
&#x3C;<span class="hljs-regexp">/List>

/</span>**
 * [<span class="hljs-number">3</span>] несмотря на то что в комопненте List
 * тип children обозначен как ReactElement&#x3C;ListItemProps>
 * вместо ожидаемого экземпляра без возникновения
 * ошибки устанавливается тип ReactElement&#x3C;LabelProps>.
 *<span class="hljs-regexp">/</span></code></pre>
<p>Всё дело в том, что экземпляр компонента представляется типом <code class="inline-code">Element</code> из пространнства имен <em>JSX</em>, который является производным от типа <code class="inline-code">ReactElement&#x3C;P, T></code> и при расширении (<code class="inline-code">extends</code>) устанавливает в качестве аргументов типа тип <code class="inline-code">any</code>. Это в свою очередь означает что любые экземпляры компонентов будут совместимы с любыми типами <code class="inline-code">ReactElement&#x3C;P, T></code>, что делает уточнение типа бессмысленным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> listItem = &#x3C;ListItem>first&#x3C;<span class="hljs-regexp">/ListItem>; /</span><span class="hljs-regexp">/ let listItem: JSX.Element
let label = &#x3C;Label type={'danger'}>label&#x3C;/</span>Label>; <span class="hljs-comment">// let label: JSX.Element</span>

<span class="hljs-comment">/**
 * Поскольку оба экземпляра принадлежат
 * к типу JSX.Element который в свою очередь
 * является производным от типа ReactElement&#x3C;any, any>,
 * то любой экземпляр будет совместим с любым типом ReactElement&#x3C;P, T>.
 */</span>

 <span class="hljs-keyword">let</span> v0: ReactElement&#x3C;ListItemProps> = label;
 <span class="hljs-keyword">let</span> v1: ReactElement&#x3C;LabelProps> = listItem;</code></pre>
<p> Кроме этого <code class="inline-code">ReactElement&#x3C;P, T></code> совместим не только с экземплярами компонентов, но и <em>React</em> элементов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v: ReactElement&#x3C;ListItemProps> = &#x3C;span>&#x3C;<span class="hljs-regexp">/span>; /</span><span class="hljs-regexp">/ Ok</span></code></pre>
<p>Это, как уже было сказанно делает конкретизацию <code class="inline-code">children</code> для экземпляров <em>React</em> компонентов и элементов бессмысленной. Остается надеятся что это исправят.</p>
<p>Второй момент о котором речь о котором шла чуть ранее состоит в том что при текущей поставноке, в случае необходимости указать в качестве <code class="inline-code">children</code> множество экземпляров <code class="inline-code">ListItem</code> возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> ListProps {
    children: ReactElement&#x3C;ListItemProps>; <span class="hljs-comment">/**[0] */</span>
}

<span class="hljs-comment">/**[1] */</span>
&#x3C;List>
    &#x3C;ListItem>first&#x3C;<span class="hljs-regexp">/ListItem>
    &#x3C;ListItem>second&#x3C;/</span>ListItem>
&#x3C;<span class="hljs-regexp">/List>

/</span>**
 * [<span class="hljs-number">0</span>] тип указан как единственный
 * экземпляр компонента. поэтому при
 * установке множества экземпляров [<span class="hljs-number">1</span>]
 * возникает ошибка.
 *<span class="hljs-regexp">/</span></code></pre>
<p>Для разрешения подобного случая необходимо указать тип <code class="inline-code">children</code> как объединение (<code class="inline-code">Union</code>) определенное типами  представляющих как единственный экземпляр <code class="inline-code">ReactElement&#x3C;ListItemProps></code> так и множество, а если быть конкретнее то массив экземпляров <code class="inline-code">ReactElement&#x3C;ListItemProps>[]</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> ListProps {
    children: ReactElement&#x3C;ListItemProps> | ReactElement&#x3C;ListItemProps>[]; <span class="hljs-comment">/**[0] */</span>
}

<span class="hljs-comment">/**[1] */</span>
&#x3C;List>
    &#x3C;ListItem>first&#x3C;<span class="hljs-regexp">/ListItem>
    &#x3C;ListItem>second&#x3C;/</span>ListItem>
&#x3C;<span class="hljs-regexp">/List>

/</span>**
 * [<span class="hljs-number">0</span>] указание в качестве типа children
 * объединение предполагающее как единственный
 * экземпляр так и множество, ошибка [<span class="hljs-number">1</span>] не возникает.
 *<span class="hljs-regexp">/</span></code></pre>
<p>Ввиду того что темы которые так или иначе соприкосаются с первым параметром функционального компонента обозначаемым как пропсы себя исчерпали, настало время рассмотреть его второй, не часто используемый параметр предназначеный для передачи ссылки на текущий компонент которая чаще обозначается как <em>реф</em>. Но поскольку тему связанную с рефами нельзя назвать незначительной, знакомство с ней будет включать множество других сопряженных тем часть из которых будет рассмотрена лишь поверхностно, поскольку детально этому будет уделено время в дальнейшем.</p>
<p>Начать тему посвященную рефам стоит с напоминания того, что они делятся на два вида. Первый вид предназначен для получения ссылок на <em>React элементы</em>, а второй на <em>React компоненты</em>.
Кроме того для функциональных компонентов существуют уникальные для них механизмы осуществимые с помощью хуков <code class="inline-code">useRef()</code> и <code class="inline-code">useImperativeHandle()</code>, а также вспомошательной функции <code class="inline-code">forwardRef()</code>.</p>
<p>Представьте сценарий при котором форма должна перейти в начальное состояние путем вызова нативного метода <code class="inline-code">reset()</code> что потребует получения на нее ссылки с помощью объекта рефы создаваемого хуком <code class="inline-code">useRef()</code>.</p>
<p>Для начала необходимо с помощью универсальной функции <code class="inline-code">useRef()</code> создать объект рефы и присвоить ссылку на него переменной чтобы в дальнейшем передать элементу формы. Сразу стоит обратить внимание что декларации <em>React</em> элементов содержат устаревшие типы в аннотации поля <code class="inline-code">ref</code> что неприменно приведет к возникновению ошибке при установлении объекта рефы. Чтобы этого избежать необходимо явным образом при определении объекта рефы преобразовать его к обобщеному типу <code class="inline-code">RefObject&#x3C;T></code> которому в качестве аргумента типа установить тип нативного элемента, в данном случае <code class="inline-code">HTMLFormElement</code>. Также стоит сделать акцент на том, что необходимо именно преобразование. Указания аннотации типа переменной или передачи типа в качестве аргумента типа хуку не поможет. Более детально поведение хука <code class="inline-code">useState()</code> рассматривается в главе посвященной предопределенным хукам.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { useRef, RefObject } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params"></span>)</span>{
                   <span class="hljs-comment">/**[0]         [1]          [2] */</span>
    <span class="hljs-keyword">let</span> formRef = useRef() <span class="hljs-keyword">as</span> RefObject&#x3C;HTMLFormElement>;
    
                 <span class="hljs-comment">/**[3] */</span>
    <span class="hljs-keyword">return</span> &#x3C;form ref={formRef}>&#x3C;<span class="hljs-regexp">/form>
}

/</span>**
 * Создаваемый хуком объект рефы необходимо преобразовать в обобщенный тип
 * RefObject&#x3C;T> [<span class="hljs-number">1</span>] в качестве аргумента которому требуется указать нативный тип
 * формы [<span class="hljs-number">2</span>]. Если не произвести преобразования то в момент установки объекта рефы форме [<span class="hljs-number">3</span>]
 * возникнет ошибка, поскольку декларации описывавющие React элементы содержут устаревший
 * тип в аннотации поля ref.
 * 
 * БОЛЕЕ ПОДРОБНО В ТЕМЕ ПОСВЯЩЕННОЙ ХУКУ useRef()
 * 
 *<span class="hljs-regexp">/</span></code></pre>
<p>Если появится необходимость возвращения формы в первоначальное состояние извне компонента то можно прибегнуть к механизму получения ссылки на сам компонент или если быть точнее на определяемый им объект выступающий в роли публичного <em>api</em>. Но для того чтобы стало возможным получения ссылки на функциональный компонент его необходимо преобразовать с помощью универсальной функцией <code class="inline-code">forwardRef&#x3C;R, P>()</code> с которой и начнется дальнейшее повествование.</p>
<p>По факту логика работы универсальной функции <code class="inline-code">forwardRef&#x3C;R, P>(render)</code> заключатеся в проверке единственного параметра на принадлежность к функциональному типу у которой помимо первого параметра представляющего <code class="inline-code">props</code> определен ещё и второй представляющий <code class="inline-code">ref</code>. Данная функция обозначается как <code class="inline-code">render</code> и теоретически её можно считать функциональным компонентом с определением второго параметра предназначенного для установления рефы. В системе типов <em>React</em> функция <code class="inline-code">render</code> принадлежит к обобщенному функциональному типу <code class="inline-code">ForwardRefRenderFunction&#x3C;T, P></code> определяющего два параметра типа, первый из которых представляет тип рефы, а второй пропсов. Первый параметр функции <code class="inline-code">render</code> представляющий пропсы не таит в себе ничего необычного. В отличии от него второй параметр представляющий рефу требует детального рассмотрения поскольку именно с ним связан один неочевидный момент.</p>
<p>Дело в том что рефы могут быть представлены как экземпляром объекта принадлежащего к типу <code class="inline-code">RefObject&#x3C;T></code> или полностью совместимым с ним <code class="inline-code">MutableRefObject&#x3C;T></code>, так и функцией <code class="inline-code">&#x3C;T>(instance: T) => void</code>. Учитывая этот факт функция <code class="inline-code">render</code> в аннотации типа второго параметра <code class="inline-code">ref</code> просто вынуждена указать это множество представленное типом объединение (<code class="inline-code">Union</code>). Но сложность состоит в том, что определение типа объединение происходит непосредственно в аннотации типа параметра <code class="inline-code">ref</code>. Простыми словами система типов <em>React</em> не предусматрела более удобного и короткого псевдонима типа представляющего рефу определяемую функциональным компонентом.  </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> ForwardRefRenderFunction&#x3C;T, P = {}> {
                                       <span class="hljs-comment">/**                              [0]                              */</span>
    (props: PropsWithChildren&#x3C;P>, ref: <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">instance: T | <span class="hljs-literal">null</span></span>) => <span class="hljs-built_in">void</span></span>) | <span class="hljs-params">MutableRefObject</span>&#x3C;<span class="hljs-params">T</span> | <span class="hljs-params">null</span>> | <span class="hljs-params">null</span>): <span class="hljs-params">ReactElement</span> | <span class="hljs-params">null</span>;
}

/**
 * [0] тип объединение определенный
 * непосредственно в аннотации типа.
 * Простыми словами он не имеет более
 * удобного короткого псевдонима.
 */</span></code></pre>
<p>Это означает что функциональный компонент определенный как <em>Function Declaration</em> и указавший принадлежность второго параметра к типу, скажем <code class="inline-code">MutableRefObject&#x3C;T></code> не сможет пройти проверку на совместимость типов в качестве аргумента универсальной функии <code class="inline-code">forwardRef()</code> даже если установить её аругменты типа. И причина тому контрвариантность параметров функции при проверки на совместимость.</p>
<pre><code class="hljs language-typescript">                    <span class="hljs-comment">/**[0]           [1] */</span>
<span class="hljs-keyword">import</span> React, { MutableRefObject, forwardRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormProps {}

<span class="hljs-comment">/**[2] */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormApi {
    reset: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">/**
 * [2] объявление типа описывающего доступное
 * api компонента.
 */</span>
                               <span class="hljs-comment">/**[3]       [4]         [5] */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params">props: FormProps, ref: MutableRefObject&#x3C;FormApi></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

        <span class="hljs-comment">/**[6]          [7]      [8]       [9]     [10] */</span>
<span class="hljs-keyword">const</span> FormWithRef = forwardRef&#x3C;FormApi, FormProps>(Form <span class="hljs-comment">/**Error */</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormWithRef; <span class="hljs-comment">/**[11] */</span>

<span class="hljs-comment">/**
 * [0] ммпорт обобщенного типа MutableRefObject&#x3C;T>
 * который будет указан в аннотации типа [4] второго
 * параметра [3] функионального комопнента предаврительно
 * получив в качестве аргумента типа тип нативного dom
 * элемента HTMLDivElement [5].
 * 
 * Несмотря на все принятые меры по типизации сигнатуры функционального
 * компонента Form избежать возникновения ошибки [10] при проверке на совместимость
 * в момент передачи в качестве аргумента универсальной функции forwardRef [7] не получится
 * даже при конкретизации с помощью аргументов функционального типа [8][9].
 * 
 * [11] для экспорта функционального компонента определяющего второй параметр необходимо
 * сохранить результат выполнения функции forwardRef [6].
 */</span></code></pre>
<p>Разрешить данную ситуацию можно несколькими способами. Первый заключается в явном преобразовании типа функционального компонента к типу <code class="inline-code">ForwardRefRenderFunction&#x3C;T, P></code> которому в качестве аргументов типа требуется указать необходимые типы. При этом отпадает нужда в указании аругументов типа непосредственно самой универсальной функции <code class="inline-code">forwardRef&#x3C;T, P>()</code>;</p>
<pre><code class="hljs language-typescript">                                                     <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, { MutableRefObject, forwardRef, ForwardRefRenderFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormProps {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormApi {
    reset: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params">props: FormProps, ref: MutableRefObject&#x3C;FormApi></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

                        <span class="hljs-comment">/**[6]                          [7]       [8]        [9] */</span>
<span class="hljs-keyword">const</span> FormWithRef = forwardRef(Form <span class="hljs-keyword">as</span> ForwardRefRenderFunction&#x3C;FormApi, FormProps>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormWithRef;

<span class="hljs-comment">/**
 * [0] импорт обобщенного функционального типа ForwardRefRenderFunction&#x3C;T, P>
 * к которому тип Form [7] будет преобразован с помощью оператора as, для
 * чего потребуентся указать необходимые аргументы типа [8] [9]. При этом отпадает
 * потребность в установке аргументов непосредственно универсальной функции [6]
 */</span></code></pre>
<p>Следующий способ заключается в получении типа представляющего рефу непосредственно из самого функционального типа <code class="inline-code">ForwardRefRenderFunction&#x3C;T, P></code>. Для необходимо указать в аннотации второго параметра функционального компонента обобщенный тип взятого у второго параметра функционального типа <code class="inline-code">ForwardRefRenderFunction&#x3C;T, P></code> при помощи типа <code class="inline-code">Parameters&#x3C;T></code> предназначенного для получения массива с типами соответствующих параметрам функции. Поскольку интересующий нас тип принадлежит второму параметру, то он будет доступен как элемент под индексом один результатирующего массива. Кроме того в указании аргументов типа универсальной функции <code class="inline-code">forwardRef&#x3C;T, P>()</code> нет необходимости поскольку выводу типов достаточно описания сигнатуры функционального компонента.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { forwardRef, ForwardRefRenderFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormProps {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormApi {
    reset: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
}

  <span class="hljs-comment">/**[0][1]       [2]             [3]            [4] [5] */</span>
<span class="hljs-keyword">type</span> Ref&#x3C;T> = Parameters&#x3C;ForwardRefRenderFunction&#x3C;T>>[<span class="hljs-number">1</span>];

                                  <span class="hljs-comment">/**[6]   [7] */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params">props: FormProps, ref: Ref&#x3C;FormApi></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

                        <span class="hljs-comment">/**[8] */</span>
<span class="hljs-keyword">const</span> FormWithRef = forwardRef(Form);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormWithRef;

<span class="hljs-comment">/**
 * При помощи типа Parameters&#x3C;T> [2] получаем массив элементы которого
 * принадлежат к типам параметров функции представляемой типом
 * ForwardRefRenderFunction&#x3C;T, P> [3] которому в качестве первого аргумента
 * типа [4] устанавливаем параметр обобщенного псевдонима [1]. Таким образом
 * Ref&#x3C;T> ссылается на первый элемент массива [5] содержащего тип указанный в аннотации
 * второго параметра (ref). Определенный псевдоним указываем в аннотации
 * второго параметра функционального компонента [6] установив в качестве аргумента
 * типа тип нативного dom элемента [7]. При таком сценарии нет необходимости 
 * конкретизировать типы при помощи аргументов типа универсальной функции
 * forwardRef&#x3C;T, P>() [8]. 
 */</span></code></pre>
<p>Последнее на что стоит обратить внимание это обобщенный тип <code class="inline-code">ForwardRefExoticComponent&#x3C;P></code> к которому принадлежит значение возвращаемое из универсальной функции <code class="inline-code">forwardRef&#x3C;T, P>()</code> и указывать который в явной форме нет никакой необходимости.</p>
<pre><code class="hljs language-typescript">                                                              <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, { forwardRef, ForwardRefRenderFunction, ForwardRefExoticComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">// ...</span>

                            <span class="hljs-comment">/**[1]                [2] */</span>
<span class="hljs-keyword">const</span> FormWithRef: ForwardRefExoticComponent&#x3C;FormProps> = forwardRef(Form);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FormWithRef;

<span class="hljs-comment">/**
 * [0] импорт обобщенного типа ForwardRefExoticComponent&#x3C;P>
 * который в качестве аргумента типа ожидает тип представляющий пропсы того
 * компонента [2] в аннотации типа которого указан [1]. СТоит заметить что
 * указан он исключительно в образовательных целях.
 */</span></code></pre>
<p>После того как функциональный компонент получит рефу ему необходимо присвоить ей значение выступающее в качестве открытого <em>api</em>. Для этого необъодимо прибегнуть к помощи хука <code class="inline-code">useImperativeHandle&#x3C;T, R>(ref: Ref&#x3C;T>, apiFactory() => R): void</code> подробное рассмотрение которого можно найти в теме посвященной предопределенным хукам. </p>
<p>Для того чтобы с помощью хука <code class="inline-code">useImperativeHandle()</code> ассоциировать рефу с открытым <em>api</em> комопнента необходимо в качестве первого аргумента передать рефу определенную вторым параметром функционального компонента. Полю определенного в рефе ожидаемой в качестве первого параметра хука будет присвоено значение возвращаемое из функции ожидаемой в качестве второго параметра. Процесс переинициализации будет выполнятся всекий раз при изменении элементов массива ожжидаемого в качестве третьего параметра данного хука. Также необходимо уточнить что рефа создаваемая с помощью хука <code class="inline-code">useRef()</code> и предназначеная для ассоцииации  с функциональным компонентом также нуждается в явном преобразовании к обобщенному типу <code class="inline-code">MatableRefObject&#x3C;T></code> которому в качестве единственного аргумента типа будет установлен тип представляющий открытое <em>api</em> комопнента. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { forwardRef, ForwardRefRenderFunction, RefObject, useRef, useImperativeHandle, MutableRefObject } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">interface</span> FormProps {}
<span class="hljs-keyword">interface</span> FormApi {
    reset: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">type</span> Ref&#x3C;T> = Parameters&#x3C;ForwardRefRenderFunction&#x3C;T>>[<span class="hljs-number">1</span>];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params">props: FormProps, ref: Ref&#x3C;FormApi></span>) </span>{
                    <span class="hljs-comment">/**[0] */</span>
    <span class="hljs-keyword">let</span> formRef = useRef() <span class="hljs-keyword">as</span> RefObject&#x3C;HTMLFormElement>;

        <span class="hljs-comment">/**[1]          [2]     [3] */</span>
    useImperativeHandle(ref, <span class="hljs-function"><span class="hljs-params">()</span> =></span> ({
        reset: <span class="hljs-function"><span class="hljs-params">()</span> =></span> formRef.current?.reset()
    }), [] <span class="hljs-comment">/**[4] */</span>);


    <span class="hljs-keyword">return</span> &#x3C;form ref={formRef}>&#x3C;<span class="hljs-regexp">/form>;
}

/</span>**
 * [<span class="hljs-number">0</span>] не забываем о необходимости явного преобразования.
 * Хук useImperativeHandle жидает в качестве первого параметра
 * ссылку [<span class="hljs-number">1</span>], в качестве второго фабричную функцию [<span class="hljs-number">3</span>] которая
 * будет переопредлелять объект api каждый раз при изменении 
 * элементов массива ожидаемого в качестве третьего параметра [<span class="hljs-number">4</span>].
 *  
 *<span class="hljs-regexp">/

const FormWithRef = forwardRef(Form);


const App = () => {
                       /</span>**[<span class="hljs-number">5</span>]         [<span class="hljs-number">6</span>]        [<span class="hljs-number">7</span>] *<span class="hljs-regexp">/
    let formRef = useRef() as MutableRefObject&#x3C;FormApi>;
    
    /</span>**[<span class="hljs-number">8</span>] *<span class="hljs-regexp">/
    formRef.current?.reset();

                /</span>**[<span class="hljs-number">9</span>] *<span class="hljs-regexp">/
    return &#x3C;FormWithRef ref={formRef}/</span>>;
}

<span class="hljs-comment">/**
 * Необходимо помнить что ссылка предназначенная
 * для ассоцииации с функциональным компонентом
 * также требует явного преобразование [5] к обобщенному
 * типу MutableRefObject&#x3C;T> [6] которому в качестве аргумента
 * типа необходимо установить тип представляющий открытое api
 * компонента [7]. И после создания экземпляра компонента определенного
 * с помощью функции forwardRef [9] можно использовать его api через объект
 * рефы [8].
 */</span></code></pre>
<p>В связи с тем что функциональный компонент может определять только два параметра пора перейти к рассмотрению следующего звена его сигнатуры. Или если быть точнее аннотации типа возвращаемого им значения. Возвратимся к первоначальному модифицированному с учетом пропсов примеру функционального компонента у которого тип возвращаемого значения не указан явно. И сразу сделать жирный акцент на том, что в большинстве случаев такой подход является более предпочтительным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TimerProps {}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Timer</span>(<span class="hljs-params">props: TimerProps</span>) /**[0] */ </span>{
    <span class="hljs-keyword">return</span> &#x3C;div>Is Timer!&#x3C;<span class="hljs-regexp">/div>;
}


/</span>**
 * [<span class="hljs-number">0</span>] отсутствие явного указания типа
 * возвращаемого типа, что для большинства
 * случаев является ппредпочтительным.
 *<span class="hljs-regexp">/</span></code></pre>
<p>И дело не в том чтобы как можно больше делегировать работы выводу типов экономя тем самым драгоценное время, а в том что система типов <em>React</em> устанавливаемая из репозиториев <code class="inline-code">@types</code> не имеет достаточно высокого уровня типобезопастности. Поскольку это очень щекотливая тема её освещение стоит начать с самого начала, а именно с перечисления типов к которым может принадлежать возвращаемое значение.</p>
<p>И так, любое допустимое возвращаемое компонентом значение в системе типов <em>React</em> может быть представленно типом <code class="inline-code">ReactNode</code> являющимся объединением (<code class="inline-code">Union</code>) определяемого такими типами как <code class="inline-code">ReactChild | ReactFragment | ReactPortal | boolean | null | undefined</code>. Тип <code class="inline-code">ReactChild</code> также представляет из себя объединение таких типов как <code class="inline-code">ReactElement&#x3C;Props, Type> | ReactText</code>. Первый, как уже было рассмотренно ранее, представляет экземпляр любого компонента и элемента <em>React</em>, а второй объединение <code class="inline-code">string | number</code>. <code class="inline-code">ReactFragment</code> также представляет объединение для <code class="inline-code">{} | ReactNodeArray</code>. Не сложно догадатся что <code class="inline-code">ReactNodeArray</code> это абстракция над <code class="inline-code">Array&#x3C;ReactNode></code>. И оставшийся тип <code class="inline-code">ReactPortal</code> является производным от типа <code class="inline-code">ReactElement</code>. Это может казатся очень запутанным и более того разбиратся в этом прямо сейчас нет нужды, поскольку совсем скоро станет ясно в чем кроется подвох причиной которого являются два из перечисленных типа.</p>
<p>Первый тип вносящий смуту, это ранее рассмотренный <code class="inline-code">ReactElement&#x3C;P, T></code> и всё неожиданное поведение которое с ним связанно. Вторым типом вносящий неразбериху стал <code class="inline-code">ReactFragment</code> поскольку определяющий его пустой объектный тип <code class="inline-code">{}</code> совместим с любым экземпляром объектного типа. По факту при использовании в качестве типа возвращаемого значения <code class="inline-code">ReactFragment</code> или <code class="inline-code">ReactNode</code> ошибки не возникнет даже если оно будет экземпляром <code class="inline-code">Promise</code> или чего-то ещё. И хотя отсутствие ошибки на этапе компиляции не означает что её получится избежать во время выполнения, сам сценарий с возвратом ошибочного значения может показатся чересчур надуманным. С какой-то долей вероятности можно с этим согласится, но поскольку идеалогия <em>TypeScript</em> подразумевает выявление проблем в программах до их запуска, об этом стоило хотя бы упомянуть.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { ReactFragment, ReactNode } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>): <span class="hljs-title">ReactFragment</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">0</span>); <span class="hljs-comment">/**[0] */</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>): <span class="hljs-title">ReactNode</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">0</span>); <span class="hljs-comment">/**[0] */</span>
}

<span class="hljs-comment">/**
 * [0] Ok на этапе компиляции и
 * Error во время выполнения.
 */</span>


<span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">class</span> T {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly p: <span class="hljs-built_in">number</span></span>){}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>): <span class="hljs-title">ReactFragment</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(<span class="hljs-number">0</span>); <span class="hljs-comment">/**[2] */</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span>(<span class="hljs-params"></span>): <span class="hljs-title">ReactNode</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(<span class="hljs-number">0</span>); <span class="hljs-comment">/**[2] */</span>
}

<span class="hljs-comment">/**
 * [1] определение некоторого класса.
 * [2] Ok на этапе компиляции и
 * Error во время выполнения.
 */</span></code></pre>
<p>Из всего этого следует что прибегать к аннотации типа возвращаемого значения стоит только в случаях когда оно принадлежит к <code class="inline-code">number</code>, <code class="inline-code">string</code>, <code class="inline-code">boolean</code>, <code class="inline-code">null</code> или массиву элементы которого принадлежат к оному из четырех перечисленных типов. Да и то только тогда, когда в этом есть острая необходимость. В остальных случаях целесообразней возложить эту работу на вывод типов, для которого это обычное дело.</p>
<p>Последнее что осталось без внимание, это событийный механизм или если быть точнее определение слушателей событий. Для этого в системе типов <em>React</em> определен специальный обобщенный тип <code class="inline-code">ReactEventHandler&#x3C;T></code> ожидающий в качестве аргумента типа тип представляющий нативный <em>dom элемент</em> которому будет установлен текущий слушатель событий. </p>
<p>Представим сценарий в котором по нажатию на кнопку с типом <code class="inline-code">submit</code> необходимо вернуть значения элементов формы в первоначальные. Для этого потребуется подписать элемент формы на событие <code class="inline-code">submit</code> и по его возникновению вызвать у нативного элемента формы, ссылка на которую доступна через свойство событийного объекта <code class="inline-code">target</code>, метод  <code class="inline-code">reset</code>.</p>
<p>Первым делом реализация подобного сценария потребует импорта обобщенного типа <code class="inline-code">ReactEventHandler&#x3C;T></code>, который в качестве аргумента типа получит тип нативного <em>dom элемента</em> <code class="inline-code">HTMLFormElement</code>, после чего будет указан в аннотации слушателя событий <code class="inline-code">form_submitHandler</code>. Выбор типа нативного <em>dom элемента</em>, в данном случае <code class="inline-code">HTMLFormElement</code>, обучлавливается типом элемента которому устанавливается слушатель событий, в данном случае <code class="inline-code">&#x3C;form></code>. </p>
<p>Стоит также обратить внимание что единственный параметр слушателя событий в аннотации типа не нуждается, поскольку вывод типов операется на обобщенный тип <code class="inline-code">ReactEvenHandler&#x3C;T></code>.</p>
<p>По возникновению события первым делом необходимо предотвратить поведение по умолчанию чтобы избежать перезагрузки вкладки браузера. Поскольку ссылка на нативную форму доступна через определенное в объекте события свойство <code class="inline-code">target</code>, которое принадлежит к типу <code class="inline-code">EventTarget</code>, то перед присвоением её переменной <code class="inline-code">form</code> появляется необходимость в приведении к типу <code class="inline-code">HTMLFormElement</code> с помощью оператора <code class="inline-code">as</code>. После это можно вызывать нативный метод <code class="inline-code">reset</code>.</p>
<pre><code class="hljs language-typescript">                    <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, {ReactEventHandler} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-comment">/**[1]                 [2]              [3]           [4] */</span>
    <span class="hljs-keyword">const</span> form_submitHandler: ReactEventHandler&#x3C;HTMLFormElement> = <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
        event.preventDefault(); <span class="hljs-comment">/**[5] */</span>

        <span class="hljs-comment">/**  [6]        [7]              [8] */</span>
        <span class="hljs-keyword">let</span> form = event.target <span class="hljs-keyword">as</span> HTMLFormElement;
        form.reset(); <span class="hljs-comment">/**[9] */</span>
    };


    <span class="hljs-keyword">return</span> (
                            <span class="hljs-comment">/**[10] */</span>
        &#x3C;form onSubmit={form_submitHandler}>
            &#x3C;button <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span>>submit&#x3C;<span class="hljs-regexp">/button>
        &#x3C;/</span>form>
    );
}

<span class="hljs-comment">/**
 * [0] импорт обобщенного функционального типа
 * которому установив в качестве аргумента типа
 * тип нативного элемента HTMLFormElement [3]
 * использовали в аннотации типа [2] переменной
 * form_su0bmitHandler [1], которой в качестве
 * значения присвоили функцию слушатель события
 * единственный параметр которой не нуждается в
 * явной аннотации типа [4], поскольку вывод типов
 * операется на тип ReactEventHandler&#x3C;T>.
 * 
 * При возникновении события первым делом происходит
 * предотвращение поведения по умолчанию чтобы избежать
 * перезагрузки вкладки браузера [5]. Затем создается
 * переменная form [6] которой присваивается ссылка на
 * нативный dom элемент доступный через свойство определенное
 * в объекте события target [7] которое при помощи оператора 
 * as приведено к нужному типу нативного dom элемента HTMLFormElement [8].
 * 
 * На следующем шаге вызывается нативный метод сброса значений формы reset [9]
 * 
 * [10] установка слушателя событий React элементу form.
 * 
 */</span></code></pre>
<p>Несмотря на то что такой способ типизирования слушателей событий является предпочтительным также не будет лишним рассмотреть и другой имеющийся вариант состоящий в описании непосредственно сигнатуры функции.</p>
<p>Для этого, в нашем конкретном случае, необходимо импортировать обобщенный тип <code class="inline-code">FormEvent&#x3C;T></code>, которому перед размещением в аннотации единственного параметра слушателя события необходимо в качестве аргумента события указать тип нативного <em>dom элемента</em> <code class="inline-code">HTMLFormElement</code>. Также стоит напомнить что в аннотации возвращаемого из слушателя события значения нет необходимости. Подобную рутинную работу необходимо делигировать выводу типов.</p>
<pre><code class="hljs language-typescript">                <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, {FormEvent} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params"></span>)</span>{
                              <span class="hljs-comment">/**[1]      [2]           [3]          [4] */</span>
    <span class="hljs-keyword">const</span> form_submitHandler = (event: FormEvent&#x3C;HTMLFormElement>): <span class="hljs-function"><span class="hljs-params">void</span> =></span> {

    }


    <span class="hljs-keyword">return</span> (
        &#x3C;form onSubmit={form_submitHandler}>
            &#x3C;button <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span>>submit&#x3C;<span class="hljs-regexp">/button>
        &#x3C;/</span>form>
    );
}

<span class="hljs-comment">/**
 * [0] импорт обобщенного типа FormEvent&#x3C;T>
 * которому перед добавлением в аннотацию типа [2]
 * единственного параметра слушателя события [1] 
 * необходимо установить в качестве аргумента типа
 * тип нативного dom элемента HTMLFormElement [3].
 * Указании типа к которому принадлежит возвращаемое
 * из слушателя события значения было указанно лишь
 * для того чтобы напомнить об отсутствии в этом необходимости.
 * Подобную работу нужно делегировать выводу типов.
 */</span></code></pre>
<p>Работа непосредственно с формой обусловила выбор более конкретного типа события каковым в данном примере стал обобщенный тип <code class="inline-code">FormEvent&#x3C;T></code>. При других условиях потребуются другие событийные типы. Кроме того, всегда можно сделать выбор в пользу базового для всех событийных типов <code class="inline-code"></code>SyntheticEvent<T>` который в качестве аргумента типа ожидает тип нативного <em>dom элемента</em>.</p>
<p>Кроме это функциональным компонентам доступно мемоизация слушателей событий при помощи универсального хука <code class="inline-code">useCallback&#x3C;T>()</code>.
Для этого понадобится импортировать универсальную функцию определяющую два обязательных параметра. В качестве первого параметра ожидается функция чье описание устанавливается в качестве аргумента функционального типа. Второй параметр принадлежит к типу массива изменение элементов которого приводит к переинициализации функции переданной в качестве первого параметра данного хука. Поскольку в качестве аргумента функционального тпа ожидается тип описывающий первый параметр хука, то нет необходимости в аннотациях типа её параметров. Или в данном случае её единственного праметра представляющего объект события. В остальном реализация ничем не отличается от предыдущего примера, поэтому повторяющийся код будет исключён.</p>
<pre><code class="hljs language-typescript">                <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React, {useCallback, ReactEventHandler} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Form</span>(<span class="hljs-params"></span>)</span>{
                                 <span class="hljs-comment">/**[1]                    [2]                       [3]*/</span>
    <span class="hljs-keyword">const</span> form_submitHandler = useCallback&#x3C;ReactEventHandler&#x3C;HTMLFormElement>>(<span class="hljs-function"><span class="hljs-params">event</span> =></span> {

    }, [] <span class="hljs-comment">/**[4] */</span> );


    <span class="hljs-keyword">return</span> (
        &#x3C;form onSubmit={form_submitHandler}>
            &#x3C;button <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span>>submit&#x3C;<span class="hljs-regexp">/button>
        &#x3C;/</span>form>
    );
}

<span class="hljs-comment">/**
 * [0] импорт универсальной функции useCallback&#x3C;T>()
 * принимающей в качестве первого обязательного параметра
 * функцию [3], описание которой устанавливается в качестве
 * аргумента функционального типа [1]. D качестве второго
 * обязательного параметра ожидается массив [4] со значениями
 * изменение которых приводит переинициализации функции переданной
 * в качестве первого аргумента.
 */</span></code></pre>
<p>На этом рассмотрение типизирования функционального компонента определенного как <em>Function Declaration</em> завершено. И поскольку тема получилась довольно не маленькая исключим затягивание и перейдем к рассмотрению следующего вида функциональных компонентов.</p>
</section><section id="Opredelenie-komponenta-kak-Function-Expression" name="Определение компонента как Function Expression" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opredelenie-komponenta-kak-Function-Expression" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Определение компонента как Function Expression
            </h2>
        
<p>Поскольку самое необходимое относящиеся ко всем видам <em>React</em> компонентов было рассмотренно в предыдущей теме, в этой и последующих повествование будет сосредоточено исключительно на различиях.</p>
<p>Для определения функционального компонента как <em>Function Expression</em> декларация типов <em>React</em> предусмотривает вспомогательный обобщенный тип <code class="inline-code">FC&#x3C;Props></code> чей идентификатор (имя) является сокращением от <em>Function Component</em>, а аргумент типа ожидающий тип представляющий пропсы явялется необязательным. Поскольку вывод типов ориентируется на тип пропсов указанный или присущий по умолчанию в качестве аргумента типа, то в аннотировании первого параметра функционального компонента нет надобности. Помимо этого типо пропсов по умолчанию описывает необязательное поле <code class="inline-code">children</code> принадлежащего к типу <code class="inline-code">ReactNode</code>.</p>
<pre><code class="hljs language-typescript">             <span class="hljs-comment">/**[0] */</span>
<span class="hljs-keyword">import</span> React , {FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

          <span class="hljs-comment">/**[1]       [2] */</span>
<span class="hljs-keyword">const</span> Timer: FC = <span class="hljs-function">(<span class="hljs-params">{children}</span>) =></span> &#x3C;div>Is Timer!&#x3C;<span class="hljs-regexp">/div>;

/</span>**
 * [<span class="hljs-number">0</span>] импорт обобщенного типа FC&#x3C;P>
 * который указан в аннотации без
 * установки аргумента типа [<span class="hljs-number">1</span>] и
 * несмотря на это ошибки при деструктуризации
 * поля children не возникает даже без аннотации
 * типа первого параметра [<span class="hljs-number">2</span>]
 *<span class="hljs-regexp">/</span></code></pre>
<p>Если тип пропсов указан в качестве аругмента типа <code class="inline-code">FC&#x3C;P></code> и при этом не описывает поле <code class="inline-code">children</code>, то оно всен равно будет определенно в объекте пропсов доступного в качестве первого параметра функционального компонента.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React , {FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TimerProps {
    duration: <span class="hljs-built_in">number</span>;
    <span class="hljs-comment">/**[0] */</span>
}
                 <span class="hljs-comment">/**[1]                     [3]*/</span>
<span class="hljs-keyword">const</span> Timer: FC&#x3C;TimerProps> = <span class="hljs-function">(<span class="hljs-params">{duration, children}</span>) =></span> &#x3C;div>Is Timer!&#x3C;<span class="hljs-regexp">/div>;


export default Timer;

/</span>**
 * [<span class="hljs-number">0</span>] несмотря на то что тип представляющий
 * пропсы и указанный в качестве аргумента
 * типа FC&#x3C;P> [<span class="hljs-number">1</span>] не описывает поле children
 * при их деструктуризации ошибки не возникает [<span class="hljs-number">3</span>]
 *<span class="hljs-regexp">/</span></code></pre>
<p>В отсльном все что было рассмотренно в предыдущей теме относительно пропсов и <code class="inline-code">children</code> идентично и для данного способа типизирования функциональных компонентов.</p>
<p>При возникновении необходимости в определении второго параметра функционального компонента придется самостоятельно указывать аннотацию типа, поскольку по каким-то причинам обобщенный тип <code class="inline-code">FC&#x3C;P></code> этого не предусматривает.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { FC } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TimerProps {}


                             <span class="hljs-comment">/**[1]   [2] */</span>
<span class="hljs-keyword">const</span> Timer: FC&#x3C;TimerProps> = <span class="hljs-function">(<span class="hljs-params">props, ref</span>) =></span> &#x3C;div>Is Timer!&#x3C;<span class="hljs-regexp">/div>;

/</span>**
 * Первый параметр [<span class="hljs-number">0</span>] выводится как
 * PropsWithChildren&#x3C;TimerProps>, а
 * второй [<span class="hljs-number">2</span>] как <span class="hljs-built_in">any</span>, поскольку обобщенный
 * тип FC&#x3C;P> не предусматривает его наличие.
 *<span class="hljs-regexp">/</span></code></pre>
<p>В остальном все рассмотренное относительно рефов в теме посвященной функциональным компонентам определенным как <em>Function Declaration</em> верно и для текущего вида определения с единственным исключением. Поскольку в отдличии от определений <em>Function Declaration</em> определния <em>Function Expression</em> могут содержать аннотацию, то при необходимости во втором параметре можно отказаться от типа <code class="inline-code">FC&#x3C;P></code> в пользу ранее рассмотренного типа <code class="inline-code">ForwardRefRenderFunction&#x3C;T, P></code>. При указании данного типа в аннотации функционального компонента пропадает необходимость как а явном аннотировании типов его параметров, так и в указании аргументов типа универсальной функции <code class="inline-code">forwardRef&#x3C;T, P>()</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React, { FC, forwardRef, ForwardRefRenderFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TimerProps {}


                    <span class="hljs-comment">/**[1] */</span>
<span class="hljs-keyword">const</span> Timer: ForwardRefRenderFunction&#x3C;HTMLDivElement, TimerProps> = <span class="hljs-function">(<span class="hljs-params">props, ref</span>) =></span> &#x3C;div>Is Timer!&#x3C;<span class="hljs-regexp">/div>;


                        /</span>**[<span class="hljs-number">2</span>] *<span class="hljs-regexp">/
const TimerWithRef = forwardRef(Timer);

export default TimerWithRef;

/</span>**
 * [<span class="hljs-number">0</span>] импорт типа для указания его в аннотации
 * функционального компонента [<span class="hljs-number">1</span>] определяющего второй
 * параметр ref. После этого нет необходимости в явной
 * аннотации типов как обоих параметров функционального
 * компонента, так и универсальной функции forwardRef&#x3C;T, P>().
 *<span class="hljs-regexp">/</span></code></pre>
<p>Важной особенностью использования обобщенного типа <code class="inline-code">FC&#x3C;P></code> заключается в том, что он помимо типа представляющего пропсы, также содержит описание типа возвращаемого функцией значения. Вроде бы так и должно быть, но нюанс заключается в том, что возвращаемое значение обязательно должно принадлежать к типу совместимому с <code class="inline-code">ReactElement&#x3C;P, T></code>. Простыми словами на этапе компиляции возникнет ошибка если функциональный компонент определенный как <em>Fuction Expression</em> будет возвращать значение принадлежащие к типам <code class="inline-code">number</code>, <code class="inline-code">string</code>, <code class="inline-code">boolean</code> или абсолютно любому массиву.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React , {FC} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> A: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-number">0123</span>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">const</span> B: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-string">"0123"</span>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">const</span> C: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">const</span> D: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> []; <span class="hljs-comment">// Error</span>

<span class="hljs-keyword">const</span> E: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> &#x3C;div>&#x3C;<span class="hljs-regexp">/div>; /</span><span class="hljs-regexp">/ Ok
const F: FC = () => &#x3C;E/</span>>; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">const</span> G: FC = <span class="hljs-function"><span class="hljs-params">()</span> =></span> &#x3C;>&#x3C;<span class="hljs-regexp">/>; /</span><span class="hljs-regexp">/ Ok</span></code></pre>
<p> Поэтому в случаях когда функционеальный компонент определен как <em>Function Expression</em> и при возвращаемое им значение должно принадлежать к типам не совместимым с <code class="inline-code">ReactElement&#x3C;P, T></code> необходимо самостоятельно описывать его сигнатуру. Что не представляет никакого труда.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> React ,{MutableRefObject} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TimerProps {}

<span class="hljs-keyword">const</span> Timer = <span class="hljs-function">(<span class="hljs-params">props: TimerProps, ref: MutableRefObject&#x3C;HTMLDivElement></span>) =></span> <span class="hljs-number">123</span>;</code></pre>
<p>Если в подобном определении функциональных компонентов существует частая потребность будет целесооббразней определить собственный тип подробно описывающий сигнатуру функции.</p>
<p>Для этого потребуется определеить обобщенный тип с двумя необязательными параметрами. Первый необязательный параметр представляющий тип пропсов должен расширять и к тому же указывать в качестве типа по умолчанию тип <code class="inline-code">object</code>. ВТорой необязательный параметр типа должен проделывать тоже что и первый для типа представляющего базовый нативный тип <em>dom элемента</em> <code class="inline-code">HTMLElement</code>.</p>
<p>Чтобы не заморачиватся в определении <code class="inline-code">children</code> указываем принадлежность первого параметра функции к уже знакомому обобщеному типу <code class="inline-code">PropsWithChildren&#x3C;P></code> которому в качестве аргумента типа устанавливаем первый параметр типа <code class="inline-code">P</code>. Второму необязательному параметру функции указываем принадлежность к обобщенному типу <code class="inline-code">MutableRefObject&#x3C;E></code> в качестве аргмента типа которому устанавливаем второй параметр типа <code class="inline-code">E</code>. Осталось лишь указать принадлежность возвращаемого функцией значения к типу <code class="inline-code">ReactNode</code> и тип <code class="inline-code">CFC&#x3C;P, E></code> что является сокращением от <em>Custom Functional Component</em> готов к тому чтобы сэкономить время и нервы разработчика.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// file CFC.ts</span>

<span class="hljs-keyword">import</span> React ,{MutableRefObject, ReactNode, PropsWithChildren} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

         <span class="hljs-comment">/**[0][1]         [2]     [3][4]           [5]            [6]                       [7]                      [8]             [9]*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> CFC&#x3C;P <span class="hljs-keyword">extends</span> object = object, E <span class="hljs-keyword">extends</span> HTMLElement = HTMLElement> = <span class="hljs-function">(<span class="hljs-params">props: PropsWithChildren&#x3C;P>, ref?: MutableRefObject&#x3C;E></span>) =></span> ReactNode;

<span class="hljs-comment">/**
 * [0] определяем обобщенный тип CustomDunctionComponent
 * или сокращенно CFC первый необязательный параметр представляющего
 * пропсы которого [1] расширяет [2] и устанавливает по умолчанию [3]
 * тип object. Второй необязательный параметр пердставляющий тип нативного
 * dom элемента [4] расширяет [5] и устанавливает по умолчанию [6] тип HTMLElement.
 * 
 * [7] устанавливаем принадлежность первого параметра функционального типа к
 * обобщенному типу PropsWithChildren&#x3C;P> которому в качестве аргумента типа передаем первый
 * параметр типа. 
 * 
 * [8] определяем принадлежность второго необязательного параметра к обобщенному типу
 * MutableRefObject&#x3C;E> которому в качестве аргумента типа устанавливаем второй параметр типа.
 * 
 * [9] тип возвращаемого значения определяем как ReactNode.
 *  
 */</span>


<span class="hljs-comment">// file Timer.tsx</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> {CFC} <span class="hljs-keyword">from</span> <span class="hljs-string">"./CFC"</span>; <span class="hljs-comment">/**[0] */</span>


<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TimerProps {}

          <span class="hljs-comment">/**[1]    [2]           [3]            [4]   [5]     [6]*/</span>
<span class="hljs-keyword">const</span> Timer: CFC&#x3C;TimerProps, HTMLDivElement> = <span class="hljs-function">(<span class="hljs-params">props, ref</span>) =></span> <span class="hljs-number">123</span>;

<span class="hljs-comment">/**
 * [0] импорт CustomFunctionCOmponent для
 * указания его в качестве типа функционального
 * компонента определенного как Function Expression [1].
 * В качестве первого параметра типа устанавливается тип
 * представляющий пропсы [2], а в качестве второго тип нативного
 * dom элемента с которым будет ассоциирован объект реф [3].
 * При таком подходе отпадает необходимость в явном указании аннотации
 * типов как пропсов [4], так и рефы [5]. Кроме того возвращаемое значение
 * может принадлежать к любому типу совместимому с типом ReactNode [6]
 */</span></code></pre>
<p>На этом тема касающаяся функциональных компонентов себя полностью исчерпала, поэтому без лишних слов будет продвигатся дальше к следующей теме посвященной классовым компонентам.</p>
</section>