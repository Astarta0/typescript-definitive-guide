<section id="Tipizaciya-Function-Types-vajno" name="Типизация (Function Types) - важно" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipizaciya-Function-Types-vajno" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типизация (Function Types) - важно
            </h2>
        
<hr>
<p>Немаловажной частью при работе с функциями является понимание совместимости функциональных типов. Одни правила совместимости функциональных типов являются более очевидными, нежели другие, впервые столкнувшись с которыми, из-за отрыва их от глобального замысла, может сложится неправильное впечатление. Для того чтобы понять замысел создателей <em>TypeScript</em> нужно детально разобрать каждый момент, но прежде стоит уточнить одну деталь. В примерах, которые будут обсуждаться в главе, посвященной типизации функциональных типов, будет использоваться уточняющий шаблон <code class="inline-code">: Target = Source</code>, о котором шел разговор в самом начале.</p>
<p>Кроме того, объектные типы, указанные в сигнатуре функции, ведут себя также, как было описано в главе, посвященной совместимости объектных типов.</p>
</section><section id="Tipizaciya-Function-Types-sovmestimost-parametrov" name="Типизация (Function Types) - совместимость параметров" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipizaciya-Function-Types-sovmestimost-parametrov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типизация (Function Types) - совместимость параметров
            </h2>
        
<hr>
<p>Первое, на что стоит обратить внимание, это параметры функции. На параметры функции приходится наибольшее количество неоднозначностей, связанных с совместимостью.</p>
<p>Начать стоит с того, что две сигнатуры считаются совместимыми, если они имеют равное количество параметров с совместимыми типами данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params">p1: <span class="hljs-built_in">number</span>, p2: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v1: T1 = <span class="hljs-function">(<span class="hljs-params">p3: <span class="hljs-built_in">number</span>, p4: <span class="hljs-built_in">string</span></span>) =></span> {}; <span class="hljs-comment">// Ok -> different prop identifiers</span>
<span class="hljs-keyword">let</span> v2: T1 = <span class="hljs-function">(<span class="hljs-params">p1: <span class="hljs-built_in">number</span>, p2: <span class="hljs-built_in">boolean</span></span>) =></span> {}; <span class="hljs-comment">// Error</span></code></pre>
<p>При этом стоит заметить, что идентификаторы параметров не участвуют в проверке на совместимость.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params"> ...rest: <span class="hljs-built_in">number</span>[ ] </span>) =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v1: T1 = <span class="hljs-function">(<span class="hljs-params">...numbers: <span class="hljs-built_in">number</span>[]</span>) =></span> {}; <span class="hljs-comment">// Ok -> different prop identifiers</span></code></pre>
<p>Кроме того, параметры, помеченные как необязательные, берутся в расчет только тогда, когда они участвуют в проверке на совместимость по признакам количества параметров.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params"> p1: <span class="hljs-built_in">number</span>, p2?: <span class="hljs-built_in">string</span> </span>) =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v1: T1 = <span class="hljs-function">(<span class="hljs-params"> p1: <span class="hljs-built_in">number</span> </span>) =></span> {}; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v2: T1 = <span class="hljs-function">(<span class="hljs-params"> p1: <span class="hljs-built_in">number</span>, p2: <span class="hljs-built_in">string</span> </span>) =></span> {}; <span class="hljs-comment">// Ok or Error with active flag --strictNullChecks</span>
<span class="hljs-keyword">let</span> v3: T1 = <span class="hljs-function">(<span class="hljs-params"> p1: <span class="hljs-built_in">number</span>, p2: <span class="hljs-built_in">boolean</span> </span>) =></span> {}; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v4: T1 = <span class="hljs-function">(<span class="hljs-params"> p1: <span class="hljs-built_in">number</span>, p2?: <span class="hljs-built_in">boolean</span> </span>) =></span> {}; <span class="hljs-comment">// Error</span></code></pre>
<p>Функция, которая имеет в параметрах остаточные параметры, будет двусторонне совместима с любой функцией, так как остаточные параметры расцениваются как параметры, которые могут принадлежать к любому типу данных и чье количество находится в диапазоне от нуля до бесконечности.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params">...rest: <span class="hljs-built_in">any</span>[]</span>) =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> T2 = <span class="hljs-function">(<span class="hljs-params"> p0: <span class="hljs-built_in">number</span>, p1: <span class="hljs-built_in">string</span> </span>) =></span> <span class="hljs-built_in">void</span>;


<span class="hljs-keyword">let</span> v0: T1 = <span class="hljs-function">(<span class="hljs-params"> ...rest </span>) =></span> {};
<span class="hljs-keyword">let</span> v1: T2 = <span class="hljs-function">(<span class="hljs-params"> p0, p1 </span>) =></span> {};

<span class="hljs-keyword">let</span> v2: T1 = v1; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v3: T2 = v0; <span class="hljs-comment">// Ok</span></code></pre>
<p>В случае, если перед остаточными параметрами объявлены обязательные параметры, то функция будет совместима с любой другой функцией, которая совместима с обязательной частью.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T0 = <span class="hljs-function">(<span class="hljs-params"> p0: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">any</span>[] </span>) =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params"> p0: <span class="hljs-built_in">number</span>, p1: <span class="hljs-built_in">string</span> </span>) =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> T2 = <span class="hljs-function">(<span class="hljs-params"> p0: <span class="hljs-built_in">string</span>, p1: <span class="hljs-built_in">string</span> </span>) =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v0: T0 = <span class="hljs-function">(<span class="hljs-params"> p0, ...rest </span>) =></span> {};
<span class="hljs-keyword">let</span> v1: T1 = <span class="hljs-function">(<span class="hljs-params"> p0, p1 </span>) =></span> {};
<span class="hljs-keyword">let</span> v2: T2 = <span class="hljs-function">(<span class="hljs-params"> p0, p1 </span>) =></span> {} ;

<span class="hljs-keyword">let</span> v3: T0 = v1; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v4: T1 = v0; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v5: T2 = v0; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v6: T0 = v2; <span class="hljs-comment">// Error</span></code></pre>
<p>Следующий, один из неочевидных моментов совместимости функциональных типов, заключается в том, что сигнатура с меньшим числом параметров, совместима с сигнатурой, с большим числом параметров, но не наоборот. Это правило верно при условии соблюдения предыдущих правил, относящихся к совместимости типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T0 = <span class="hljs-function">(<span class="hljs-params">p0: <span class="hljs-built_in">number</span>, p1: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v0: T0 = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: T0 = <span class="hljs-function">(<span class="hljs-params">p: <span class="hljs-built_in">number</span></span>) =></span> {}; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v3: T1 = <span class="hljs-function">(<span class="hljs-params">p?: <span class="hljs-built_in">number</span></span>) =></span> {}; <span class="hljs-comment">// Ok -> optional param</span>
<span class="hljs-keyword">let</span> v4: T1 = <span class="hljs-function">(<span class="hljs-params">p: <span class="hljs-built_in">number</span></span>) =></span> {}; <span class="hljs-comment">// Error -> in type S params more then in type T</span></code></pre>
<p>На данный момент уже известно, что два объектных типа (<code class="inline-code">:T = S</code>), на основании структурной типизации, считаются совместимыми, если в типе <code class="inline-code">S</code> присутствуют все признаки типа <code class="inline-code">T</code>. Помимо этого, тип <code class="inline-code">S</code> может быть более специфическим, чем тип <code class="inline-code">T</code>. Простыми словами, тип <code class="inline-code">S</code>, помимо всех признаков, присущих в типе <code class="inline-code">T</code>, также может иметь признаки, которые в типе <code class="inline-code">T</code> отсутствуют, но не наоборот. Простыми словами, больший тип совместим с меньшим типом данных. В случае с параметрами функциональных типов, все с точностью наоборот.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = <span class="hljs-function">(<span class="hljs-params"> p0: <span class="hljs-built_in">number</span> </span>) =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v0: T = <span class="hljs-function">(<span class="hljs-params"> p0 </span>) =></span> {}; <span class="hljs-comment">// Ok, equal params</span>
<span class="hljs-keyword">let</span> v1: T = <span class="hljs-function"><span class="hljs-params">(  )</span> =></span> {}; <span class="hljs-comment">// Ok, less params</span>
<span class="hljs-keyword">let</span> v2: T = <span class="hljs-function">(<span class="hljs-params"> p0, p1 </span>) =></span> {}; <span class="hljs-comment">// Error, more params</span></code></pre>
<p>Такое поведение проще всего объяснить на примере работы с методами массива. За основу будет взят метод <code class="inline-code">forEach</code> из библиотеки <em>TypeScript</em>.</p>
<pre><code class="hljs language-typescript">forEach(callbackfn: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: T[]</span>) =></span> <span class="hljs-built_in">void</span>, thisArg?: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span>;</code></pre>
<p>В данном случае нужно обратить внимание на функциональный тип первого параметра, в котором задекларировано три других параметра.</p>
<pre><code class="hljs language-typescript">callbackfn: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: T[]</span>) =></span> <span class="hljs-built_in">void</span></code></pre>
<p>Если бы функциональный тип с большим числом параметров не был совместим с функциональным типом с меньшим числом параметров, то при работе с методом <code class="inline-code">forEach</code>, при необходимости только в одном, первом параметре, обязательно бы приходилось создавать callback со всеми тремя параметрами, что привело бы к излишнему коду.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { name: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">class</span> Elephant <span class="hljs-keyword">extends</span> Animal {}
<span class="hljs-keyword">class</span> Lion <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-keyword">let</span> animalAll: Animal[ ] = [
  <span class="hljs-keyword">new</span> Elephant(),
  <span class="hljs-keyword">new</span> Lion()
];

<span class="hljs-keyword">let</span> nameAnimalAll: <span class="hljs-built_in">string</span>[ ] = [ ];

animalAll.forEach( <span class="hljs-function">(<span class="hljs-params"> value, index, source </span>) =></span> nameAnimalAll.push( value.name ) ); <span class="hljs-comment">// Bad</span>
animalAll.forEach( <span class="hljs-function"><span class="hljs-params">value</span> =></span> nameAnimalAll.push( value.name ) ); <span class="hljs-comment">// Good</span></code></pre>
<p>Кроме того, обобщенные функции, чьим параметрам в качестве типа указан параметр типа, проверяются на совместимость по стандартному сценарию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>&#x3C;<span class="hljs-title">T</span>>(<span class="hljs-params">p0: T</span>): <span class="hljs-title">void</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">S</span>>(<span class="hljs-params">p0: T, p1: S</span>): <span class="hljs-title">void</span> </span>{}


<span class="hljs-keyword">type</span> T0 = <span class="hljs-keyword">typeof</span> f0;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-keyword">typeof</span> f1;


<span class="hljs-keyword">let</span> v0: T0 = f1; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v1: T1 = f0; <span class="hljs-comment">// Ok</span></code></pre>
<p>Также стоит знать, что параметры, принадлежащие к конкретным типам, совместимы с параметрами, которым в качестве типов указаны параметры типа, но не наоборот.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>&#x3C;<span class="hljs-title">T</span>>(<span class="hljs-params"> p: T </span>): <span class="hljs-title">void</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"> p: <span class="hljs-built_in">number</span> </span>): <span class="hljs-title">void</span> </span>{}


<span class="hljs-keyword">type</span> T0 = <span class="hljs-keyword">typeof</span> f0;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-keyword">typeof</span> f1;



<span class="hljs-keyword">let</span> v0: T0 = f1; <span class="hljs-comment">// Error, параметр типа T не совместим с параметром типа number</span>
<span class="hljs-keyword">let</span> v1: T1 = f0; <span class="hljs-comment">// Ok, параметр типа number совместим с параметром типа T</span></code></pre>
<p>Помимо того, что две сигнатуры считаются совместимыми, в случаях, в которых участвующие в проверке параметры принадлежат к одному типу, они также считаются совместимыми, если параметры принадлежат к совместимым типам данных. С этим связана ещё одна неочевидность.</p>
<p>Как известно, в контексте объектных типов, если тип <code class="inline-code">T1</code> не идентичен полностью типу <code class="inline-code">T2</code>, и при этом тип <code class="inline-code">T1</code> совместим с типом <code class="inline-code">T2</code>, то значит тип <code class="inline-code">T2</code> будет совместим с типом <code class="inline-code">T1</code> через операцию приведения типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> T0 { f0: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">class</span> T1 { f0: <span class="hljs-built_in">number</span>; f1: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">let</span> v0: T0 = <span class="hljs-keyword">new</span> T1(); <span class="hljs-comment">// Ok -> неявное преобразование типов</span>

<span class="hljs-keyword">let</span> v1: T1 = <span class="hljs-keyword">new</span> T0(); <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v2: T1 = <span class="hljs-keyword">new</span> T0() <span class="hljs-keyword">as</span> T1; <span class="hljs-comment">// Ok -> явное приведение типов</span></code></pre>
<p>С типами в аннотации параметров функций все тоже самое, только не требуется явного преобразование типов. Такое поведение называется бивариантностью (глава <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-variantnosti" title="Экскурс в типизацию - Совместимость типов на основе вариантности" target="_blank">Экскурс в типизацию - Совместимость типов на основе вариантности</a>) параметров и создано для того, чтобы сохранить совместимость с распространенными в <em>JavaScript</em> практиками.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> T0 { f0: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">class</span> T1 { f0: <span class="hljs-built_in">number</span>; f1: <span class="hljs-built_in">string</span>; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params"> p: T1 </span>): <span class="hljs-title">void</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"> p: T0 </span>): <span class="hljs-title">void</span> </span>{}

<span class="hljs-keyword">type</span> FT0 = <span class="hljs-keyword">typeof</span> f0;
<span class="hljs-keyword">type</span> FT1 = <span class="hljs-keyword">typeof</span> f1;


<span class="hljs-comment">// бивариантное поведение</span>

<span class="hljs-keyword">let</span> v0: FT0 = f1; <span class="hljs-comment">// Ok, параметр с типом T1 совместим с параметром принадлежащим к типу T0. Кроме того, тип T1 совместим с типом T0.</span>
<span class="hljs-keyword">let</span> v1: FT1 = f0; <span class="hljs-comment">// Ok, параметр с типом T0 совместим с параметром принадлежащем к типу T1. Но тип T0 не совместим с типом T1  без явного приведения.</span></code></pre>
<p>Изменить поведение бивариантного сопоставления параметров можно с помощью опции компилятора     <code class="inline-code">--strictFunctionTypes</code>. Установив флаг <code class="inline-code">--strictFunctionTypes</code> в <code class="inline-code">true</code>, сопоставление будет происходить по контрвариантным правилам (глава <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-variantnosti" title="Экскурс в типизацию - Совместимость типов на основе вариантности" target="_blank">Экскурс в типизацию - Совместимость типов на основе вариантности</a>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> T0 { f0: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">class</span> T1 { f0: <span class="hljs-built_in">number</span>; f1: <span class="hljs-built_in">string</span>; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>(<span class="hljs-params"> p: T1 </span>): <span class="hljs-title">void</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"> p: T0 </span>): <span class="hljs-title">void</span> </span>{}

<span class="hljs-keyword">type</span> FT0 = <span class="hljs-keyword">typeof</span> f0;
<span class="hljs-keyword">type</span> FT1 = <span class="hljs-keyword">typeof</span> f1;


<span class="hljs-comment">// контрвариантное поведение</span>

<span class="hljs-keyword">let</span> v0: FT0 = f1; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: FT1 = f0; <span class="hljs-comment">// Error</span></code></pre>
</section><section id="Tipizaciya-Function-Types-sovmestimost-vozvrashchaemogo-znacheniya" name="Типизация (Function Types) - совместимость возвращаемого значения" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipizaciya-Function-Types-sovmestimost-vozvrashchaemogo-znacheniya" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типизация (Function Types) - совместимость возвращаемого значения
            </h2>
        
<hr>
<p>Первое, на что стоит обратить внимание, это ожидаемое поведение при проверке на совместимость возвращаемых типов данных. Другими словами, две сигнатуры считаются совместимыми, если их типы,  указанные в аннотации возвращаемого значения, совместимы по правилам структурной типизации, которой подчиняются все объекты в <em>TypeScript</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> T0 { f0: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">class</span> T1 { f0: <span class="hljs-built_in">number</span>; f1: <span class="hljs-built_in">string</span>; }

<span class="hljs-keyword">type</span> FT0 = <span class="hljs-function"><span class="hljs-params">()</span> =></span> T0;
<span class="hljs-keyword">type</span> FT1 = <span class="hljs-function"><span class="hljs-params">()</span> =></span> T1;


<span class="hljs-keyword">let</span> v0: FT0 = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-keyword">new</span> T1(); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: FT1 = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-keyword">new</span> T0(); <span class="hljs-comment">// Error</span></code></pre>
<p>Исключением из этого правила составляет примитивный тип данных <code class="inline-code">void</code>. Как стало известно из главы посвященной типу данных <code class="inline-code">void</code>, в обычном режиме он совместим только с типами <code class="inline-code">null</code> и <code class="inline-code">undefined</code>, так как они являются его подтипами. При активной опции <code class="inline-code">--strictNullChecks</code>, примитивный тип <code class="inline-code">void</code> совместим только с типом <code class="inline-code">undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v0: <span class="hljs-built_in">void</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ok and Error with strictNullChecks</span>
<span class="hljs-keyword">let</span> v1: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Ok</span></code></pre>
<p>Но это правило неверно, если тип <code class="inline-code">void</code> указан в аннотации возвращаемого из функции значения. В случаях, когда примитивный тип <code class="inline-code">void</code> указан в качестве возвращаемого из функции типа данных, он совместим со всеми типами данных, без исключения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">let</span> v0: T = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: T = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v2: T = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v3: T = <span class="hljs-function"><span class="hljs-params">()</span> =></span> ({}); <span class="hljs-comment">// Ok</span></code></pre>
<p>Причину, по которой поведение типа <code class="inline-code">void</code>, в случаях указания его в аннотации возвращаемого из функции значения, было изменено, лучше рассмотреть на примере работы с массивом, а точнее его методом <code class="inline-code">forEach</code>.</p>
<p>Предположим, есть два массива. Первый массив состоит из элементов, принадлежащих к объектному типу, у которого определенно поле <code class="inline-code">name</code>. Второй массив предназначен для хранения строк, и имеет длину, равную <code class="inline-code">0</code>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { name: <span class="hljs-built_in">string</span>; }

<span class="hljs-keyword">let</span> animalAll: Animal[ ] = [
 <span class="hljs-keyword">new</span> Animal(),
 <span class="hljs-keyword">new</span> Animal()
];</code></pre>
<p>Задача заключается в получении имен объектов из первого массива с последующим сохранением их во второй массив.</p>
<p>Для этого создадим callback-стрелочную функцию. Слева от стрелки будет расположен один параметр <code class="inline-code">value</code>, а справа — операция сохранения имени во второй массив с помощью метода <code class="inline-code">push</code>.</p>
<p>Если обратится к декларации метода массива <code class="inline-code">forEach</code>, то можно убедится, что в качестве callback’а этот метод  принимает функцию, у которой отсутствует возвращаемое значение.</p>
<pre><code class="hljs language-typescript">forEach(callbackfn: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: T[]</span>) =></span> <span class="hljs-built_in">void</span>, thisArg?: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span>;</code></pre>
<p>Но в нашем случае, в теле callbeck’а происходит операция добавления элемента в массив. Результатом этой операции является значение длины массива. То есть, метод <code class="inline-code">push</code> возвращает значение, принадлежащий к типу <code class="inline-code">number</code>, которое в свою очередь возвращается из callback (стрелочной функции), переданного в метод <code class="inline-code">forEach</code>, у которого callback задекларирован как возвращающий тип <code class="inline-code">void</code>, что противоречит возвращенному типу <code class="inline-code">number</code>. В данном случае отсутствие ошибки объясняется совместимостью типа <code class="inline-code">void</code>, используемого в функциональных типах, со всеми остальными типами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal { name: <span class="hljs-built_in">string</span>; }

<span class="hljs-keyword">let</span> animalAll: Animal[ ] = [
 <span class="hljs-keyword">new</span> Animal(),
 <span class="hljs-keyword">new</span> Animal()
];

<span class="hljs-keyword">let</span> nameAnimalAll: <span class="hljs-built_in">string</span>[ ] = [ ];

animalAll.forEach( <span class="hljs-function"><span class="hljs-params">value</span> =></span> nameAnimalAll.push( value.name ) ); <span class="hljs-comment">// forEach ожидает () => void, а получает () => number, так как стрелочная функция ыбез тела неявно возвращает значение, возвращаемое методом push.</span></code></pre>
<p>И напоследок стоит упомянуть, что две обобщенные функции считаются совместимы, если у них в аннотации возвращаемого значения указан параметр типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>&#x3C;<span class="hljs-title">T</span>>(<span class="hljs-params"> p: T </span>): <span class="hljs-title">T</span> </span>{ <span class="hljs-keyword">return</span> p; }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>&#x3C;<span class="hljs-title">S</span>>(<span class="hljs-params"> p: S </span>): <span class="hljs-title">S</span> </span>{ <span class="hljs-keyword">return</span> p; }


<span class="hljs-keyword">type</span> T0 = <span class="hljs-keyword">typeof</span> f0;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-keyword">typeof</span> f1;


<span class="hljs-keyword">let</span> v0: T0 = f1; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: T1 = f0; <span class="hljs-comment">// Ok</span></code></pre>
<p>Кроме того, параметр типа совместим с любым конкретным типом данных, но не наоборот.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f0</span>&#x3C;<span class="hljs-title">T</span>>(<span class="hljs-params"> p: T </span>): <span class="hljs-title">T</span> </span>{ <span class="hljs-keyword">return</span> p; }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"> p: <span class="hljs-built_in">number</span> </span>): <span class="hljs-title">number</span> </span>{ <span class="hljs-keyword">return</span> p; }


<span class="hljs-keyword">type</span> T0 = <span class="hljs-keyword">typeof</span> f0;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-keyword">typeof</span> f1;


<span class="hljs-keyword">let</span> v0: T0 = f1; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v1: T1 = f0; <span class="hljs-comment">// Ok</span></code></pre>
</section>