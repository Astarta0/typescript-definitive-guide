<section id="Primitivnye-Tipy-Enum" name="Примитивные Типы Enum" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Primitivnye-Tipy-Enum" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Примитивные Типы Enum
            </h2>
        
<hr>
<p>Сложно представить приложение, которое бы обошлось без специальных-конфигурационных значений, которые разработчики выносят в отдельные классы со статическими свойствами-константами, чтобы избежать так называемых <em>магических значений</em>. <em>TypeScript</em> предлагает решение в виде перечисления <code class="inline-code">Enum</code>. <code class="inline-code">Enum</code> идеологически, представляет из себя набор логически связанных констант. Значения констант может быть как числа, так и строки.</p>
</section><section id="Enum-enum-primitivnyi-perechislyaemyi-tip" name="Enum (enum) примитивный перечисляемый тип" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Enum-enum-primitivnyi-perechislyaemyi-tip" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Enum (enum) примитивный перечисляемый тип
            </h2>
        
<hr>
<p><code class="inline-code">Enum</code>, это конструкция, состоящая из набора именованных констант называемого списком перечисления и определяемого такими примитивными типами, как <code class="inline-code">number</code> и <code class="inline-code">string</code>. Enum объявляется с помощью ключевого слова <code class="inline-code">enum</code>.</p>
</section><section id="Perechisleniya-s-chislovym-znacheniem" name="Перечисления с числовым значением" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Perechisleniya-s-chislovym-znacheniem" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Перечисления с числовым значением
            </h2>
        
<hr>
<p>Идентификаторы-имена для перечислений <code class="inline-code">Enum</code> принято задавать во множественном числе. В случае, когда идентификаторам констант значение не устанавливается явно, они ассоциируются с числовым значениями, в порядке возрастания, начиная с нуля. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Fruits {
  Apple,   <span class="hljs-comment">// 0</span>
  Pear,   <span class="hljs-comment">// 1</span>
  Banana <span class="hljs-comment">// 2</span>
}</code></pre>
<p>Также можно установить любое значение вручную.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Citrus {
 Lemon = <span class="hljs-number">2</span>,  <span class="hljs-comment">// 2</span>
 Orange = <span class="hljs-number">4</span>, <span class="hljs-comment">// 4</span>
 Lime = <span class="hljs-number">6</span>      <span class="hljs-comment">// 6</span>
}</code></pre>
<p>Если указать значение частично, то компилятор будет стараться соблюдать последовательность.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Berrys {
  Strawberry = <span class="hljs-number">1</span>,
  Raspberry, <span class="hljs-comment">// 2</span>

  Blueberry = <span class="hljs-number">4</span>,
  Cowberry <span class="hljs-comment">// 5</span>
}</code></pre>
<p>Но автоматически компилятор рассчитывает значение на основе значения предыдущего члена перечисления. То есть, в перечислении с четырьмя константами, одной из которых значение установлено явно, предположим третья по счету константа со  значением <code class="inline-code">0</code>, значения для остальных констант будут устанавливаться следующим образом. Первой константе будет задано значение <code class="inline-code">0</code>, второй, так как у первой значение <code class="inline-code">0</code>, будет установлено значение <code class="inline-code">1</code>. Третьей константе мы явно установим значение <code class="inline-code">0</code>, поэтому компилятор пропускает её и идет дальше. Четвертой, последней константе он устанавливает значение <code class="inline-code">1</code>, так как у предыдущего члена перечисления установлено значение <code class="inline-code">0</code>. Таким образом компилятор неявно создал повторяющиеся значения <code class="inline-code">1</code>. При попытке получить строковое представление константы перечисления по числовому повторяющемуся числовому значению, в качестве результата будет возвращена та константа, которая была определена последней.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Nuts {
  Peanuts,        <span class="hljs-comment">// 0</span>
  Walnut,        <span class="hljs-comment">// 1</span>
  Hazelnut = <span class="hljs-number">0</span>, <span class="hljs-comment">// 0</span>
  Cedar        <span class="hljs-comment">// 1</span>
}
<span class="hljs-built_in">console</span>.log( Nuts[ Nuts.Peanuts ] ); <span class="hljs-comment">// Hazelnut</span>
<span class="hljs-built_in">console</span>.log( Nuts[ Nuts.Walnut ] ); <span class="hljs-comment">// Cedar</span></code></pre>
<p>Вдобавок ко всему <code class="inline-code">Enum</code> позволяет задавать псевдонимы (alias). Псевдонимам устанавливается значение константы, на которую они ссылаются.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Langues {
  Apple,            <span class="hljs-comment">// en, value = 0</span>
  Apfel = Apple,   <span class="hljs-comment">// de, value = 0</span>
  LaPomme = Apple <span class="hljs-comment">// fr, value = 0</span>
}</code></pre>
<p>При обращении к константе перечисления через точечную нотацию, будет возвращено значение. Обращении к перечислению с помощью скобочной нотации и указания значения в качестве ключа, будет возвращено строковое представление идентификатора константы.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> value: <span class="hljs-built_in">number</span> = Fruits.Apple; <span class="hljs-comment">// 0</span>
<span class="hljs-keyword">let</span> identificator: <span class="hljs-built_in">string</span> = Fruits[ value ]; <span class="hljs-comment">// “Apple”</span></code></pre>
<p>Так как <code class="inline-code">Enum</code> представляет реальные значения, без которых программа будет неработоспособна, <code class="inline-code">Enum</code> обязан оставаться в коде после компиляции. Поэтому чтобы быстрее понять <code class="inline-code">Enum</code>, нужно посмотреть на него в скомпилированном-конечном виде. Но прежде создадим его самостоятельно. </p>
<p><em>1 шаг.</em> Тем кто ранее работал с <code class="inline-code">Enum</code>, уже известно, что <code class="inline-code">Enum</code> позволяет получать  строковое представление константы, а также значение ассоциированное с ней. Поэтом чтобы создать <code class="inline-code">Enum</code>, нам потребуется ассоциативный массив, коими в <em>JavaScript</em> являются объекты. Назовем объект <code class="inline-code">Fruits</code> и передадим его в качестве аргумента в функцию <code class="inline-code">initialization</code>, в которую поместим код его инициализации. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialization</span>(<span class="hljs-params"> Fruits </span>)</span>{

}</code></pre>
<p><em>2 шаг.</em> Создадим поле с именем <code class="inline-code">Apple</code> и присвоим ему в качестве значения  <code class="inline-code">0</code>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialization</span>(<span class="hljs-params"> Fruits </span>)</span>{
  Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span>;
}</code></pre>
<p><em>3 шаг.</em> Ассоциация константа-значение, создана, осталось создать зеркальную ассоциацию значение-константа. Для этого создадим ещё одно поле у которого в качестве ключа будет выступать значение <code class="inline-code">0</code>, а в качестве значения строковое представление константы, то есть имя.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialization</span>(<span class="hljs-params"> Fruits </span>)</span>{
  Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span>;
  Fruits[ <span class="hljs-number">0</span> ] = <span class="hljs-string">"Apple"</span>;
}</code></pre>
<p><em>4 шаг.</em> Теперь сократим код. И для начала вспомним что результатом операции присваивания является значение правого операнда. Поэтому сохраним результат первого выражения в переменную <code class="inline-code">value</code>, а затем используем её в качестве ключа во втором выражении. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialization</span>(<span class="hljs-params"> Fruits </span>)</span>{
  <span class="hljs-keyword">let</span> value = Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span>; <span class="hljs-comment">// тоже самое что value = 0</span>
  Fruits[ value ] = <span class="hljs-string">"Apple"</span>; <span class="hljs-comment">// тоже самое что Fruits[ 0 ] = "Apple";</span>
}</code></pre>
<p><em>5 шаг.</em> Продолжим сокращать и в первом выражении откажемся от переменной <code class="inline-code">value</code>, а во втором выражении на её место поместим первое выражение. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialization</span>(<span class="hljs-params"> Fruits </span>)</span>{
  Fruits[ Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span> ] = <span class="hljs-string">"Apple"</span>;
}</code></pre>
<p><em>6 шаг.</em> Теперь проделаем тоже самое для двух других констант. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialization</span>(<span class="hljs-params"> Fruits </span>)</span>{
  Fruits[ Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span> ] = <span class="hljs-string">"Apple"</span>;
  Fruits[ Fruits[ <span class="hljs-string">"Lemon"</span> ] = <span class="hljs-number">1</span> ] = <span class="hljs-string">"Lemon"</span>;
  Fruits[ Fruits[ <span class="hljs-string">"Orange"</span> ] = <span class="hljs-number">2</span> ] = <span class="hljs-string">"Orange"</span>;
}</code></pre>
<p><em>7 шаг.</em> Теперь превратим функции <code class="inline-code">intialization</code> в самовызывающиеся функциональное выражение, а лучше анонимное самовызывающееся функциональное выражение.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits = {};

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> Fruits </span>)</span>{
  Fruits[ Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span> ] = <span class="hljs-string">"Apple"</span>;
  Fruits[ Fruits[ <span class="hljs-string">"Pear"</span> ] = <span class="hljs-number">1</span> ] = <span class="hljs-string">"Pear"</span>;
  Fruits[ Fruits[ <span class="hljs-string">"Banana"</span> ] = <span class="hljs-number">2</span> ] = <span class="hljs-string">"Banana"</span>;
})( Fruits );</code></pre>
<p><em>8 шаг.</em> И перенесем инициализацию объекта прямо в место вызова.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> Fruits;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> Fruits </span>)</span>{
 Fruits[ Fruits[ <span class="hljs-string">"Apple"</span> ] = <span class="hljs-number">0</span> ] = <span class="hljs-string">"Apple"</span>;
 Fruits[ Fruits[ <span class="hljs-string">"Pear"</span> ] = <span class="hljs-number">1</span> ] = <span class="hljs-string">"Pear"</span>;
 Fruits[ Fruits[ <span class="hljs-string">"Banana"</span> ] = <span class="hljs-number">2</span> ] = <span class="hljs-string">"Banana"</span>;
})( Fruits || (Fruits = {}) );</code></pre>
<p>Перечисление готово. Осталось сравнить созданное перечисление с кодом полученным в результате компиляции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// enum сгенерированный typescript compiler</span>
<span class="hljs-keyword">var</span> Fruits;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fruits</span>) </span>{
  Fruits[Fruits[<span class="hljs-string">"Apple"</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">"Apple"</span>;
  Fruits[Fruits[<span class="hljs-string">"Pear"</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">"Pear"</span>;
  Fruits[Fruits[<span class="hljs-string">"Banana"</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">"Banana"</span>;
})(Fruits || (Fruits = {}));</code></pre>
<p>Теперь добавим  в рассматриваемое перечисление псевдоним <code class="inline-code">LaPomme</code> (яблоко на французском языке) для константы <code class="inline-code">Apple</code>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Fruits {
   Apple,                    <span class="hljs-comment">// 0</span>
   Pear,                  <span class="hljs-comment">// 1</span>
   Banana,                 <span class="hljs-comment">// 2</span>

   LaPomme = Apple <span class="hljs-comment">// 0</span>
}</code></pre>
<p>И снова взглянем на получившийся в результате компиляции код. Можно увидеть, что псевдоним создается также, как обычная константа, но в качестве значения ему присваивается значение идентичное константе, на которую он ссылается.</p>
<pre><code class="hljs language-typescript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fruits</span>) </span>{
  Fruits[Fruits[<span class="hljs-string">"Apple"</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">"Apple"</span>;
  Fruits[Fruits[<span class="hljs-string">"Lemon"</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">"Lemon"</span>;
  Fruits[Fruits[<span class="hljs-string">"Ornge"</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">"Ornge"</span>;
  Fruits[Fruits[<span class="hljs-string">"LaPomme"</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">"LaPomme"</span>; <span class="hljs-comment">// псевдоним</span>
})(Fruits || (Fruits = {}));</code></pre>
<p>По причине того, что конструкции <code class="inline-code">Enum</code> не существует в <code class="inline-code">JavaScript</code>, хочется сказать лишь одно - данный тип перечисления безусловно стоит применять тогда, когда нужна двухсторонняя ассоциация ключа с его числовым значением или проще говоря карта <em>“строковой ключ - числовое значение \ числовой ключ - строковое значение”</em>. </p>
</section><section id="Perechisleniya-so-strokovym-znacheniem" name="Перечисления со строковым значением" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Perechisleniya-so-strokovym-znacheniem" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Перечисления со строковым значением
            </h2>
        
<hr>
<p>Помимо значения с типом данных <code class="inline-code">Number</code>, <em>TypeScript</em> позволяет в перечислении указывать в качестве значений строки.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> FruitColors {
  Red = <span class="hljs-string">"#ff0000"</span>,
  Green = <span class="hljs-string">"#00ff00"</span>,
  Blue = <span class="hljs-string">"#0000ff"</span>
}</code></pre>
<p>Но в случае, когда константам присваиваются строки, ассоциируется только ключ со значением. Обратная ассоциация, значение-ключ отсутствует. Простыми словами, по идентификатору-имени константы можно получить строковое значение, но по строковому значению получить идентификатор-имя константы невозможно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> FruitColors;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">FruitColors</span>) </span>{
  FruitColors[<span class="hljs-string">"Red"</span>] = <span class="hljs-string">"#ff0000"</span>;
  FruitColors[<span class="hljs-string">"Green"</span>] = <span class="hljs-string">"#00ff00"</span>;
  FruitColors[<span class="hljs-string">"Blue"</span>] = <span class="hljs-string">"#0000ff"</span>;
})(FruitColors || (FruitColors = {}));</code></pre>
<p>Точно также, как <code class="inline-code">Enum</code> с числовыми значениями, <code class="inline-code">Enum</code> со строковыми значениями позволяет создавать псевдонимы (alias).</p>
<p>Добавим в перечисление <code class="inline-code">FruitColors</code> псевдонимы.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> FruitColors {
  Red = <span class="hljs-string">"#ff0000"</span>,
  Green = <span class="hljs-string">"#00ff00"</span>,
  Blue = <span class="hljs-string">"#0000ff"</span>,

  Rouge = Red, <span class="hljs-comment">// fr "#ff0000"</span>
  Vert = Green,  <span class="hljs-comment">// fr "#00ff00"</span>
  Bleu = Blue     <span class="hljs-comment">// fr "#0000ff"</span>
}</code></pre>
<p>И снова изучим скомпилированный код. Можно убедится, что псевдонимы создаются также как и константы. А значение присваиваемое псевдонимам идентично значению констант, на которые они ссылаются.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> FruitColors;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">FruitColors</span>) </span>{
  FruitColors[<span class="hljs-string">"Red"</span>] = <span class="hljs-string">"#ff0000"</span>;
  FruitColors[<span class="hljs-string">"Green"</span>] = <span class="hljs-string">"#00ff00"</span>;
  FruitColors[<span class="hljs-string">"Blue"</span>] = <span class="hljs-string">"#0000ff"</span>;
  FruitColors[<span class="hljs-string">"Rouge"</span>] = <span class="hljs-string">"#ff0000"</span>;
  FruitColors[<span class="hljs-string">"Vert"</span>] = <span class="hljs-string">"#00ff00"</span>;
  FruitColors[<span class="hljs-string">"Bleu"</span>] = <span class="hljs-string">"#0000ff"</span>;
})(FruitColors || (FruitColors = {}));</code></pre>
</section><section id="Smeshannoe-perechislenie-mixed-enum" name="Смешанное перечисление (mixed enum)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Smeshannoe-perechislenie-mixed-enum" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Смешанное перечисление (mixed enum)
            </h2>
        
<hr>
<p>Если в одном перечислении объявлены, как числовые константы, так и строковые, то такое перечисление называется <em>смешанным</em> (mixed enum). </p>
<p>Со смешанным перечислением связаны две неочевидные особенности. </p>
<p>Первая из них заключается в том,что константам, которым значение не задано явно, присваивается числовое значение по правилам перечисления с числовыми константами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Stones {
  Peach,                 <span class="hljs-comment">// 0</span>
  Apricot = <span class="hljs-string">"apricot"</span>
}</code></pre>
<p>Вторая особенность заключается в том, что если константа, которой значение не было присвоено явно, следует после константы со строковым значением, то такой код не скомпилируется. Причина заключается в том, что как было рассказано в главе “Перечисления с числовым значением”, если константе значение не было установлено явно, то её значение будет рассчитано, как значение предшествующей ей константе <code class="inline-code">+1</code>, либо <code class="inline-code">0</code>, в случае её отсутствия. А так как у предшествующей константы значение принадлежит к строковому типу, то рассчитать число на его основе не представляется возможным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Stones {
  Peach,                 <span class="hljs-comment">// 0</span>
  Apricot = <span class="hljs-string">"apricot"</span>,
  Cherry,              <span class="hljs-comment">// Error</span>
  Plum                <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Для разрешения этой проблемы, значение, константе смешанного перечисления, которая объявлена после константы со строковым значением и которой значение не было задано явно, необходимо задавать явно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Stones {
  Peach,                <span class="hljs-comment">// 0</span>
  Apricot = <span class="hljs-string">"apricot"</span>,
  Cherry = <span class="hljs-number">1</span>,         <span class="hljs-comment">// 1</span>
  Plum               <span class="hljs-comment">// 2</span>
}</code></pre>
</section><section id="Perechislenie-v-kachestve-tipa-dannyh" name="Перечисление в качестве типа данных" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Perechislenie-v-kachestve-tipa-dannyh" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Перечисление в качестве типа данных
            </h2>
        
<hr>
<p>Может возникнуть мысль использовать перечисление в качестве типа данных переменной или параметра. Это вполне нормальное желание, но нужно быть очень  осторожным, в <em>TypeScript</em> с перечислением связан один достаточно неприятный нюанс.
Дело в том, что пока в перечислении есть хотя бы одна константа с числовым значением, он будет совместим с типом <code class="inline-code">Number</code>. Простыми словами, любое число проходит проверку совместимости типов с любым перечислением.</p>
<p>Функцию, тип единственного параметра который является смешанным перечислением, благополучно получится вызвать как с константой перечисления в качестве аргумента, так и с любым числом. Вызвать эту же функцию, с идентичной константе перечисления строкой, уже не получится.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Fruits {
  Apple,
  Pear,
  Banana = <span class="hljs-string">"banana"</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFruitInStore</span>(<span class="hljs-params"> fruit: Fruits </span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

isFruitInStore( Fruits.Banana ); <span class="hljs-comment">// Ok</span>
isFruitInStore( <span class="hljs-number">123456</span> ); <span class="hljs-comment">// Ok!</span>
isFruitInStore( <span class="hljs-string">"banana"</span> ); <span class="hljs-comment">// Error</span></code></pre>
<p>Если перечисление содержит константы только со строковым значением, то совместимыми считаются только константы перечисления указанного в качестве типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Berrys {
 Strawberry = <span class="hljs-string">"strawberry"</span>,
 Raspberry = <span class="hljs-string">"raspberry"</span>,
 Blueberry = <span class="hljs-string">"blueberry"</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBerryInStory</span>(<span class="hljs-params"> berry: Berrys </span>): <span class="hljs-title">boolean</span> </span>{
 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

isBerryInStory( Berrys.Strawberry ); <span class="hljs-comment">// Ok</span>
isBerryInStory( <span class="hljs-number">123456</span> ); <span class="hljs-comment">// Error</span>
isBerryInStory( <span class="hljs-string">"strawberry"</span> ); <span class="hljs-comment">// Error</span></code></pre>
<p>Поведение не совсем очевидное, поэтому при использовании перечислений в которых присутствуют константы с числовым значением, в качестве типа данных, об этом нельзя забывать.</p>
</section><section id="Perechislenie-const-s-chislovym-i-strokovym-znacheniem" name="Перечисление const с числовым и строковым значением" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Perechislenie-const-s-chislovym-i-strokovym-znacheniem" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Перечисление const с числовым и строковым значением
            </h2>
        
<hr>
<p>Перечисление <code class="inline-code">Enum</code> объявленное с помощью ключевого слова const после компиляции не оставляет в коде, уже привычных, конструкций. Вместо этого компилятор встраивает в места, в которых происходит обращение к значениям перечисления, литералы значений. Значениями констант перечисления могут быть как числовыми так и строковыми типами данных. И как в обычных перечислениях, в перечислениях объявленных с помощью ключевого слова <code class="inline-code">const</code>, есть возможность создавать псевдонимы (alias) для уже объявленных констант.</p>
<p>Если создать два перечисления <code class="inline-code">Apple</code> и <code class="inline-code">Pear</code> у каждого из которых будет объявлена константа <code class="inline-code">Sugar</code> с числовым значением, то на основе этих констант можно рассчитать количество сахара в яблочно-грушевом соке. Присвоив результат операции сложения количества сахара в промежуточную переменную, мы получим хорошо читаемое, задекларированное выражение.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> Apple {
  Sugar = <span class="hljs-number">10</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> Pear {
  Sugar = <span class="hljs-number">10</span>
}

<span class="hljs-keyword">let</span> calciumInApplePearJuice: <span class="hljs-built_in">number</span> = Apple.Sugar + Pear.Sugar;</code></pre>
<p>После компиляции от перечисления не остается и следа, так как константы, заменены числовыми литералами. Такое поведение называется <em>inline встраивание</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> calciumInApplePearJuice = <span class="hljs-number">10</span> + <span class="hljs-number">10</span>;</code></pre>
<p>Обращение к значению через точечную нотацию, требует большего времени, чем обращение к литеральному значению напрямую. Поэтому код с <em>inline</em> конструкциями выполняется быстрее по сравнению с кодом, в котором происходит обращение к членам объекта. Прибегать к подобному подходу рекомендуется только в тех частях кода, которые подвержены высоким нагрузкам. За счет перечисления объявленного с ключевым словом <code class="inline-code">const</code>, исходный код будет легко читаемым, а конечный код более производительным.</p>
<p>Тип <code class="inline-code">Enum</code> является уникальным для <em>TypeScript</em>, в<em> JavaScript</em> подобного типа не существует.</p>
</section><section id="Itog" name="Итог" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itog" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итог
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Примитивный тип данных перечисление (<code class="inline-code">Enum</code>), это конструкция представляющая из себя список именованных констант.</li>
<li class="book__list__item">Объявление перечисления происходит с помощью ключевого слова <code class="inline-code">enum</code>.</li>
<li class="book__list__item">Константы перечисления быть ассоциированы с такими типами как <code class="inline-code">Number</code> и <code class="inline-code">String</code>.</li>
<li class="book__list__item">В случае, когда в перечислении отсутствует явное указание значений, они ассоциируются с числовыми значениям в возрастающем порядке начиная с нуля.</li>
<li class="book__list__item">В случае, когда значения в перечислении заданы не всем константам, константам которым значение не было задано, ассоциируются с числовыми значениями основываясь на результате значения предыдущей константы или точки отсчета - нуля.</li>
<li class="book__list__item">Константе нужно присваивать значение явно, если впереди стоящей объявленной было присвоено строковое значение.</li>
<li class="book__list__item">Нельзя забывать что с перечислениями в которых присутствуют константы со значением типа <code class="inline-code">Number</code>, совместимость проходит любое число.</li>
<li class="book__list__item">Перечисления объявленные с добавлением ключевого слова <code class="inline-code">const</code>, встраивают значения констант <em>inline</em></li>
<li class="book__list__item">Использовать <em>inline встраивание</em> рекомендуется в коде, который подвержен высокой нагрузке.</li>
</ul>
</section>