<section id="Primitivnye-Tipy-Literalnye-Tipy-Number-String-Boolean-Unique-Symbol-Enum" name="Примитивные Типы - Литеральные Типы Number, String, Boolean, Unique Symbol, Enum" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Primitivnye-Tipy-Literalnye-Tipy-Number-String-Boolean-Unique-Symbol-Enum" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Примитивные Типы - Литеральные Типы Number, String, Boolean, Unique Symbol, Enum
            </h2>
        
<hr>
<p>В <em>TypeScript</em> существуют примитивные типы данных, которые называются <em>литеральными типами данных</em>. Как можно понять из названия, типы выражаются литералами значений примитивных типов. Так например число <code class="inline-code">5</code>, строка <code class="inline-code">“apple”</code>, логическое значение <code class="inline-code">true</code> или константа перечисления <code class="inline-code">Fruits.Apple</code>, может выступать в качестве типа данных. Не сложно догадаться, что  в качестве значений могут выступать только литеральные эквиваленты самих типов, а также <code class="inline-code">Null</code> и <code class="inline-code">Undefined</code>.</p>
<p>Литеральные типы были созданы для того, чтобы на этапе компиляции выявлять ошибки, возникающие из-за несоответствия значений заранее объявленных констант, которые раньше можно было выявить только на этапе выполнения.</p>
</section><section id="Literalnyi-Tip-Number-Numeric-Literal-Types" name="Литеральный Тип Number (Numeric Literal Types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Literalnyi-Tip-Number-Numeric-Literal-Types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Литеральный Тип Number (Numeric Literal Types)
            </h2>
        
<hr>
<p>Литеральный тип <code class="inline-code">Number</code> должен состоять из литеральных значений входящих в допустимый диапазон чисел, от <code class="inline-code">Number.MIN_VALUE</code> (-9007199254740992) до <code class="inline-code">Number.MAX_VALUE</code> (9007199254740992) и  может записываться в любой системе счисления (двоичной, восьмеричной, десятичной, шестнадцатеричной).</p>
<p>Очень часто в программе фигурируют константные значения, ограничить которые одним типом, недостаточно. Здесь на помощь и приходят литеральные типы данных. Сервер, в конфигурации которого разрешено запускаться на <code class="inline-code">80</code> или <code class="inline-code">42</code> порту, мог бы иметь метод, который вызывали с номером нужного порта, в качестве аргумента. Проверка значения аргумента на принадлежность к разрешенному порту, в блоке <code class="inline-code">if</code>, с последующим выбрасыванием исключения, выявило бы несоответствие только на этапе выполнения. Помощь статической типизации, в данном случае, выражалась лишь в ограничении по типу <code class="inline-code">Number</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> Port80: <span class="hljs-built_in">number</span> = <span class="hljs-number">80</span>;
<span class="hljs-keyword">const</span> Port42: <span class="hljs-built_in">number</span> = <span class="hljs-number">42</span>;

<span class="hljs-comment">// параметры ограничены лишь типом данных</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"> port: <span class="hljs-built_in">number</span> </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-comment">// блок if сообщит об ошибке только во время выполнения</span>
  <span class="hljs-keyword">if</span>( port !== Port80 || port !== Port42 ){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">`port #<span class="hljs-subst">${ port }</span> is not valid.`</span> );
  }
}

start( <span class="hljs-number">81</span> ); <span class="hljs-comment">// вызов с неправильным значением</span></code></pre>
<p>Именно для таких случаев и были введены литеральные типы данных. Благодаря литеральному типу <code class="inline-code">Number</code>, появилась возможность выявлять ошибки не дожидаясь выполнения программы. В данном случае значение допустимых портов можно указать в качестве типа параметров функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> Port80: <span class="hljs-built_in">number</span> = <span class="hljs-number">80</span>;
<span class="hljs-keyword">const</span> Port42: <span class="hljs-built_in">number</span> = <span class="hljs-number">42</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"> port: 80 | 42 </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-comment">// блок if сообщит об ошибке только во время выполнения</span>
  <span class="hljs-keyword">if</span>( port !== Port80 || port !== Port42 ){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">`port #<span class="hljs-subst">${ port }</span> is not valid.`</span> );
  }
}

start( <span class="hljs-number">81</span> ); <span class="hljs-comment">// ошибка выявлена на этапе компиляции!</span></code></pre>
<p>Для повышения семантики кода создадим псевдоним типа для литерального типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ValidProtValue = <span class="hljs-number">80</span> | <span class="hljs-number">42</span>;

<span class="hljs-keyword">const</span> Port80: <span class="hljs-built_in">number</span> = <span class="hljs-number">80</span>;
<span class="hljs-keyword">const</span> Port42: <span class="hljs-built_in">number</span> = <span class="hljs-number">42</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"> port: ValidProtValue </span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-comment">// блок if сообщит об ошибке только во время выполнения</span>
  <span class="hljs-keyword">if</span>( port !== Port80 || port !== Port42 ){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">`port #<span class="hljs-subst">${ port }</span> is not valid.`</span> );
  }
}

start( <span class="hljs-number">81</span> ); <span class="hljs-comment">// ошибка выявлена на этапе компиляции!</span></code></pre>
<p>Как уже было сказано ранее литеральный тип <code class="inline-code">Number</code> можно указывать в любой системе счисления.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> NumberLiteralType = <span class="hljs-number">0b101</span> | <span class="hljs-number">0o5</span> | <span class="hljs-number">5</span> | <span class="hljs-number">0x5</span>;</code></pre>
<p>Примитивный литеральный тип <code class="inline-code">Number</code> является уникальным для <em>TypeScript</em>, в <em>JavaScript</em> подобного типа не существует.</p>
</section><section id="Literalnyi-tip-String-String-Literal-Types" name="Литеральный тип String (String Literal Types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Literalnyi-tip-String-String-Literal-Types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Литеральный тип String (String Literal Types)
            </h2>
        
<hr>
<p>Литеральный тип <code class="inline-code">String</code> может быть указан только строковыми литералами заключенные в одинарные ( <code class="inline-code">' '</code> ) или двойные ( <code class="inline-code">" "</code> ) кавычки. Так называемые шаблонные строки, которые заключены в обратные кавычки ( <code class="inline-code">` `</code> ) не могут быть  использоваться в качестве строкового литерального типа.</p>
<p>В ходе разработки, конвенциями проекта, могут быть наложены ограничения на типы используемой анимации. Чтобы не допустить ошибочных идентификационных значений, можно ограничить тип <code class="inline-code">string</code> литеральными значениями.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"> name: "ease-<span class="hljs-keyword">in</span>" | "ease-out" </span>): <span class="hljs-title">void</span> </span>{}

animate( <span class="hljs-string">'ease-in'</span> ); <span class="hljs-comment">// Ok</span>
animate( <span class="hljs-string">'ease-in-out'</span> ); <span class="hljs-comment">// Error</span></code></pre>
<p>Примитивный литеральный тип <code class="inline-code">string</code> является уникальным для <em>TypeScript</em>, в <em>JavaScript</em> подобного типа не существует.</p>
</section><section id="Literalnyi-Tip-Boolean-Boolean-Literal-Types" name="Литеральный Тип Boolean (Boolean Literal Types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Literalnyi-Tip-Boolean-Boolean-Literal-Types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Литеральный Тип Boolean (Boolean Literal Types)
            </h2>
        
<hr>
<p>Литеральный тип <code class="inline-code">Boolean</code> ограничен всего двумя литеральными значениями <code class="inline-code">true</code> и <code class="inline-code">false</code>.</p>
<p>Так как литеральный тип <code class="inline-code">Boolean</code>, также как и обычный тип <code class="inline-code">Boolean</code> состоит всего из двух литеральных значение <code class="inline-code">true</code> и <code class="inline-code">false</code>, то детально разбирать собственно и нечего.</p>
<p>Это прекрасный повод чтобы ещё раз повторить определение. Каждый раз, когда встречаться часть кода, работа которой зависит от заранее определенного значения-константы, стоит подумать, нужно ли ограничивать тип литеральным типом и может ли литеральный тип повысить типобезопасность и семантику кода .</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setFlag</span>(<span class="hljs-params"> flag: <span class="hljs-literal">true</span> | "<span class="hljs-literal">true</span>" </span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>Примитивный Литеральный тип <code class="inline-code">boolean</code> является уникальным для <em>TypeScript</em>, в <em>JavaScript</em> подобного типа не существует.</p>
</section><section id="Literalnyi-Tip-Unique-Symbol-unique-symbol-unikalnyi-simvolnyi-tip" name="Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Literalnyi-Tip-Unique-Symbol-unique-symbol-unikalnyi-simvolnyi-tip" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип
            </h2>
        
<hr>
<p>Несмотря на то, что тип данных <code class="inline-code">symbol</code> является уникальным для программы, с точки зрения системы типов, он не может гарантировать типобезопасность. </p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key: symbol</span>)</span>{
  <span class="hljs-comment">// для успешного выполнения программы предполагается, что параметр key будет принадлежать к типу Symbol.for('key')...</span>
}

f(Symbol.for(<span class="hljs-string">'bad key'</span>)); <span class="hljs-comment">// ... тем не менее функцию f() можно вызвать с любым другим символом</span></code></pre>
<p>Для того чтобы избежать подобный сценарий, <em>TypeScript</em> добавил новый примитивный литеральный тип данных <code class="inline-code">Unique Symbol</code>. <code class="inline-code">Unique Symbol</code> является подтипом <code class="inline-code">Symbol</code> и указывается в аннотации с помощью литерального представления <code class="inline-code">unique symbol</code>.</p>
<p>Создается <code class="inline-code">unique symbol</code> теме же способами, что и <code class="inline-code">Symbol</code>, с помощью прямого вызова конструктора <code class="inline-code">Symbol()</code> или с помощью метода класса <code class="inline-code">Symbol.for()</code>. Но в отличии от <code class="inline-code">symbol</code>, <code class="inline-code">unique symbol</code> может быть указан только в аннотации константы (<code class="inline-code">const</code>) и поля класса (<code class="inline-code">static</code>) объявленного с модификатором <code class="inline-code">readonly</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> v0: unique  symbol = Symbol.for(<span class="hljs-string">'key'</span>); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v1: unique  symbol = Symbol.for(<span class="hljs-string">'key'</span>); <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">var</span> v2: unique  symbol = Symbol.for(<span class="hljs-string">'key'</span>); <span class="hljs-comment">// Error</span>


<span class="hljs-keyword">class</span> Identifier {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> readonly f0: unique symbol = Symbol.for(<span class="hljs-string">'key'</span>); <span class="hljs-comment">// Ok</span>

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> f1: unique symbol = Symbol.for(<span class="hljs-string">'key'</span>); <span class="hljs-comment">// Error</span>
  <span class="hljs-keyword">public</span> f2: unique symbol = Symbol.for(<span class="hljs-string">'key'</span>); <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Кроме того, чтобы ограничить значение до значения принадлежащего к типу <code class="inline-code">unique symbol</code>, требуется  прибегать к механизму запроса типа, который подробно рассматривается в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Type-Queries-zaprosy-tipa-Alias-psevdonimy-tipa" title="Типы - Type Queries (запросы типа), Alias (псевдонимы типа)" target="_blank">Типы - Type Queries (запросы типа), Alias (псевдонимы типа)</a>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> KEY: unique symbol = Symbol.for( <span class="hljs-string">'key'</span> );

<span class="hljs-comment">// аннотация параметра и возвращаемого из функции типа при помощи механизма запросов типа</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> key: <span class="hljs-keyword">typeof</span> KEY </span>): <span class="hljs-title">typeof</span> <span class="hljs-title">KEY</span> </span>{
  <span class="hljs-keyword">return</span> key;
}


f( KEY ); <span class="hljs-comment">// Ok</span>
f( Symbol( <span class="hljs-string">'key'</span> ) ); <span class="hljs-comment">// Error</span>
f( Symbol.for( <span class="hljs-string">'key'</span> ) ); <span class="hljs-comment">// Error</span></code></pre>
<p>Поскольку каждый <code class="inline-code">unique symbol</code> имеет собственное представление в системе типов, то совместимыми могут считаться только символы имеющие идентичную ссылку на объявление.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> KEY: unique symbol = Symbol.for( <span class="hljs-string">'key'</span> );
<span class="hljs-keyword">const</span> OTHER_KEY: unique symbol = Symbol.for( <span class="hljs-string">'key'</span> );

<span class="hljs-keyword">if</span>(KEY === OTHER_KEY){} <span class="hljs-comment">// Error, unique symbol не равно unique symbol</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> key: <span class="hljs-keyword">typeof</span> KEY </span>): <span class="hljs-title">typeof</span> <span class="hljs-title">KEY</span> </span>{
  <span class="hljs-keyword">return</span> key;
}


<span class="hljs-keyword">let</span> key = KEY; <span class="hljs-comment">// let key: symbol; // symbol !== unique symbol</span>

f(key); <span class="hljs-comment">// Error</span></code></pre>
<p>Тип <code class="inline-code">unique symbol</code> предназначен для аннотирования уникальных символьных литералов. С его помощью реализуется задуманное для <em>JavaScript</em> поведение, типизированной среде <em>TypeScript</em>.</p>
</section><section id="Literalnyi-Tip-Enum-Enum-Literal-Types" name="Литеральный Тип Enum (Enum Literal Types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Literalnyi-Tip-Enum-Enum-Literal-Types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Литеральный Тип Enum (Enum Literal Types)
            </h2>
        
<hr>
<p>Литеральный тип <code class="inline-code">Enum</code> ограничивается литеральными значениями его констант. Это утверждение верно, но с одной оговоркой, правило совместимости типов для перечисления у которого имеются константы с числовым значением, распространяется и на литеральный тип <code class="inline-code">Enum</code>.</p>
<p>Напомним, если перечисление составляют только строковые константы, то в качестве значения может быть присвоено только константы перечисления.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Berrys {
 Strawberry = <span class="hljs-string">"strawberry"</span>,
 Raspberry = <span class="hljs-string">"raspberry"</span>,
 Blueberry = <span class="hljs-string">"blueberry"</span>
}


<span class="hljs-keyword">type</span> RedBerry = Berrys.Raspberry | Berrys.Strawberry;

<span class="hljs-keyword">var</span> berry: RedBerry = Berrys.Strawberry; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">var</span> berry: RedBerry = Berrys.Raspberry; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">var</span> berry: RedBerry = Berrys.Blueberry; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">var</span> berry: RedBerry = <span class="hljs-number">123</span>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">var</span> berry: RedBerry = <span class="hljs-string">"strawberry"</span>; <span class="hljs-comment">// Error</span></code></pre>
<p>В том случае, если в перечислении присутствует константа с числовым значение, то в качестве значения может быть присвоено и любое число.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Fruits {
 Apple,
 Pear,
 Banana = <span class="hljs-string">"banana"</span>
}

<span class="hljs-keyword">type</span> FruitGrowOnTree = Fruits.Apple | Fruits.Pear;

<span class="hljs-keyword">var</span> fruit: FruitGrowOnTree = Fruits.Apple; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">var</span> fruit: FruitGrowOnTree = Fruits.Pear; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">var</span> fruit: FruitGrowOnTree = Fruits.Banana; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">var</span> fruit: FruitGrowOnTree = <span class="hljs-number">123</span>; <span class="hljs-comment">// Ok!</span>
<span class="hljs-keyword">var</span> fruit: FruitGrowOnTree = <span class="hljs-string">"apple"</span>; <span class="hljs-comment">// Error</span></code></pre>
<p>Правила литеральных типов Enum распространяются и на перечисление объявленного с помощью ключевого слова <code class="inline-code">const</code>.</p>
<p>Примитивный литеральный тип <code class="inline-code">Enum</code> является уникальным для <em>TypeScript</em>, в <em>JavaScript</em> подобного типа не существует.</p>
</section><section id="Itogi" name="Итоги" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itogi" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итоги
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Литеральный тип <code class="inline-code">Number</code> должен указываться числовыми литералами входящими в допустимый диапазон от <code class="inline-code">Number.MIN_VALUE</code> до <code class="inline-code">Number.MAX_VALUE</code> и может записываться в двоичной, восьмеричной, десятичной и шестнадцатеричной системе счисления.</li>
<li class="book__list__item">Литеральный тип <code class="inline-code">String</code> должен указываться литералами строк заключенные в одинарные (<code class="inline-code">' '</code>) или двойные кавычки (<code class="inline-code">" "</code>).</li>
<li class="book__list__item">Литеральные тип <code class="inline-code">Boolean</code> указывается при помощи литеральных значения <code class="inline-code">true</code> и <code class="inline-code">false</code>.</li>
<li class="book__list__item">Литеральный тип <code class="inline-code">Enum</code> указывается с помощью констант объявленных в перечислении.</li>
<li class="book__list__item">На литеральный тип <code class="inline-code">Enum</code> действуют те же правила сопоставления типов что и на обычный <code class="inline-code">Enum</code>.</li>
</ul>
</section>