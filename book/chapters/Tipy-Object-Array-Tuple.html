<section id="Tipy-Object-Array-Tuple" name="Типы — Object, Array, Tuple" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipy-Object-Array-Tuple" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типы — Object, Array, Tuple
            </h2>
        
<hr>
<p>Пришло время рассмотреть такие типы данных как <code class="inline-code">Object</code> и <code class="inline-code">Array</code>, с которыми разработчики <em>JavaScript</em> уже хорошо знакомы. А также неизвестный в мире <em>JavaScript</em> тип данных <code class="inline-code">Tuple</code>, который не представляет собой ничего сложного.</p>
</section><section id="Object-object-ssylochnyi-obektnyi-tip" name="Object (object) — ссылочный объектный тип" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Object-object-ssylochnyi-obektnyi-tip" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Object (object) — ссылочный объектный тип
            </h2>
        
<hr>
<p>Ссылочный тип данных <code class="inline-code">Object</code> является базовым для всех ссылочных типов в <em>TypeScript</em>.</p>
<p>Помимо того, что в <em>TypeScript</em> существует объектный тип <code class="inline-code">Object</code>, описывающий с помощью глобального интерфейса одноимённый тип из <em>JavaScript</em>, также существует тип данных, который представляет любое объектное значение, и который указывается с помощью ключевого слова <code class="inline-code">object</code>. Поведение типа указанного с помощью ключевого слова и интерфейса различаются.</p>
<p>Переменные, которым указан тип с помощью ключевого слова <code class="inline-code">object</code>, не могут хранить значения примитивных типов, чьи имена начинаются со строчной буквы. В отличие от них, тип интерфейс <code class="inline-code">Object</code> совместим с любым типом данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephant: object;
<span class="hljs-keyword">let</span> lion: <span class="hljs-built_in">Object</span>;

elephant = <span class="hljs-number">5</span>; <span class="hljs-comment">// Error</span>
lion = <span class="hljs-number">5</span>; <span class="hljs-comment">// Ok</span>

elephant = <span class="hljs-string">''</span>; <span class="hljs-comment">// Error</span>
lion = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok</span>

elephant = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Error</span>
lion = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Ok</span>

elephant = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span>
lion = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span>

elephant = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span>
lion = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span></code></pre>
<p>Ограничение объектов типом, указанным с помощью ключевого слова <code class="inline-code">object</code>, будет ограничивать их функционалом интерфейса <code class="inline-code">Object</code>. При попытке обратиться к членам объекта, не задекларированным в интерфейсе <code class="inline-code">Object</code>, возникнет ошибка. Напомним, что в случаях, когда тип нужно сократить до базового, сохранив при этом возможность обращения к специфичным (определенным пользователем) членам объекта, нужно использовать тип <code class="inline-code">any</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> SeaLion {
    rotate(): <span class="hljs-built_in">void</span> {}
    
    voice(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">let</span> seaLionAsObject: object = <span class="hljs-keyword">new</span> SeaLion(); <span class="hljs-comment">// Ok</span>
seaLionAsObject.voice(); <span class="hljs-comment">// Error</span>

<span class="hljs-keyword">let</span> seaLionAsAny: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> SeaLion(); <span class="hljs-comment">// Ok</span>
seaLionAsAny.voice(); <span class="hljs-comment">// Ok</span></code></pre>
<p>Тип интерфейс <code class="inline-code">Object</code> идентичен по своей работе с одноименным типом из <em>JavaScript</em>. Несмотря на то, что тип, указанный с помощью ключевого слова <code class="inline-code">object</code>, имеет схожее название, его поведение отличается от типа интерфейса.</p>
</section><section id="Array-type-ssylochnyi-massivopodobnyi-tip" name="Array (type[]) ссылочный массивоподобный тип" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Array-type-ssylochnyi-massivopodobnyi-tip" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Array (type[]) ссылочный массивоподобный тип
            </h2>
        
<hr>
<p>Ссылочный тип данных <code class="inline-code">Array</code> является типизированным спископодобным объектом, содержащим логику для работы с элементами.</p>
<p>Тип данных <code class="inline-code">Array</code> указывается с помощью литерала массива, перед которым указывается тип данных <code class="inline-code">type[]</code>.</p>
<p>Если при объявлении массива указать тип <code class="inline-code">string[]</code>, то храниться в нем могут только элементы, принадлежащие или совместимые с типом <code class="inline-code">String</code> (например <code class="inline-code">Null</code>, <code class="inline-code">Undefined</code>, <code class="inline-code">Literal Type String</code>)</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> animalAll: <span class="hljs-built_in">string</span>[] = [
    <span class="hljs-string">'Elephant'</span>,
    <span class="hljs-string">'Rhino'</span>,
    <span class="hljs-string">'Gorilla'</span>
];

animalAll.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// Error</span>
animalAll.push(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Error</span>
animalAll.push(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Ok</span>
animalAll.push(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Ok</span></code></pre>
<p>В случае неявного указания типа, вывод типов самостоятельно укажет тип как <code class="inline-code">string[]</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> animalAll = [
    <span class="hljs-string">'Elephant'</span>,
    <span class="hljs-string">'Rhino'</span>,
    <span class="hljs-string">'Gorilla'</span>
]; <span class="hljs-comment">// animalAll : string[]</span></code></pre>
<p>Если массив должен хранить смешанные типы данных, то один из способов это сделать — указать тип объединение (<code class="inline-code">Union</code>). Нужно обратить внимание на то, как трактуется тип данных <code class="inline-code">Union</code> при указании его массиву. Может показаться, что указав в качестве типа тип объединение <code class="inline-code">Union</code>, массив может состоять только из какого-то одного перечисленного типа <code class="inline-code">Elephant</code>, <code class="inline-code">Rhino</code> или <code class="inline-code">Gorilla</code>. Но это не совсем так. Правильная трактовка гласит, что каждый элемент массива может принадлежать к типу <code class="inline-code">Elephant</code> или <code class="inline-code">Rhino</code> или <code class="inline-code">Gorilla</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Elephant {}
<span class="hljs-keyword">class</span> Rhino {}
<span class="hljs-keyword">class</span> Gorilla {}

<span class="hljs-keyword">var</span> animalAll: (Elephant | Rhino | Gorilla)[] = [
    <span class="hljs-keyword">new</span> Elephant(),
    <span class="hljs-keyword">new</span> Rhino(),
    <span class="hljs-keyword">new</span> Gorilla()
];</code></pre>
<p>Если для смешанного массива не указать тип явно, то вывод типов самостоятельно укажет все типы, которые хранятся в массиве. Более подробно эта тема будет рассмотрена в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Vyvod-tipov" title="Типизация - Вывод типов" target="_blank">Типизация - Вывод типов</a>.</p>
<p>В случае, если типы данных неизвестны при создании экземпляра массива, следует указать в качестве типа тип <code class="inline-code">any</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> dataAll: <span class="hljs-built_in">any</span>[] = [];

dataAll.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// Ok -> number</span>
dataAll.push(<span class="hljs-string">'5'</span>); <span class="hljs-comment">// Ok -> string</span>
dataAll.push(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Ok -> boolean</span></code></pre>
<p>Нужно стараться как можно реже использовать массивы со смешанными типами, а к массивам с типом <code class="inline-code">any</code> нужно прибегать только в самых крайних случаях. Кроме того, как было рассказано в главе <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-variantnosti" title="Экскурс в типизацию - Совместимость типов на основе вариантности" target="_blank">Экскурс в типизацию - Совместимость типов на основе вариантности</a>, из-за того, что нужно крайне осторожно относиться к массивам, у которых входные типы являются ковариантными, не рекомендуется указывать массиву базовые типы. </p>
<p>В случаях, в которых требуется создавать массив при помощи оператора <code class="inline-code">new</code>, приходится прибегать к типу глобального обобщённого интерфейса <code class="inline-code">Array&#x3C;T></code>. Обобщения будут рассмотрены чуть позднее, а пока нужно запомнить следующее.</p>
<p>При попытке создать экземпляр массива путем вызова конструктора, операция завершится успехом в тех случаях, когда создаваемый массив будет инициализирован пустым, либо с элементами одного типа данных. В случаях смешанного массива, необходимо явно указывать типы обобщения, заключенные в угловые скобки.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> animalData: <span class="hljs-built_in">string</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">//Ok</span>
<span class="hljs-keyword">let</span> elephantData: <span class="hljs-built_in">string</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">'Dambo'</span>); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> lionData: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[];

lionData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">'Simba'</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Error</span>
lionData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">'Simba'</span>); <span class="hljs-comment">// Ok</span>
lionData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> deerData: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>&#x3C;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>>(<span class="hljs-string">'Bambi'</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Ok</span></code></pre>
<p>В <em>TypeScript</em> поведение типа <code class="inline-code">Array</code> идентично поведению одноимённого типа в <em>JavaScript</em>.</p>
</section><section id="Tuple-T0-T1-Tn-tip-kortej" name="Tuple ([T0, T1, …, Tn]) тип кортеж" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tuple-T0-T1-Tn-tip-kortej" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Tuple ([T0, T1, …, Tn]) тип кортеж
            </h2>
        
<hr>
<p>Тип данных <code class="inline-code">Tuple</code> (кортеж) состоит из строго заданной последовательности типов, череда которых соответствует индексам, указанного в качестве значения массива, начиная с нуля. Тип данных Tuple указывается литералом массива, в котором заключены, перечисленные через запятую, типы данных <code class="inline-code">[T1, T2, T3]</code>.</p>
<p>Массив, выступающий в качестве значения, должен хранить элементы таким образом, чтобы в индексах, соответствующих расположению типов в кортеже, обязательно находились значения совместимые с этими типами.</p>
<p>Другими словами, если переменной, аннотированной типом кортеж имеющим определенную последовательность, состоящую из типов <code class="inline-code">string</code> и <code class="inline-code">number</code>, присвоить ссылку на массив у которого первым элементом хранится строка, а вторым цифра, операция присваивания завершится успехом. Если в массиве первым элементом будет значение <code class="inline-code">null</code>, а вторым <code class="inline-code">undefined</code>, то ошибка выброшена не будет, так как эти типы считаются совместимыми с указанными в кортеже. Но если первым элементом будет цифра, а вторым строка, то возникнет ошибка по причине не соблюдения заданной последовательности типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>]; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> giraffeData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>]; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> liontData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-string">'Simba'</span>]; <span class="hljs-comment">// Error</span></code></pre>
<p>Длина массива-значения должна соответствовать количеству типов, указанных в <code class="inline-code">Tuple</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>]; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> liontData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Simba'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]; <span class="hljs-comment">// Error, лишний элемент</span>
<span class="hljs-keyword">let</span> fawnData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Bambi'</span>]; <span class="hljs-comment">// Error, не достает одного элемента</span>
<span class="hljs-keyword">let</span> giraffeData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = []; <span class="hljs-comment">// Error, не достает всех элементов</span></code></pre>
<p>Но это правило не мешает добавить новые элементы после того, как массив был присвоен ссылке (ассоциирован со ссылкой). Но элементы, чьи индексы выходят за пределы установленные кортежем, обязаны иметь тип, совместимый с одним из перечисленных в этом кортеже.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>];
elephantData.push(<span class="hljs-number">1941</span>); <span class="hljs-comment">// Ok</span>
elephantData.push(<span class="hljs-string">'Disney'</span>); <span class="hljs-comment">// Ok</span>
elephantData.push(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Error, тип boolean, в то время, как допустимы только типы совместимые с типами string и number</span>

elephantData[<span class="hljs-number">10</span>] = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok</span>
elephantData[<span class="hljs-number">11</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Ok</span>

elephantData[<span class="hljs-number">0</span>] = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok, значение совместимо с типом заданном в кортеже</span>
elephantData[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error, значение не совместимо с типом заданном в кортеже</span></code></pre>
<p>Массив, который связан с типом кортежем, ничем не отличается от обычного, за исключение того, как определяются типы его элементов.</p>
<p>При попытке присвоить элемент под индексом 0 переменной с типом <code class="inline-code">string</code>, а элемент под индексом <code class="inline-code">1</code> переменной с типом <code class="inline-code">number</code>, операции присваивания завершатся успехом. Но несмотря на то, что элемент под индексом <code class="inline-code">2</code> принадлежит к литеральному типу <code class="inline-code">string</code>, при попытке присвоить его в качестве значения переменной с типом <code class="inline-code">string</code>, будет выброшена ошибка. Дело в том, что элементы, чьи индексы выходят за пределы установленные кортежем, принадлежат к типу объединению (<code class="inline-code">Union</code>). Это означает что элемент под индексом <code class="inline-code">2</code> принадлежит к типу <code class="inline-code">string | number</code>, а это не то же самое, что тип <code class="inline-code">string</code>, который указан переменной.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>]; <span class="hljs-comment">// Ok</span>

elephantData[<span class="hljs-number">2</span>] = <span class="hljs-string">'nuts'</span>;

<span class="hljs-keyword">let</span> elephantName: <span class="hljs-built_in">string</span> = elephantData[<span class="hljs-number">0</span>]; <span class="hljs-comment">// Ok, тип string</span>
<span class="hljs-keyword">let</span> elephantAge: <span class="hljs-built_in">number</span> = elephantData[<span class="hljs-number">1</span>]; <span class="hljs-comment">// Ok, тип number</span>
<span class="hljs-keyword">let</span> elephantDiet: <span class="hljs-built_in">string</span> = elephantData[<span class="hljs-number">2</span>]; <span class="hljs-comment">// Error, тип string | number</span></code></pre>
<p>Есть два варианта решения этой проблемы. Первый вариант, изменить тип переменной со <code class="inline-code">string</code> на тип объединение <code class="inline-code">string | number</code>, что ненадолго избавит от проблемы совместимости типов. Второй, более подходящий вариант, прибегнуть к приведению типов, который детально будет рассмотрен позднее.</p>
<p>В случае, если описание кортежа может навредить семантике кода, его можно поместить в описание псевдонима типа (<code class="inline-code">type</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Tuple = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];

<span class="hljs-keyword">let</span> v1: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]; <span class="hljs-comment">// плохо</span>
<span class="hljs-keyword">let</span> v2: Tuple; <span class="hljs-comment">// хорошо</span></code></pre>
<p>Кроме того, тип кортеж можно указывать в аннотации остаточных параметров (<code class="inline-code">...rest</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">...rest: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span> ,<span class="hljs-built_in">boolean</span>]</span>): <span class="hljs-title">void</span> </span>{}

<span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span>];
<span class="hljs-keyword">let</span> array = [<span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span>];

f(<span class="hljs-number">5</span>); <span class="hljs-comment">// Error</span>
f(<span class="hljs-number">5</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// Error</span>
f(<span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// Ok</span>
f(...tuple); <span class="hljs-comment">// Ok</span>
f(tuple[<span class="hljs-number">0</span>], tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">2</span>]); <span class="hljs-comment">// Ok</span>
f(...array); <span class="hljs-comment">// Error</span>
f(array[<span class="hljs-number">0</span>], array[<span class="hljs-number">1</span>], array[<span class="hljs-number">2</span>]); <span class="hljs-comment">// Error, все элементы массива принадлежат к типу string | number | boolean, в то время как первый элемент кортежа принадлежит к типу number</span></code></pre>
<p>Помимо этого, типы, указанные в кортеже могут быть помечены как необязательные с помощью необязательного модификатора <code class="inline-code">?</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">...rest: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>?, <span class="hljs-built_in">boolean</span>?]</span>): <span class="hljs-title">void</span> </span>{}

f(); <span class="hljs-comment">// Error</span>
f(<span class="hljs-number">5</span>); <span class="hljs-comment">// Ok</span>
f(<span class="hljs-number">5</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// Ok</span>
f(<span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// Ok</span></code></pre>
<p>У кортежа, который включает типы, помеченные как не обязательные, свойство длины принадлежит к типу объединения (<code class="inline-code">Union</code>) состоящего из литеральных числовых типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">...rest: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>?, <span class="hljs-built_in">boolean</span>?]</span>): [<span class="hljs-title">number</span>, <span class="hljs-title">string</span>?, <span class="hljs-title">boolean</span>?] </span>{
    <span class="hljs-keyword">return</span> rest;
}

<span class="hljs-keyword">let</span> l = f(<span class="hljs-number">5</span>).length; <span class="hljs-comment">// let l: 1 | 2 | 3</span></code></pre>
<p>Кроме того для кортежа существует возможность указывать <code class="inline-code">spread</code> в любой его части, а не только в конце.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Strings = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>];
<span class="hljs-keyword">type</span> Numbers = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];

<span class="hljs-comment">// type Mixed = [string, string, number, number]</span>
<span class="hljs-keyword">type</span> Mixed = [...Strings, ...Numbers];</code></pre>
<p>Когда <code class="inline-code">spread</code> применяется к типу без известной длины (обычный массив <code class="inline-code">...number[]</code>), то результатирующий тип также становится неограниченным и все типы следующие после такого распростронения (обычный массив) образуют с ним тип объединение (<code class="inline-code">Union</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Strings = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>];
<span class="hljs-keyword">type</span> BooleanArray = <span class="hljs-built_in">boolean</span>[];

<span class="hljs-comment">// type Unbounded0 = [string, string, ...(boolean | symbol)[]]</span>
<span class="hljs-keyword">type</span> Unbounded0 = [...Strings, ...BooleanArray, symbol];

<span class="hljs-comment">// type Unbounded1 = [string, string, ...(string | boolean | symbol)[]]</span>
<span class="hljs-keyword">type</span> Unbounded1 = [ ...Strings, ...BooleanArray, symbol, ...Strings]</code></pre>
<p>Механизм объявления множественного распростронения (<code class="inline-code">spread</code>) значительно упрощает  аннотирование сигнатуры функции при реализации непростых сценариев, один из которых будет рассмотрен далее в главе (Массивоподобные readonly типы)[].</p>
<p>Еще несколько неочевидных моментов, связанным с выводом типов при работе с типом кортеж будет рассмотрено в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Vyvod-tipov" title="Типизация - Вывод типов" target="_blank">Типизация - Вывод типов</a> (<em>см реализацию функции concat</em>).</p>
<p>Помимо этого симантику типов кортежей можно повышать за счет добавления им меток.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример безликого кортежа</span>

<span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">p: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</span>) =></span> {}

<span class="hljs-comment">/**
 * автодополнение -> f(p: [string, number]): void
 * 
 * Совершенно не понятно чем конкретно являются
 * элементы представляемые типами string и number
 */</span>
f0()</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример кортежа с помеченными элементами</span>

<span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">p: [a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>]</span>) =></span> {};

<span class="hljs-comment">/**
 * автодополнение -> f(p: [a: string, b: number]): void
 * 
 * Теперь мы знаем что функция ожидает не просто 
 * строку и число, а аргумент "a" и аргумент "b",
 * которые в реальном проекте будут иметь более
 * осмысленное смысловое значение, например "name" и "age".
 */</span>
f1()</code></pre>
<p>Поскольку метки являются исключительной частью синтаксиса <em>TypeScript</em> они не имеют никакой силы в коде при деструктуризации массива представленного типом кортежа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">p: [a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>]</span>) =></span> {
    <span class="hljs-keyword">let</span> [c, d] = p;
};</code></pre>
<p>Единственное правило касающееся данного механизма заключается в том, что кортеж содержащий метки не может содеражть элементы описанные только типами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = [a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>]; <span class="hljs-comment">// Error -> Tuple members must all have names or all not have names.ts(5084)</span></code></pre>
<p>Напоследок стоит обратить внимание на тот факт, что тип переменной при присвоении ей инициализированного массива без явного указания типа, будет выведен как массив. Другими словами вывод типа неспособен вывести тип кортеж.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData = [<span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>]; <span class="hljs-comment">// type Array (string | number)[]</span></code></pre>
<p>Тип <code class="inline-code">Tuple</code> является уникальным для <code class="inline-code">TypeScript</code>, в <code class="inline-code">JavaScript</code> подобного типа не существует.</p>
</section><section id="Itogi" name="Итоги" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itogi" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итоги
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Поведение типа глобального интерфейса <code class="inline-code">Object</code> отличается от типа, указанного с помощью ключевого слова <code class="inline-code">object</code>.</li>
<li class="book__list__item">Объект с типом <code class="inline-code">object</code> является базовым типом для всех ссылочных типов и ограничен <em>api</em> экземпляра класса <code class="inline-code">Object</code>.</li>
<li class="book__list__item">Ссылочный тип <code class="inline-code">Array</code> обозначается с помощью литерала массива, перед которым обязательно указывается тип <code class="inline-code">type[]</code>.</li>
<li class="book__list__item">Очень важным моментом является понимание того, что указывается не тип данных, из которого состоит массив, а тип данных, к которому может принадлежать каждый элемент массива.</li>
<li class="book__list__item">Тип данных <code class="inline-code">Tuple</code> (кортеж) состоит из строго заданной последовательности типов, череда которых соответствует индексам, указанным в качестве значения массива (начиная с нуля) и обозначается литералом массива, в котором заключены перечисленные типы данных.</li>
<li class="book__list__item">Элементы, чьи индексы выходят за границы указанные кортежем, должны быть совместимы с <code class="inline-code">Union</code> от перечисленных в кортеже типов.</li>
<li class="book__list__item">Элементы, чьи индексы выходят за границы указанные кортежем, при присвоении имеют тип объединения (<code class="inline-code">Union</code>), а также не могут быть получены путем деструктуризации.</li>
<li class="book__list__item">Кортеж не выводится с помощью вывода типов.</li>
</ul>
</section>