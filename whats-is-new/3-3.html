<section id="Povyshenie-proizvoditelnosti-sborki-dlya-komandy-build-watch" name="Повышение производительности сборки для команды --build --watch" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Povyshenie-proizvoditelnosti-sborki-dlya-komandy-build-watch" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Повышение производительности сборки для команды --build --watch
        </h2>
        <hr>
        <p>Так как ссылки на проекты, появившиеся в версии <em>v3.0</em>, способны значительно упростить разработку крупных проектов, команда <em>TypeScript</em>, в версии <em>v3,3</em>, направив свои усилия на усовершенствование этого функционала, смогла ускорить процесс сборки при совместном использовании флагов <code class="inline-code">--build</code> и <code class="inline-code">--watch</code> на 50% - 75%, что действительно можно назвать впечатляющим результатом.</p>

    </section>
<section id="Uluchshenie-povedeniya-dlya-tipov-Union-ukazannyh-v-kachestve-parametrov-funkcii" name="Улучшение поведения для типов Union указанных в качестве параметров функции" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Uluchshenie-povedeniya-dlya-tipov-Union-ukazannyh-v-kachestve-parametrov-funkcii" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Улучшение поведения для типов Union указанных в качестве параметров функции
        </h2>
        <hr>
        <p>До версии <em>v3.3</em> было невозможно вызвать функцию даже если аргумент, передаваемый при вызове, принадлежал к типу, включенным в определение каждого объединенного типа указанного в аннотации параметров функциональных типов определяющих объединенный вызываемый тип к которому принадлежит вызываемая функция. </p>
<p>Вышесказанное с трудом поддается осмыслению, поэтому продолжить рассмотрение описанного случая лучше сразу на коде, который по шагам разберет завал из умных слов по полочкам.</p>
<p>Всем нам известно, что объединенный тип (<code class="inline-code">Union</code>) представляет из себя множество типов, к одному из которых может принадлежать ассоциированное с ним значение.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// До v3.3</span>

<span class="hljs-comment">/**
* Несовместимые типы A, B
*/</span>
<span class="hljs-keyword">interface</span> A { a: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> B { b: <span class="hljs-built_in">number</span>; }

<span class="hljs-comment">/**
* Определение функционального типа параметры которого
* принадлежат к типу Union определяющегося типами A и B
*/</span>
<span class="hljs-keyword">type</span> T0 = <span class="hljs-function">(<span class="hljs-params"> p: A | B </span>) =></span> <span class="hljs-built_in">number</span>;

<span class="hljs-comment">/**
* Декларация функции принадлежащий к функциональному типу T0
*/</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> f: T0;


f( { a: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Ok, аргумент принадлежащий к типу A; const f: (p: A | B) => number</span>
f( { b: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Ok, аргумент принадлежащий к типу B; const f: (p: A | B) => number</span></code></pre>
<p>Из кода выше понятно, что компилятор, в случаи первого вызова, определяет принадлежность аргумента к типу <code class="inline-code">A</code>, а во втором к типу <code class="inline-code">B</code>. Все предельно просто, поэтому перейдем к следующему шагу и расширим пример.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// До v3.3</span>

<span class="hljs-comment">/**
* Добавлен ещё один тип C
* Несовместимые типы A, B и C
*/</span>
<span class="hljs-keyword">interface</span> A { a: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> B { b: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> C { c: <span class="hljs-built_in">number</span>; }

<span class="hljs-comment">/**
* добавлена определение ещё одного функционального типа T1
* параметры которого принадлежат к типу Union определяющегося
* типами A и C и также отличным возвращаемым типом
*/</span>
<span class="hljs-keyword">type</span> T0 = <span class="hljs-function">(<span class="hljs-params"> p: A | B </span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params"> p: A | C </span>) =></span> <span class="hljs-built_in">string</span>;

<span class="hljs-comment">/**
* Теперь декларация функции принадлежит к типу Union
*/</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> f: T0 | T1;


f( { a: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Error, (error text is listed below)</span>
f( { b: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Error, (error text is listed below)</span>
f( { c: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Error, (error text is listed below)</span>

<span class="hljs-comment">/**
* Cannot invoke an expression whose type lacks a call
* signature. Type 'T0 | T1' has no compatible call
* signatures.ts(2349)
*/</span></code></pre>
<p>Как видно из кода выше, в случаях, когда вызываемая функция принадлежит к типу <code class="inline-code">Union</code> определенному функциональными типами, в параметрах которых также указаны объединенные типы, даже не смотря на то, что их определение включает общий для всех тип <code class="inline-code">A</code>, возникает ошибка. Это кажется нелогичным, так как тип объединение вызывающий ошибку определяется типами, которые по отдельности к ней не приводят.</p>
<p>Поэтому начиная с версии <em>v3.3</em> это поведение было изменено и теперь код из второго примера не приводит к ошибке.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Начиная с v3.3</span>

<span class="hljs-keyword">interface</span> A { a: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> B { b: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> C { c: <span class="hljs-built_in">number</span>; }


<span class="hljs-keyword">type</span> T0 = <span class="hljs-function">(<span class="hljs-params"> p: A | B </span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params"> p: A | C </span>) =></span> <span class="hljs-built_in">string</span>;


<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> f: T0 | T1;


f( { a: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Ok, const f: (p: A | (A &#x26; C) | (B &#x26; A) | (B &#x26; C)) => string | number</span>
f( { b: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Error, так как тип B определяет объединение указанное только в параметрах типа T0 </span>
f( { c: <span class="hljs-number">0</span> } ); <span class="hljs-comment">// Error, так как тип С определяет объединение указанное только в параметрах типа T1</span></code></pre>
<p>Код выше наглядно демонстрирует сказанное, а именно тот факт, что при вызове функции с аргументом принадлежащем к типу <code class="inline-code">A</code>, который является общим для всех определений типов Union, компилятор рассматривает вызываемую функцию основываясь сразу на двух функциональных типах <code class="inline-code">T0</code> и <code class="inline-code">T1</code> - </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
* Так компилятор начиная с v3.3 видит вызываемый тип
*/</span>
<span class="hljs-keyword">const</span> f: (p: A | (A &#x26; C) | <span class="hljs-function">(<span class="hljs-params">B &#x26; A</span>) | (<span class="hljs-params">B &#x26; C</span>)) =></span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></code></pre>
<p>Кроме того, что уже известно на данный момент, также существует ещё один случай при котором новое поведение работать не будет. Таким случаем является ограничение на использование функциональных обобщены типов. Новое поведение не будет работать, если объединенный тип определяется более чем одним обобщенным вызываемым типом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
* Тип A является обобщенным типом (generics type)
*/</span>
<span class="hljs-keyword">interface</span> A&#x3C;T> { a: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> B { b: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> C { c: <span class="hljs-built_in">number</span>; }

<span class="hljs-comment">/**
* сигнатура обоих типов (T0 и T1) имеют
* объявления параметров типа (T)
*/</span>
<span class="hljs-keyword">type</span> T0 = &#x3C;T><span class="hljs-function">(<span class="hljs-params"> p: A&#x3C;T> | B </span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> T1 = &#x3C;T><span class="hljs-function">(<span class="hljs-params"> p: A&#x3C;T> | C </span>) =></span> <span class="hljs-built_in">string</span>;


<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> f: T0 | T1;


f&#x3C;<span class="hljs-built_in">number</span>>( { a: <span class="hljs-number">0</span>} ); <span class="hljs-comment">// Error, (error text is listed below)</span>

<span class="hljs-comment">/**
* Cannot invoke an expression whose type lacks a call
* signature. Type 'T0 | T1' has no compatible call
* signatures.ts(2349)
*/</span></code></pre>
<p>Как уже было сказано, ошибка возникает из-за того, что оба типа <code class="inline-code">T0</code> и <code class="inline-code">T1</code> являются обобщенными. Но обобщенные типы в реальной практике обычное явление, при возникновении подобного случая единственных выход прибегнуть к механизму закрытия типазаполнителя.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> A&#x3C;T> { a: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> B { b: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> C { c: <span class="hljs-built_in">number</span>; }

<span class="hljs-comment">/**
* Сигнатура только одного типа T0 является обобщенной.
* В определении типа T1 тип A указан с закрытым параметром типа.
*/</span>
<span class="hljs-keyword">type</span> T0 = &#x3C;T><span class="hljs-function">(<span class="hljs-params"> p: A&#x3C;T> | B </span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> T1 = <span class="hljs-function">(<span class="hljs-params"> p: A&#x3C;<span class="hljs-built_in">number</span>> | C </span>) =></span> <span class="hljs-built_in">string</span>;


<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> f: T0 | T1;


f&#x3C;<span class="hljs-built_in">number</span>>( { a: <span class="hljs-number">0</span>} ); <span class="hljs-comment">// Ok, const f: &#x3C;number>(p: A&#x3C;number> | (B &#x26; A&#x3C;number>) | (B &#x26; C) | (A&#x3C;number> &#x26; C)) => string | number</span></code></pre>
<p>Кроме того, новое поведение отразилось на методе принадлежащему классу <code class="inline-code">Array</code>, а именно <code class="inline-code">forEach</code>. До версии <em>v3.3</em>, в случаях когда операции выполнялись над объектом принадлежащем к объединенному типу определенного массивами принадлежащих к разным типам, итерировать с помощью метода <code class="inline-code">forEach</code> над ним можно было лишь после его уточнения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Bird {
   kind: <span class="hljs-string">"bird"</span>;
  
   uniqueBirdProp: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">interface</span> Fish {
   kind: <span class="hljs-string">"fish"</span>;

   uniqueFishProp: <span class="hljs-built_in">string</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBirdAll</span>(<span class="hljs-params">animalAll:Bird[]|Fish[]</span>): <span class="hljs-title">animalAll</span> <span class="hljs-title">is</span> <span class="hljs-title">Bird</span>[] </span>{
   <span class="hljs-keyword">return</span> animalAll[<span class="hljs-number">0</span>].kind === <span class="hljs-string">'bird'</span>
}

<span class="hljs-comment">/**
* Параметр принадлежит к объединеному типу определяемого
* типами массива принадлежащих к типам Bird и Fish
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> animalAll: Bird[] | Fish[] </span>): <span class="hljs-title">void</span> </span>{
   <span class="hljs-comment">/**
    * Уточнение массива с посмощью защитника типа
    */</span>
   <span class="hljs-keyword">if</span>( isBirdAll( animalAll ) ) {
       animalAll.forEach( <span class="hljs-function"><span class="hljs-params">animal</span> =></span> {
           <span class="hljs-comment">// param animal is of type Bird</span>
       } );
   }<span class="hljs-keyword">else</span>{
       animalAll.forEach( <span class="hljs-function"><span class="hljs-params">animal</span> =></span> {
           <span class="hljs-comment">// param animal is of type Fish</span>
       } );
   }
} </code></pre>
<p>Начиная с версии <em>v3.3</em> уточнение типа можно выполнять на уровне метода <code class="inline-code">forEach</code> - </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Bird {
   kind: <span class="hljs-string">"bird"</span>;
  
   uniqueBirdProp: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">interface</span> Fish {
   kind: <span class="hljs-string">"fish"</span>;

   uniqueFishProp: <span class="hljs-built_in">string</span>;
}



<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> animalAll: Bird[] | Fish[] </span>): <span class="hljs-title">void</span> </span>{
   animalAll.forEach( <span class="hljs-function">(<span class="hljs-params"> animal: Bird | Fish </span>) =></span> {
       <span class="hljs-comment">/**
        * Уточнение типа на уровне метода forEach
        */</span>
       <span class="hljs-keyword">if</span>( animal.kind === <span class="hljs-string">'bird'</span> ) {
           <span class="hljs-comment">// param animal is of type Bird</span>
       }<span class="hljs-keyword">else</span>{
           <span class="hljs-comment">// param animal is of type Fish</span>
       }
 </code></pre>

    </section>