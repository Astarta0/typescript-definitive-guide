<section id="Povyshenie-tipobezopasnosti-generotorov" name="Повышение типобезопасности генероторов" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Povyshenie-tipobezopasnosti-generotorov" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Повышение типобезопасности генероторов
        </h2>
        <hr>
        <p>До текущей версии такие конструкции как генераторы (<code class="inline-code">generators</code>) имели недоработки косающиеся определения типа данных возвращаемых, как из, так и во внутрь генератора, значений.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример со значением возвращающимся из генератора </span>

<span class="hljs-comment">// function generator(): IterableIterator&#x3C;"Done" | 100></span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-keyword">yield</span> <span class="hljs-number">100</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-string">`Done`</span>;
}

<span class="hljs-keyword">let</span> iterator = generator(); <span class="hljs-comment">// let iterator: IterableIterator&#x3C;"Done" | 100></span>
<span class="hljs-keyword">let</span> result = iterator.next(); <span class="hljs-comment">// let result: IteratorResult&#x3C;"Done" | 100></span>

<span class="hljs-comment">/**
 * Поскольку генератор перешел взавершенное состояние
 * значение result.value может принадлежать исключительно
 * к типу string ...
 */</span>
<span class="hljs-keyword">if</span> ( result.done ) {
    <span class="hljs-comment">/**
     * ... тем не менее, вывод типов определеяет его
     * как тип объединение (Union) string | number
     */</span>
    <span class="hljs-keyword">let</span> value = result.value; <span class="hljs-comment">// let value: string | number</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример со значением возвращаемым в генератор</span>

<span class="hljs-keyword">type</span> Greeter = {
    greet():<span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">// function generator(): IterableIterator&#x3C;undefined></span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">/**
     * В строке - let greeter: Greeter = yield;
     * предполагается, что возвращенное извнешнего кода
     * значение будетпринадлежать к типу Greeter...
     * 
     */</span>
    <span class="hljs-keyword">let</span> greeter: Greeter = <span class="hljs-keyword">yield</span>;
    greeter.greet();
}

<span class="hljs-keyword">let</span> iterator = generator(); <span class="hljs-comment">// let iterator: IterableIterator&#x3C;undefined></span>
iterator.next();
<span class="hljs-comment">/**
 * Строка ниже приведт кошибке во время выполнения
 * внутри  генератора при вызове метода greeter.greet();
 * поскольку возращенное значение принадлежит к типу number,
 * в то время как ожидается тип Greeter.
 */</span>
iterator.next(<span class="hljs-number">123</span>); <span class="hljs-comment">// Error, runtime error</span></code></pre>
<p>Начиная с версии <em>TypeScript</em> <code class="inline-code">3.6</code> описанные выше недостатки были устранены.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример со значением возвращающимся из генератора </span>

<span class="hljs-comment">/**
 *  &#x3C;v3.6: function generator(): IterableIterator&#x3C;"Done" | 100>
 * >=v3.6: function generator(): Generator&#x3C;number, string, unknown>
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-keyword">yield</span> <span class="hljs-number">100</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-string">`Done`</span>;
}

<span class="hljs-comment">/**
 *  &#x3C;v3.6: let iterator: IterableIterator&#x3C;"Done" | 100>
 * >=v3.6: let iterator: Generator&#x3C;number, string, unknown>
 */</span>
<span class="hljs-keyword">let</span> iterator = generator();

<span class="hljs-comment">/**
 *  &#x3C;v3.6: let result: IteratorResult&#x3C;"Done" | 100>
 * >=v3.6: let result: IteratorResult&#x3C;number, string>
 */</span>
<span class="hljs-keyword">let</span> result = iterator.next();

<span class="hljs-keyword">if</span> ( result.done ) {
    <span class="hljs-comment">/**
     *  &#x3C;v3.6: let value: string | number
     * >=v3.6: let value: string
     */</span>
    <span class="hljs-keyword">let</span> value = result.value;
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример со значением возвращаемым в генератор</span>

<span class="hljs-keyword">type</span> Greeter = {
    greet():<span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">/**
 *  &#x3C;v3.6: function generator(): IterableIterator&#x3C;undefined>
 * >=v3.6: function generator(): Generator&#x3C;undefined, void, Greeter>
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> greeter: Greeter = <span class="hljs-keyword">yield</span>;
    greeter.greet();
}

<span class="hljs-comment">/**
 *  &#x3C;v3.6: let iterator: IterableIterator&#x3C;undefined>
 * >=v3.6: let iterator: Generator&#x3C;undefined, void, Greeter>
 */</span>
<span class="hljs-keyword">let</span> iterator = generator();
iterator.next();
iterator.next(<span class="hljs-number">123</span>); <span class="hljs-comment">// Error! Argument of type '[123]' is not assignable to parameter of type '[] | [Greeter]'.</span></code></pre>
<p>Подобноестало возможно благодаря добавлению шести новых типов перечисленных ниже, которые вы также можете использовать при работе с генераторами. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Iterator&#x3C;T, TReturn = any, TNext = undefined> {<span class="hljs-comment">/** ... */</span>}
<span class="hljs-keyword">type</span> IteratorResult&#x3C;T, TReturn = <span class="hljs-built_in">any</span>> = IteratorYieldResult&#x3C;T> | IteratorReturnResult&#x3C;TReturn>;
<span class="hljs-keyword">interface</span> IteratorReturnResult&#x3C;TReturn> {<span class="hljs-comment">/** ... */</span>}
<span class="hljs-keyword">interface</span> IteratorYieldResult&#x3C;TYield> {<span class="hljs-comment">/** ... */</span>}

<span class="hljs-keyword">interface</span> Generator&#x3C;T = unknown, TReturn = any, TNext = unknown> <span class="hljs-keyword">extends</span> Iterator&#x3C;T, TReturn, TNext> {<span class="hljs-comment">/** ... */</span>}
<span class="hljs-keyword">interface</span> GeneratorFunction {<span class="hljs-comment">/** ... */</span>}
<span class="hljs-keyword">interface</span> GeneratorFunctionConstructor {<span class="hljs-comment">/** ... */</span>}</code></pre>
<p>И напоследок будет не лишним ещё раз взглянуть на очень простой и информативный пример более эффективной работы с генераторами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * Generator&#x3C;number, string, boolean> 
 * или по другому
 * Generator&#x3C;
 *  возвращаемое с помощью оператора yield  значение,
 *  возвращаемое с помощью оператора return значение,
 *  передаваемое в метод next, то есть возвращаемое в генератор, значение
 * > 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">counter</span>(<span class="hljs-params"></span>): <span class="hljs-title">Generator</span>&#x3C;<span class="hljs-title">number</span>, <span class="hljs-title">string</span>, <span class="hljs-title">boolean</span>> </span>{
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">yield</span> i++) {
            <span class="hljs-built_in">console</span>.log(
                <span class="hljs-string">`[if]  Block if in counter generator.
                       Variable value "i": <span class="hljs-subst">${i}</span>`</span>
            );
            
            <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">"Done"</span>;
}



<span class="hljs-keyword">let</span> iterator = counter();
<span class="hljs-keyword">let</span> result = iterator.next();


<span class="hljs-keyword">while</span> ( !result.done ) {
    <span class="hljs-keyword">let</span> returnedFromGeneratorValue = result.value;
    <span class="hljs-keyword">let</span> passedToGeneratorValue = returnedFromGeneratorValue === <span class="hljs-number">3</span>;
    
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`[out] Returned from generator value: <span class="hljs-subst">${ returnedFromGeneratorValue }</span>`</span> );
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`[in]  Passed to generator  value: <span class="hljs-subst">${ passedToGeneratorValue }</span>`</span> );
    
    result = iterator.next(passedToGeneratorValue);
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[end] Return from generator resultant value: <span class="hljs-subst">${result.value.toUpperCase()}</span>`</span> );

<span class="hljs-comment">/**
 * "[out] Returned from generator value: 0"
 * "[in]  Passed to generator  value: false"
 * "[out] Returned from generator value: 1"
 * "[in]  Passed to generator  value: false"
 * "[out] Returned from generator value: 2"
 * "[in]  Passed to generator  value: true"
 * "[if]  Block if in counter generator.
          Variable value "i": 3"
 * "[end] Return from generator resultant value: DONE"
 */</span></code></pre>

    </section>
<section id="Dobavlenie-helpera-imetiruushchego-mehanizm-spread-array-pri-kompilyacii-v-ecmascript-nije-versii-6-pri-neaktivnom-flage-downlevelIteration" name="Добавление хелпера иметирующего механизм spread array при компиляции в ecmascript ниже версии 6 при неактивном флаге --downlevelIteration" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Dobavlenie-helpera-imetiruushchego-mehanizm-spread-array-pri-kompilyacii-v-ecmascript-nije-versii-6-pri-neaktivnom-flage-downlevelIteration" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Добавление хелпера иметирующего механизм spread array при компиляции в ecmascript ниже версии 6 при неактивном флаге --downlevelIteration
        </h2>
        <hr>
        <p>Начиная с версии <code class="inline-code">v3.6</code>, хелпер, генерирующийся при компиляции такой конструкции, как <code class="inline-code">array spread ([...Array(5)])</code>, в ECMAScript ниже 6 версии, при неактивном флаге <code class="inline-code">--downlevelIteration</code>, притерпел кардинальные изменения. Но обо всем по порядку.</p>
<p>До <code class="inline-code">TypeScript</code> версии <code class="inline-code">v3.6</code>, при компиляции кода в версию ниже <code class="inline-code">es6</code>, для эмитации механизма <code class="inline-code">spread</code> примененого к массиву генерировался код объединяющий массивы с помощью его метода <code class="inline-code">.concat()</code> - </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ...[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]; <span class="hljs-comment">// этот код es6+ компилировался в..</span>
<span class="hljs-keyword">var</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>].concat([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// ..этот es5 код</span></code></pre>
<p>Но эмитация подобным образом не соответствует поведению предполагаемого спецификацией <code class="inline-code">es6</code> при использовании массива созданного с помощью конструктора, которому при вызове передали в качестве единственного аргумента числовое значение.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ...Array(<span class="hljs-number">3</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// этот код es6+ компилировался в..</span>
<span class="hljs-keyword">var</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>].concat(<span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>), [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// ..этот es5 код</span></code></pre>
<p>Получение экземпляра массива подобным образом приводит к созданию объекта массива с заданной длиной, равной значению переданного вкачестве аргумента, а также полным отсутствием элементов и следовательно ассоциированных с ними ключей (индексов массива).</p>
<pre><code class="hljs language-typescript"><span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// [empty × 3]</span>

[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]; <span class="hljs-comment">// ['a', 'b', 'c']</span>


<span class="hljs-comment">/**
 * У объекта массива созданного с помощью конструктора
 * длина равна переданному аргументу, то есть 3, но
 * ключи представляющие индекс массива, также как и
 * элементы - отсутствуют.
 */</span>
<span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// псевдо объект массива {length: 3}</span>

<span class="hljs-comment">/**
 * У объекта массива созданного с помощью литерала массива
 * длина равняется количеству его элементов, то есть 3, а также
 * существуют ключи (0, 1, 2) ассоциированные с элементами ('a','b','c').
 */</span>
[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] <span class="hljs-comment">// псевдо объект массива {length: 3, 0: 'a', 1: 'b', 2: 'c'}</span></code></pre>
<p>Не будет лишним напомнить, что элементы у массива созданного с помощью конструктора буквально полностью отсутствуют, а не имеют значение <code class="inline-code">undefined</code>, как может показаться. При обращении к элементам по индексу входящего в диапазон установленного его длиной, <code class="inline-code">undefined</code> возвращается не потому что хранится в качестве элемента, а потому что <code class="inline-code">undefined</code> возвращается всегда при обращении к несуществующему ключу объекта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// случай с объектом созданного при помощи литерала</span>

({prop: <span class="hljs-string">'value'</span>})[<span class="hljs-string">'prop'</span>]; <span class="hljs-comment">// value - обращение к существующему ключу prop  </span>
({})[<span class="hljs-string">'prop'</span>]; <span class="hljs-comment">// undefined - обращение к не существующему ключу prop</span>

<span class="hljs-comment">// случай с массивом созданного при помощи литерала</span>

[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// a - обращение к существующему ключу 0</span>
[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// undefined - обращение к не существующему ключу 10</span>

<span class="hljs-comment">// случай с массивом созданного при помощи конструктора</span>

<span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">// undefined - обращение к не существующему ключу 0</span></code></pre>
<p>Отсутствие ключей является причиной несоответствия количества реальных итераций и длины массива при работе с ними. Методы массива (<code class="inline-code">.forEach()</code>, <code class="inline-code">.map()</code> и др.) и итерирующие конструкции (<code class="inline-code">forin\forof</code>)проверяют ключи с помощью метода <code class="inline-code">.hasOwnProperty(key)</code> доставшегося по наследству от базового типа <code class="inline-code">Object</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * псевдо объект массива {length: 3}
 * Нет ключей - нет итераций!
 * Вывод в консоль: (пусто)
 */</span>
<span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).forEach(<span class="hljs-function"><span class="hljs-params">()</span>=></span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`iteration`</span>));


<span class="hljs-comment">/**
 * псевдо объект массива {length: 3}
 * Нет ключей - нет итераций!
 * Вывод в консоль: (пусто)
 */</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item of <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>)){<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`iteration`</span>);}</code></pre>
<p>Тем не менее при применении механиза <code class="inline-code">spread</code> к массиву в <code class="inline-code">es6+</code> создает несуществующие элементы и заполняет их значениями <code class="inline-code">undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * Длина === 7, количество итераций === 7
 */</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...Array(<span class="hljs-number">3</span>), <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// es6 - [1, 2, undefined, undefined, undefined, 3, 4]</span></code></pre>
<p>Но скомпилированный <code class="inline-code">TypeScript</code> в <code class="inline-code">es &#x3C; v6</code> код при неактивном флаге <code class="inline-code">--downlevelIteration</code>, до версии <code class="inline-code">v3.6</code> не соответствовал этому поведению, поскольку не преобразовывал отсутствующие элементы в элементы ассоциированные со значением <code class="inline-code">undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * Длина === 7, количество итераций === 4!
 */</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...Array(<span class="hljs-number">3</span>), <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// es6 синтаксис компилировался в..</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].concat(<span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>), [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// в es5 подобный код - [1, 2, empty × 3, 2, 3]</span></code></pre>
<p>После того, как коммунити обратило внимание на несоответствие в поведении, подход с нативным методом <code class="inline-code">.concat()</code> заменили на генерацию хелпера <code class="inline-code">__spreadArrays(array)</code> и тем самым исправили поведение на предполагаемое спецификацией. Отказ от нативного <code class="inline-code">.concat()</code> замедлил сказался на производительности, снизив её ровно в два раза.</p>

    </section>
<section id="Rasshirenie-sistemy-tipov-tipami-predstavlyaushchimi-struktury-dannyh-tolko-dlya-chteniya" name="Расширение системы типов типами представляющими структуры данных только для чтения" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirenie-sistemy-tipov-tipami-predstavlyaushchimi-struktury-dannyh-tolko-dlya-chteniya" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Расширение системы типов типами представляющими структуры данных только для чтения
        </h2>
        <hr>
        <p>Начиная с версии <code class="inline-code">v3.6</code>, система типов <code class="inline-code">Typescript</code> пополнилась новыми вспомогательными типами представляющими структуры данных <em>только для чтения</em> (<code class="inline-code">readonly</code>). Такими типами стали <code class="inline-code">ReadonlyMap&#x3C;K, V></code> и <code class="inline-code">ReadonlySet&#x3C;T></code> и в отличии от своих прототипов они не имеют методов способных их изменить.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> map: ReadonlyMap&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>> = <span class="hljs-keyword">new</span> Map([[<span class="hljs-string">"key"</span>, <span class="hljs-number">0</span>]]);
<span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span>: ReadonlySet&#x3C;<span class="hljs-built_in">number</span>> = <span class="hljs-keyword">new</span> Set([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);</code></pre>

    </section>
<section id="Strokovoi-identifikator-funkcii-konstruktora" name="Строковой идентификатор функции-конструктора" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Strokovoi-identifikator-funkcii-konstruktora" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Строковой идентификатор функции-конструктора
        </h2>
        <hr>
        <p><code class="inline-code">TypeScript</code>, начиная сверсии <code class="inline-code">v3.6</code> реализовывает механизм ecmascript спецификации предусматривающей строковое именование функции-конструктора. Другими словами, определение метода идентификатор которого представлен в виде строки экфивалентной <code class="inline-code">"constructor"</code> расценивается как определение функции-конструктора. Если идентификатор помеается как вычисляемый <code class="inline-code">["constructor"]</code>, то такое объявление расценивается обычным методом класса. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// этот ts код...</span>

<span class="hljs-keyword">class</span> T {
    <span class="hljs-string">"constructor"</span>(){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Constructor!`</span>);
    }

    [<span class="hljs-string">"constructor"</span>](){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Method with name "constructor"!`</span>);
    }
}

<span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// output: Constructor!</span>
t.constructor(); <span class="hljs-comment">// output: Method with name "constructor"!</span>


<span class="hljs-comment">// ...будетскомпилирован в этот js код</span>

<span class="hljs-keyword">class</span> T {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Constructor!`</span>);
    }
    [<span class="hljs-string">"constructor"</span>]() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Method with name "constructor"!`</span>);
    }
}
<span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// output: Constructor!</span>
t.constructor(); <span class="hljs-comment">// output: Method with name "constructor"!</span></code></pre>

    </section>
<section id="Rasshirenie-vyvoda-ob-oshibkah-pri-rabote-s-Promise" name="Расширение вывода об ошибках при работе с Promise" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirenie-vyvoda-ob-oshibkah-pri-rabote-s-Promise" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Расширение вывода об ошибках при работе с Promise
        </h2>
        <hr>
        <p>Поскольку работа с <code class="inline-code">Promise</code> является очень важной частью повседневной разработки, <code class="inline-code">TypeScript</code>, начиная с версии <code class="inline-code">v3.6</code>, расширила информирование при возникновении ошибок связанными с ними, а также били добавлены механизмы их быстрогоустранения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Person {
    name:<span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPersonData</span>(<span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">Person</span>></span>;
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printPersonInfo</span>(<span class="hljs-params">personData: Person</span>): <span class="hljs-title">void</span></span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">/**
     * До v3.6 возникала ошибка говорящая что
     * тип Promise&#x3C;Person> не соответствует типу Person
     * 
     * Argument of type 'Promise&#x3C;Person>' is not assignable
     * to parameter of type 'Person'.
     * Type 'Promise&#x3C;Person>' is missing the following properties
     * from type 'Person': name, agets(2345)
     * 
     * 
     * После v3.6 вывод расширили предложением пофиксить
     * ошибку добавлением ключевого слова await
     * 
     * Did you forget to use 'await'?
     * 
     */</span>
    printPersonInfo(getPersonData()); <span class="hljs-comment">// Error</span>
    printPersonInfo(<span class="hljs-keyword">await</span> getPersonData()); <span class="hljs-comment">// Ok</span>
}


<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPersonData</span>(<span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">Person</span>> </span>{
    <span class="hljs-comment">/**
     * Также предлагается пофиксить ошибку путем
     * добавления ключевого слова await 
     * 
     * Property 'json' does not exist on type 'Promise&#x3C;Response>'.ts(2339)
     * Did you forget to use 'await'?
     */</span>
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">``</span>).json(); <span class="hljs-comment">// Error</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> fetch(<span class="hljs-string">``</span>)).json(); <span class="hljs-comment">// Ok</span>
}</code></pre>

    </section>
<section id="Sliyanie-odnoimennyh-klassov-i-funkcii-iz-okrujaushchego-konteksta" name="Слияние одноименных классов и функций из окружающего контекста" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sliyanie-odnoimennyh-klassov-i-funkcii-iz-okrujaushchego-konteksta" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Слияние одноименных классов и функций из окружающего контекста
        </h2>
        <hr>
        <p>Начиная с <code class="inline-code">v3.6</code> был реализован механизм позволяющий сливать воедино одноименные классы и функции находящиеся в одном окружающем контексте.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> Point {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>);
}

declare function Point(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): Point;</code></pre>
<p>Начиная с <code class="inline-code">v3.7</code> компилятор будет прибегать к данной возможности при генерации <code class="inline-code">.d.ts</code> файлов из <code class="inline-code">JavaScript</code> кода.</p>

    </section>
<section id="Dobavlena-podderjka-Unicode-dlya-identifikatorov" name="Добавлена поддержка Unicode для идентификаторов" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Dobavlena-podderjka-Unicode-dlya-identifikatorov" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Добавлена поддержка Unicode для идентификаторов
        </h2>
        <hr>
        <p>Начиная с версии <code class="inline-code">v3.6</code> в <em>TypeScript</em>, для кода компилируемого в <code class="inline-code">--target es2015</code> и выше, была добавлена поддержка символов <em>unicode</em> испольуемых в качестве идентификаторов синтаксических конструкций.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * До v3.6:
 *      Error, Variable declaration expected.
 *      
 * Начиная с v3.6 для --target es2015 и выше
 *      Ok
 */</span>
<span class="hljs-keyword">const</span> 𝓱𝓮𝓵𝓵𝓸 = <span class="hljs-string">"world"</span>;</code></pre>

    </section>
<section id="Podderjka-import-meta-dlya-SystemJS" name="Поддержка import.meta для SystemJS" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Podderjka-import-meta-dlya-SystemJS" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Поддержка import.meta для SystemJS
        </h2>
        <hr>
        <p>В <em>TypeScript</em> <code class="inline-code">v3.6</code> была добавлена возможность трансформации <code class="inline-code">import.meta</code> в <code class="inline-code">context.meta</code> что является  необходимым функционалом при работе с такой модульной системой, как <em>SystemJS</em> (<code class="inline-code">--module system</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// этот код .ts ...</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">import</span>.meta);

<span class="hljs-comment">// ...преобразуется в этот .js код</span>
System.register([], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exports_1, context_1</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;
    <span class="hljs-keyword">var</span> __moduleName = context_1 &#x26;&#x26; context_1.id;
    <span class="hljs-keyword">return</span> {
        setters: [],
        execute: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(context_1.meta);
        }
    };
});</code></pre>

    </section>
<section id="get-i-set-v-okrujaushchem-kontekste" name="get и set в окружающем контексте" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="get-i-set-v-okrujaushchem-kontekste" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            get и set в окружающем контексте
        </h2>
        <hr>
        <p>Начаиная с версии <code class="inline-code">v3.6</code>, <code class="inline-code">TypeScript</code> получил возможность объявлять <code class="inline-code">get/set</code> в окружающем контексте (<code class="inline-code">declare class ID {}</code> или в файлах декларациях <code class="inline-code">.d.ts</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Начиная с v3.6 - Ok</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> T {
    <span class="hljs-keyword">get</span> field():<span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">set</span> field(value: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;
}</code></pre>
<p>Кроме того, начиная с версии <code class="inline-code">v3.7</code>  компилятор начнет использовать данный функционал при генерации <code class="inline-code">.d.ts</code> файлов.</p>

    </section>
<section id="Api-dlya-podderjki-build-i-incremental" name="Api для поддержки --build и --incremental" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Api-dlya-podderjki-build-i-incremental" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Api для поддержки --build и --incremental
        </h2>
        <hr>
        <p>С недавних пор в <em>TypeScript</em>, благодаря добавлению функционала скрывающегося за флагами <code class="inline-code">--build</code> и <code class="inline-code">--incremental</code>, появилась возможность создавать ссылки на другие проекты  и генерировать метаинофрмацию о предыдущих компиляциях, позволяющую включать в последующие компиляции толькоте файлы, которые подверглись изменениям. Данный функционал позволил значительно увеличить скорость разработки, но до этого момента не был доступен для совместного использования с такими сборщиками, как например <code class="inline-code">Gulp</code> или  <code class="inline-code">Webpack</code>. Начиная с версии <code class="inline-code">v3.6</code>, разработчики компилятора <em>TypeScript</em> добавили новое <em>api</em> позволяющее создателям плагинов для сторонних сборщиков использовать данный, увеличивающий скорость компиляции, механизм.</p>

    </section>
<section id="Intellektualnoe-opredelenie-sintaksisa-avto-importa" name="Интеллектуальное определение синтаксиса авто-импорта" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Intellektualnoe-opredelenie-sintaksisa-avto-importa" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Интеллектуальное определение синтаксиса авто-импорта
        </h2>
        <hr>
        <p>Поскольку <em>TypeScript</em> позволяет напрямую работать с <em>JavaScript</em> кодом, который может содержать множество вариантов экспорта конструкций (стандарты <em>ECScript</em>, <em>CommonJS</em>, <em>AMD</em>, <em>SysytemJS</em>), возникают разногласия по поводу определения синтаксиса экспорта в коде <code class="inline-code">.ts</code> при авто-импорте. Начиная с версии <code class="inline-code">v3.6</code>, компилятору была добавлена возможность автоматического определения синтаксиса используемого при авто-импорте для каждого отдельного случая.</p>

    </section>