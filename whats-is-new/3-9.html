<section id="Uluchshenie-vyvoda-tipa-dlya-Promise-all" name="Улучшение вывода типа для Promise.all" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Uluchshenie-vyvoda-tipa-dlya-Promise-all" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Улучшение вывода типа для Promise.all
        </h2>
        <hr>
        <p>В последних версиях <em>TypeScript</em> (начиная с версии <code class="inline-code">3.7</code>) были обновлены декларации для таких методов как <code class="inline-code">Promise.all</code> и <code class="inline-code">Promise.race</code>. Но к сожалению это привело к неожиданным результатам в работе вывода типа, что более всего стало очевидно если в выводе учавствуют <code class="inline-code">null</code> или <code class="inline-code">undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Foodstuff{
    isExpirationDate():<span class="hljs-built_in">boolean</span>;
}
<span class="hljs-keyword">interface</span> Milk <span class="hljs-keyword">extends</span> Foodstuff {
}
<span class="hljs-keyword">interface</span> Coffee <span class="hljs-keyword">extends</span> Foodstuff {
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>(<span class="hljs-params">milkOrder: <span class="hljs-built_in">Promise</span>&#x3C;Milk>, coffeeOrder: <span class="hljs-built_in">Promise</span>&#x3C;Coffee | <span class="hljs-literal">undefined</span>></span>) </span>{
    <span class="hljs-keyword">let</span> [milk, coffee] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([milkOrder, coffeeOrder]);
    
    <span class="hljs-comment">/**
     * [error] Object is possibly 'undefined'.
     * [сейчас] let milk: Milk | undefined
     * [должно] let milk: Milk
     * 
     * [ERROR] Ошибочное поведение!
     */</span>
    milk.isExpirationDate();
    <span class="hljs-comment">/**
     * [error] Object is possibly 'undefined'.
     * [сейчас] let milk: Coffee | undefined
     * 
     * [Ok] Ожидаемое\правильное поведение!
     */</span>
    coffee.isExpirationDate();

}</code></pre>
<p>Поскольку данное поведение ошибочно, начиная с версии <code class="inline-code">3.9</code> оно было исправленно должным образом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// ...</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>(<span class="hljs-params">milkOrder: <span class="hljs-built_in">Promise</span>&#x3C;Milk>, coffeeOrder: <span class="hljs-built_in">Promise</span>&#x3C;Coffee | <span class="hljs-literal">undefined</span>></span>) </span>{
    <span class="hljs-keyword">let</span> [milk, coffee] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([milkOrder, coffeeOrder]);
    
    milk.isExpirationDate(); <span class="hljs-comment">// Ok! let milk: Milk</span>
    coffee.isExpirationDate(); <span class="hljs-comment">// Error! let coffee: Coffee | undefined</span>

}</code></pre>

    </section>
<section id="Sokrashchenie-skorosti-kompilyacii" name="Сокращение скорости компиляции" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sokrashchenie-skorosti-kompilyacii" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Сокращение скорости компиляции
        </h2>
        <hr>
        <p>Работа с такими пакетами как <code class="inline-code">material-ui</code> и <code class="inline-code">styled-components</code>, чья компиляция занимает гораздо больше времени чем хотелось бы, подтолкнула разработчиков языка <code class="inline-code">TypeScript</code> на серию точечных оптимизаций, если быть конкретнее то шести, каждая из которых сократила время компиляции от 5% до 10%. По словам разработчиков время сборки\редактирования <code class="inline-code">material-ui</code> сократилось на 40%. Кроме того, оптимизации затронули механизм изменения путей для импортов\экспортов при изменении импортируемых\экспортируемых файлов.</p>

    </section>
<section id="Kommentarnaya-direktiva-ts-expect-error" name="Комментарная директива @ts-expect-error" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Kommentarnaya-direktiva-ts-expect-error" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Комментарная директива @ts-expect-error
        </h2>
        <hr>
        <p>Поскольку разработка на языке <code class="inline-code">TypeScript</code> неразрывно связанна с <code class="inline-code">JavaScript</code> в некоторых моментах может возникать разногласия.</p>
<p>Представьте ситуацию при которой необходимо покрыть тестами функцию принимающую на вход строковой параметр и кроме того выполняющей в своем теле его валидацию времени выполнения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringAssert</span>(<span class="hljs-params">valid:<span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">asserts</span> <span class="hljs-title">valid</span> </span>{
    <span class="hljs-keyword">if</span>(!valid){
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`...`</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>)</span>{
    isStringAssert(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>); <span class="hljs-comment">// валидация времени выполнения</span>

    <span class="hljs-comment">// некоторый код...</span>
}</code></pre>
<p>Поскольку лучшие практики тестирования предполагают написание таких тестов которые по своей природе не должны пройти, тестировщик пишуший тесты также на <code class="inline-code">TypeScript</code> при попытке протестировать ошибку время выполнения (<code class="inline-code">assert</code>) столкнется с проблемой время компиляции, так как компилятор не позволит скомпилировать код выявив несоответствие типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// файл .ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringAssert</span>(<span class="hljs-params">valid:<span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">asserts</span> <span class="hljs-title">valid</span> </span>{
    <span class="hljs-keyword">if</span>(!valid){
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`...`</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>)</span>{
    isStringAssert(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>); <span class="hljs-comment">// валидация времени выполнения</span>

    <span class="hljs-comment">// некоторый код...</span>
}

<span class="hljs-comment">// ...где-то в .ts.spec</span>

<span class="hljs-comment">/**
 * [error] Argument of type '5' is not assignable to parameter of type 'string'.
 * Компилятор TypeScript не позволяет скомпилировать код имеющий ошибки вызванные
 * несоответствие типов и тем самым препятствует тестированию кода времени выполнения.
 */</span>
action(<span class="hljs-number">5</span>);</code></pre>
<p>Чтобы разрешить сложившуюся ситуацию начиная с текущей версии была введена комемнтарная директива <code class="inline-code">// @ts-expect-error</code>.
Новая комментарная директива затавляет компилятор подовлять сообщение об ошибке в случае её возникновения, но при отсутствии необходимости сама становится её причиной.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @ts-expect-error</span>
action(<span class="hljs-number">5</span>); <span class="hljs-comment">// Ok!</span>
<span class="hljs-comment">// @ts-expect-error</span>
action(<span class="hljs-string">'5'</span>); <span class="hljs-comment">// Error! Unused '@ts-expect-error' directive.</span></code></pre>

    </section>
<section id="Proverka-vyzova-funkcii-v-ternarnom-uslovnom-operatore" name="Проверка вызова функции в тернарном условном операторе" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Proverka-vyzova-funkcii-v-ternarnom-uslovnom-operatore" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Проверка вызова функции в тернарном условном операторе
        </h2>
        <hr>
        <p>В версии <code class="inline-code">3.7</code> была добавлена проверка обязательного вызова функций учавствующих в условном выражении <code class="inline-code">if</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params"></span>): <span class="hljs-title">boolean</span></span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">/**
     * Начиная с версии 3.7
     * 
     * [error] This condition will always return true 
     * since the function is always defined.
     * Did you mean to call it instead?
     */</span>
    <span class="hljs-keyword">if</span>(isValid){
        <span class="hljs-comment">/**
         * По факту этот блок кода быдет
         * выполняться всегда, поскольку
         * в условном выражении участвует
         * ссылка на функцию, а не предполагаемый
         * результат её вызова!
         */</span>
    }
}</code></pre>
<p>Начиная с версии <code class="inline-code">3.9</code> подобное поведение было реализованно и для тернарного условного оператора.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params"></span>): <span class="hljs-title">boolean</span></span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">/**
     * Начиная с версии 3.9
     * 
     * [error] This condition will always return true 
     * since the function is always defined.
     * Did you mean to call it instead?
     */</span>
    <span class="hljs-keyword">return</span> isValid ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>;
}</code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Izmenenie-povedeniya-dlya-operatora-Non-Null-prisovmestnom" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменение поведения для оператора Non-Null присовместном" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Izmenenie-povedeniya-dlya-operatora-Non-Null-prisovmestnom" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменение поведения для оператора Non-Null присовместном
        </h2>
        <hr>
        <p>После того, как начиная с версии <code class="inline-code">3.7</code> был реализован оператор опциональной последовательности (<code class="inline-code">.?</code>), функционал определенный стандартом <em>ESMAScript</em>, многие обратили внимание на нелогичность его поведения при совместном использовании с таким оператором, как <code class="inline-code">Not-Null\Not-Undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = {
    f0?: {
        f1?: <span class="hljs-built_in">any</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p?:T</span>)</span>{
    p?.f0!.f1;
}

f({});</code></pre>
<p>Как известно, оператор опциональной последовательности предпологает предотвращение выполнения цепочки вызовов и поскольку в коде выше в функцию <code class="inline-code">f</code> передается объект лишенный хоть каких-то опциональных признаков типа <code class="inline-code">T</code>, то ошибки при обращении к полю <code class="inline-code">f1</code> через нулевую ссылку ассоциированную с полем <code class="inline-code">f0</code> не произойдет.</p>
<p>То есть предполагается что подобный код после компиляции примет следующий вид -</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>)</span>{
    <span class="hljs-comment">/**
     * Обращение к f1 произойдет только в случае
     * существования параметра p и определения в
     * нем поля f0 ссылающегося на объект.
     */</span>/
    p === <span class="hljs-literal">null</span> || p === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : p.f0.f1;
}</code></pre>
<p>И это логично!</p>
<p>Но до текущей версии подобный код разворачивался таким образом что приводило к ошибке во время выполнения.</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>)</span>{
    <span class="hljs-comment">/**
     * Обращение к f1 произойдет даже в случае
     * если параметр p и\или поле f1 отсутствует,
     * что приведет к ошибке во время выполнения.
     * Кроме того подобное поведение в корне противоречит
     * ожижидаемому разработчиком поведению оператора
     * опциональной последовательности.
     */</span>
     (p === <span class="hljs-literal">null</span> || p === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : p.f0).f1;
}</code></pre>
<p>Исходя из этого начиная с версии <code class="inline-code">3.9</code> поведение оператора <code class="inline-code">Not-Null\Not-Undefined</code> используемого совместно с оператором опциональной цепочки быломизменнено на ожидаемое. В случае необходимости получения поведения предшествующего текущей версии предлагается конкретизировать выражение с помощью фигурных скобок.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = {
    f0?: {
        f1?: <span class="hljs-built_in">any</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p?:T</span>)</span>{
    <span class="hljs-comment">/**
     * Указываем что обращение к полю f1
     * должно произойти независимо от результата
     * выражения в круглых скобках.
     * 
     * После компиляции данный код примет подобный вид -
     * 
     * (p === null || p === void 0 ? void 0 : p.f0).f1;
     */</span>
    (p?.f0)!.f1;
}

f({});</code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Vozniknovenie-oshibki-pri-nalichii-v-stroke-zakryvaushchei-figurnoi-ili-uglovatoi-skobki-v-failah-s-rasshireniem-TSX" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Возникновение ошибки при наличии в строке закрывающей фигурной или угловатой скобки в файлах с расширением TSX" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Vozniknovenie-oshibki-pri-nalichii-v-stroke-zakryvaushchei-figurnoi-ili-uglovatoi-skobki-v-failah-s-rasshireniem-TSX" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Возникновение ошибки при наличии в строке закрывающей фигурной или угловатой скобки в файлах с расширением TSX
        </h2>
        <hr>
        <p>Спецификация <code class="inline-code">JSX</code> не допускает наличие закрывающих фигурных (<code class="inline-code">}</code>) и угловых (<code class="inline-code">></code>) скобок в строках. Поэтому начиная с текущей версии при явном их указании будет возникать ошибка текст которой предложит решение в виде их экранирования или замены на спец-символы допускаемые <code class="inline-code">JSX</code> спецификацией.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> text = [
    <span class="hljs-comment">// Unexpected token. Did you mean `{'}'}` or `&#x26;rbrace;`?</span>
    &#x3C;span>Text <span class="hljs-keyword">with</span> closing curly bracket }.&#x3C;/span>,
    <span class="hljs-comment">// Unexpected token. Did you mean `{'>'}` or `&#x26;gt;`?</span>
    &#x3C;span>Text <span class="hljs-keyword">with</span> closing angle bracket >.&#x3C;/span>,
];</code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Povyshenie-urovnya-proverki-neobyazatelnyh-polei-dlya-tipov-opredelyaushchih-tip-peresechenie" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Повышение уровня проверки необязательных полей для типов определяющих тип пересечение" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Povyshenie-urovnya-proverki-neobyazatelnyh-polei-dlya-tipov-opredelyaushchih-tip-peresechenie" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Повышение уровня проверки необязательных полей для типов определяющих тип пересечение
        </h2>
        <hr>
        <p>До версии <code class="inline-code">3.9</code> такой тип пересечения (<code class="inline-code">Intersection</code>) как <code class="inline-code">A &#x26; B</code> присваивается типу <code class="inline-code">C</code> если <code class="inline-code">A</code> или <code class="inline-code">B</code> присваивается <code class="inline-code">C</code>. При наличии в <code class="inline-code">A</code> или <code class="inline-code">B</code> необязательных членов это может превести к неожиданным последствиям. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> A {
    a: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> B {
    b: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> C {
    a?: <span class="hljs-built_in">boolean</span>;
    b: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> x: A &#x26; B;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> y: C;

<span class="hljs-comment">/**
 * Ok до версии 3.9, поскольку A можно присвоить C
 * и B можно присвоить C.
 */</span>
y = x;</code></pre>
<p>Поэтому начиная с текущей версии поведение измененно таким образом, что пока каждый тип определяющим пересечение является объектным типом, система типов будет рассматривать все члены сразу.</p>
<p>Поэтому в рассматриваемом коде возникнит следующая ошибка -</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// ...код</span>

<span class="hljs-comment">/**
 * Error начиная с версии 3.9 -
 * 
 * Type 'A &#x26; B' is not assignable to type 'C'.
 * Types of property 'a' are incompatible.
 * Type 'number' is not assignable to type 'boolean | undefined'.
 */</span>
y = x;</code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Opredelenie-tipa-peresecheniya-deskriminantnymi-polyami" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Определение типа пересечения дескриминантными полями" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Opredelenie-tipa-peresecheniya-deskriminantnymi-polyami" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Определение типа пересечения дескриминантными полями
        </h2>
        <hr>
        <p>До версии <code class="inline-code">3.9</code> сужение на основе дескиминантных полей определяющих тип пересечение (<code class="inline-code">Intersection</code>) определяло такие поля, как принадлежащие к типу <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">join</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params">a: T, b: U</span>): <span class="hljs-title">T</span> &#x26; <span class="hljs-title">U</span></span>;


<span class="hljs-keyword">interface</span> NameInfo {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">"name"</span>;

    firstName: <span class="hljs-built_in">string</span>;
    lastName: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> AddressInfo {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">"address"</span>;

    country:<span class="hljs-built_in">string</span>;
    city: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> nameInfo: NameInfo;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> addressInfo: AddressInfo;

<span class="hljs-comment">/**
 * let person: NameInfo &#x26; AddressInfo
 */</span>
<span class="hljs-keyword">let</span> person = join(nameInfo, addressInfo);

<span class="hljs-comment">/**
 * Ok, До версии 3.9
 */</span>
person.type; <span class="hljs-comment">// (property) type: never</span></code></pre>
<p>Поскольку на практике потеря информации о типах полей недопустима начиная с текущей версии вывод типов определит как тип <code class="inline-code">never</code> не дескриминантные поля, а сам тип пересечения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// ...код</span>


<span class="hljs-comment">/**
 * let person: never
 */</span>
<span class="hljs-keyword">let</span> person = join(nameInfo, addressInfo);

<span class="hljs-comment">/**
 * Error, Начиная с версии 3.9 -
 * 
 * Property 'type' does not exist on type 'never'.
 */</span>
person.type; <span class="hljs-comment">// (property) type: never</span></code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Parametr-tipa-rasshiryaushchii-tip-any-bolshe-ne-nasleduet-ego-harakteristiki" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Параметр типа расширяющий тип any больше не наследует его характеристики" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Parametr-tipa-rasshiryaushchii-tip-any-bolshe-ne-nasleduet-ego-harakteristiki" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Параметр типа расширяющий тип any больше не наследует его характеристики
        </h2>
        <hr>
        <p>Раньше параметр типа расширяющий тип <code class="inline-code">any</code> наделялся всеми его характеристиками, что при указании его в качестве типа снижало уровень типобезопасности программы. </p>
<pre><code class="hljs language-typescript"></code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-get-set-bolshe-ne-perechislyaemy" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] get\set больше не перечисляемы" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-get-set-bolshe-ne-perechislyaemy" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] get\set больше не перечисляемы
        </h2>
        <hr>
        <p>До версии <code class="inline-code">3.9</code> при генерации кода для аксессоров определенных в теле класса под <code class="inline-code">es5</code> \ <code class="inline-code">es2015</code> поле <code class="inline-code">enumerable</code> устанавливалось в значение <code class="inline-code">true</code>, в то время как спецификация <em>ESMAScript</em> предполагает <code class="inline-code">false</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> T {
    set accessor(value: <span class="hljs-built_in">string</span>){

    }
    get accessor(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"accessor"</span>;
    }
}</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">var</span> T = <span class="hljs-comment">/** @class */</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">T</span>(<span class="hljs-params"></span>) </span>{
    }
    <span class="hljs-built_in">Object</span>.defineProperty(T.prototype, <span class="hljs-string">"accessor"</span>, {
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"accessor"</span>;
        },
        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        },
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// false начиная с версии 3.9, но true для версий ниже</span>
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
    });
    <span class="hljs-keyword">return</span> T;
}());</code></pre>
<p>Начиная с текущей версии расхождение со спецификацией <em>ESMAScript</em> было исправленно.</p>

    </section>
<section id="KRITIChESKOE-IZMENENIE-export-teper-vsegda-vkluchaetsya-v-sborku" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] export * теперь всегда включается в сборку" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-export-teper-vsegda-vkluchaetsya-v-sborku" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] export * теперь всегда включается в сборку
        </h2>
        <hr>
        <p>Раньше реэкспорт вида <code class="inline-code">export * from "path/to/module";</code> не включался в сборку если модуль не экспортировал валидных с точки зрения <em>JavaScript</em> конструкций. Это поведение вставляло палки в колеса такому компилятору как <em>Babel</em> из-за чего было принято решение изменить поведение.</p>
<p>Начиная с текущей версии подобные модули будут включены в конечную сборку.</p>

    </section>