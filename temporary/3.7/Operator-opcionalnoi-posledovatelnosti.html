<p>Начиная с текущей (<code class="inline-code">v3.7</code>) версии, <em>TypeScript</em> реализовал функционал обозначаемый как опертор опциональной последовательности (<em>optional chaining operator</em>) внесенный в спецификацию <em>ECMScript</em> комитетом <em>TC39</em>. Оператор опциональной последовательности обозначается вопросительным знаком после которого следует точка <code class="inline-code">?.</code> и предназначен для безопасного обращения к членам объекта через ссылку которая может иметь значение <code class="inline-code">null</code> или <code class="inline-code">undefined</code>. Этого функционала очень давно все ждали, поэтому не будем медлить и немедля приступим к его рассмотрению на простом пример.</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">/**
 * Вложенные друг в друга типы
 * (как матрешки) объявленные
 * семантически в обратном порядке.
 */</span>
<span class="hljs-keyword">interface</span> D {n:<span class="hljs-built_in">number</span>}
<span class="hljs-keyword">interface</span> C {d:D;}
<span class="hljs-keyword">interface</span> B {c:C;}
<span class="hljs-keyword">interface</span> A {b:B;}

<span class="hljs-comment">/**
 * Представьте сценарий по которому
 * ответ от сервера может представлять
 * из себя json соответствующий как типу
 * A так и объекту у которого отсутствуют
 * какие-либо принаки {}.
 */</span>


<span class="hljs-keyword">let</span> json = <span class="hljs-string">"{}"</span>;
<span class="hljs-keyword">let</span> a: A = <span class="hljs-built_in">JSON</span>.parse(json);

<span class="hljs-comment">/**
 * При поппытке обращения к несуществующим
 * полям объекта возникнет соответствующее
 * исключение.
 */</span>
<span class="hljs-keyword">let</span> b = a.b; <span class="hljs-comment">// Ok! поскольку отсутствуют операции над значением undefined</span>
<span class="hljs-keyword">let</span> c = a.b.c; <span class="hljs-comment">// Runtime Error! </span>
<span class="hljs-keyword">let</span> d = a.b.c.d; <span class="hljs-comment">// Runtime Error!</span>
<span class="hljs-keyword">let</span> n = a.b.c.d.n; <span class="hljs-comment">// Runtime Error!</span>

<span class="hljs-comment">/**
 * Подобное можно избежать произведя
 * проверку на существование ссылок.
 */</span>

<span class="hljs-keyword">if</span> (a.b &#x26;&#x26; a.b.c &#x26;&#x26; a.b.c.d) {
    <span class="hljs-comment">/**
     * Здесь можно обратится к полю n,
     * которое также может быть не определенно
     * что при попытке вызвать методы реализованные
     * в типе Number также приведет к исключению.
     * Чтобы этого избежать потребуется дополнительная
     * проверка. Но стоит сразу заметить, что обычной
     * проверки на существование поля a.b.c.d.n может
     * быть недостаточно, поскольку значение поля n може
     * быть 0, что при преобразовании типов преобразуется
     * в false. Поэтому помимо наличие самого поля необходимо
     * также проверить его значение. 
     */</span>

    <span class="hljs-keyword">if</span> (a.b.c.d.n &#x26;&#x26; !<span class="hljs-built_in">Number</span>.isNaN(a.b.c.d.n)) {
        <span class="hljs-keyword">let</span> r = a.b.c.d.n.toFixed(<span class="hljs-number">2</span>);
    }
}</code></pre>
<p>Сложно представить разработчика, который на практике не сталкивался с чем-то подобным и не испытывал желания избавится от написания утомительных проверок. И наконец свершилось! Разработчики <em>TypeScript</em> реализовали оператор опциональной последовательности известный также как <em>элвис-оператор</em>.</p>
<p>Элвис-оператор позволяет избавится от написания утомительных условных инструкций требуя от разработчика своего указания лишь в потенциально опасных местах. Оценить его мощь будет проще переписав предыдущий пример.</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">interface</span> D {n:<span class="hljs-built_in">number</span>}
<span class="hljs-keyword">interface</span> C {d:D;}
<span class="hljs-keyword">interface</span> B {c:C;}
<span class="hljs-keyword">interface</span> A {b:B;}


<span class="hljs-keyword">let</span> json = <span class="hljs-string">"{}"</span>;
<span class="hljs-keyword">let</span> a: A = <span class="hljs-built_in">JSON</span>.parse(json);

<span class="hljs-comment">/**
 * Ещё раз стоит обратить внимание на то,
 * что указание элвис-оператора требуется
 * во всех потенциально опасных местах, поскольку
 * наличие одной ссылки не гарантирует наличие остальных
 * во всей цепочки выовов.
 * 
 * 0) поскольку отсутствуют операции над значением undefined
 * 1) если ссылка на "b" существует вернуть значение ассоциированное с полем "c"
 * 2) если ссылки на "b" и "c" существуют вернуть значение ассоциированное с полем "d"
 * 3) если ссылки на "b" и "c" и "d" существуют вернуть значение ассоциированное с полем "n"
 * 4) если ссылки на "b" и "c" и "d" и "n" существуют вернуть значение возвращенное методом "toFixed"
 */</span>
<span class="hljs-keyword">let</span> b = a.b; <span class="hljs-comment">// Ok! (0)</span>
<span class="hljs-keyword">let</span> c = a.b?.c; <span class="hljs-comment">// Ok! (1)</span>
<span class="hljs-keyword">let</span> d = a.b?.c?.d; <span class="hljs-comment">// Ok! (2)</span>
<span class="hljs-keyword">let</span> n = a.b?.c?.d?.n; <span class="hljs-comment">// Ok! (3)</span>
<span class="hljs-keyword">let</span> r = a.b?.c?.d?.n?.toFixed(<span class="hljs-number">2</span>); <span class="hljs-comment">// Ok! (4)</span></code></pre>
<p>В случаях, когда элвис-оператор обнаруживает ссылку со значением <code class="inline-code">null</code> или <code class="inline-code">undefined</code>, результатом возвращенным из выражения становится <code class="inline-code">undefined</code>. </p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">interface</span> IT {
    a: {
        n: <span class="hljs-built_in">number</span>;
    }
}


<span class="hljs-keyword">let</span> o0: IT = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"{}"</span>);
<span class="hljs-keyword">let</span> o1: IT = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"{a: null}"</span>);


<span class="hljs-comment">/**
 * Несмотря на то, что во втором случае
 * значение поля "a" равно null, n1,
 * также как и n0 будет иметь значение
 * и следовательно тип undefined.
 */</span>
<span class="hljs-keyword">let</span> n0 = o0?.a.n; <span class="hljs-comment">// n0 имеет значение undefined;</span>
<span class="hljs-keyword">let</span> n1 = o0?.a.n; <span class="hljs-comment">// n1 имеет значение;</span></code></pre>
<p>кроме того важной особенностью при использовании элвис-оператора является тот факт, что вывод типов не определяет тип как объединение включающий тип <code class="inline-code">undefined</code>, что в свою очередь избавляет от дополнительных проверок.</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">interface</span> IT {
    a: {
        n: <span class="hljs-built_in">number</span>;
    }
}


<span class="hljs-keyword">let</span> o0: IT = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"{}"</span>);
<span class="hljs-keyword">let</span> o1: IT = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"{a: null}"</span>);

<span class="hljs-keyword">let</span> n0 = o0?.a.n; <span class="hljs-comment">// let n0: number; а не number | undefined</span>
<span class="hljs-keyword">let</span> n1 = o0?.a.n; <span class="hljs-comment">// let n1: number; а не number | undefined</span></code></pre>
<p>Кроме того элвис-опрератор также может быть применен при вызове методов, а в случае отстутствия ссылок на них результатом вызова также будет <code class="inline-code">undefined</code>.</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">interface</span> IT {
    f: <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>) => <span class="hljs-built_in">number</span></span>) | <span class="hljs-params">null</span>;
}
<span class="hljs-params">class</span> <span class="hljs-params">T</span> <span class="hljs-params">implements</span> <span class="hljs-params">IT</span> {
    /**
     * Вводим вывод типов в амешательство путем
     * присваивания функции в положительном случае
     * и <span class="hljs-params">null</span> в отрицательном. 
     */
    <span class="hljs-params">f</span> = <span class="hljs-params">Math</span>.<span class="hljs-params">round</span>(<span class="hljs-params"><span class="hljs-built_in">Math</span>.random(<span class="hljs-params"></span>) * 1</span>) === 1 ? <span class="hljs-params">()</span> =></span> <span class="hljs-number">10</span> : <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> T();
<span class="hljs-keyword">let</span> n = t.f?.();<span class="hljs-comment">// результатом выражения вызова метода является undefined</span></code></pre>
<p>Таким образом выход версии <code class="inline-code">v3.7</code> дал разработчикам на языке <em>TypeScript</em> инструмент предотвращающий исключения связанные с обращением к отсутствующим ссылкам или ссылкам имеющим значение <code class="inline-code">null</code>, который кроме всего не чувствителен к значениям преобразование которых к типу Boolean принимает ложную форму (<code class="inline-code">0</code>, <code class="inline-code">NaN</code>, <code class="inline-code">false</code>), что в свою очередь ознаминовало начало эпохи в которой нет места конструкциям выполняющих утомительные и проверки наличия ссылок. </p>
