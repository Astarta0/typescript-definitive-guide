<p>Развитие стандарта <em>EsmaScript</em> относительно объявлений полей в теле класса привело к пересмотрению подхода генерации <em>JavaScript</em> кода. Устаревший подход предполагал что поля инициализированные при объявлении в теле класса после генерации помещались в конструктор, а не инициализированные исключались вовсе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до компиляции (.ts)</span>

<span class="hljs-keyword">class</span> T {
    f0: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// поле инициализированное при объявлении</span>
    f1: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// не инициализированное объявление поля</span>
}

<span class="hljs-comment">// после компиляции (.js)</span>

<span class="hljs-keyword">class</span> T {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">this</span>.f0 = <span class="hljs-number">5</span>;
        
        <span class="hljs-comment">// отсутствует не инициализированное поле</span>
    }
}</code></pre>
<p>Новый подход предполагает необходимость обязательного включения не инициализированных полей в сгенерированный исходный <em>JavaScript</em> код, а также отказа от <em>синтаксического сахара</em> в пользу применения <code class="inline-code">Object.defineProperty</code>. Стало быть код выше будет представлен следуюущим образом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// после компиляции (.js)</span>

<span class="hljs-keyword">class</span> T {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"f0"</span>, {
            enumerable: <span class="hljs-literal">true</span>,
            configurable: <span class="hljs-literal">true</span>,
            writable: <span class="hljs-literal">true</span>,
            value: <span class="hljs-number">0</span>
        }); <span class="hljs-comment">// поле инициализированное при объявлении</span>
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"f1"</span>, {
            enumerable: <span class="hljs-literal">true</span>,
            configurable: <span class="hljs-literal">true</span>,
            writable: <span class="hljs-literal">true</span>,
            value: <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>
        }); <span class="hljs-comment">// включено не инициализированное объявление поля</span>
    }
}</code></pre>
<p>Но новое поведение, при некоторых сценариях вовлеченных в механизм наследования, ломает устаревшее. Расхождение поведения происходит при объявлении в наследнике поля чей идентификатор совпадает с идентификатором аксессоров определенных в классе-предке.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до компиляции (.ts)</span>

<span class="hljs-keyword">class</span> SuperClass {
    <span class="hljs-keyword">set</span> prop(value: <span class="hljs-built_in">number</span>){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setter'</span>);
    }
    <span class="hljs-keyword">get</span> prop(): <span class="hljs-built_in">number</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'getter'</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}

<span class="hljs-keyword">class</span> SubClass <span class="hljs-keyword">extends</span> SuperClass {
    prop: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>;
}

<span class="hljs-keyword">let</span> subClass = <span class="hljs-keyword">new</span> SubClass();
<span class="hljs-keyword">let</span> prop = subClass.prop;</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/**
 * УСТАРЕВШЕЕ ПОВЕДЕНИЕ
 */</span>

<span class="hljs-comment">// после компиляции (.js)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>{
    <span class="hljs-keyword">set</span> prop(value) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setter'</span>);
    }
    <span class="hljs-keyword">get</span> prop() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'getter'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>(...arguments);
        <span class="hljs-keyword">this</span>.prop = <span class="hljs-number">5</span>; <span class="hljs-comment">// [0] установка значения сеттеру определенному в суперклассе</span>
    }
}
<span class="hljs-keyword">let</span> subClass = <span class="hljs-keyword">new</span> SubClass();
<span class="hljs-keyword">let</span> prop = subClass.prop; <span class="hljs-comment">// [1]</span>

<span class="hljs-comment">/**
 * Вывод в консоль - 
 * [0] > setter
 * [1] > getter
 */</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/**
 * НОВОЕ ПОВЕДЕНИЕ
 */</span>

<span class="hljs-comment">// после компиляции (.js)</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>{
    <span class="hljs-keyword">set</span> prop(value) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setter'</span>);
    }
    <span class="hljs-keyword">get</span> prop() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'getter'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>(...arguments);
        <span class="hljs-comment">/**
         * Происходит ПЕРЕОПРЕДЕЛЕНИЕ свойств
         * определенных в суперклассе. При дальнейшем
         * обращении к prop через ссылку экземпляра
         * SubClass вызовы аксессоров производится
         * не будут.
         */</span>
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"prop"</span>, {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>
        });
    }
}
<span class="hljs-keyword">let</span> subClass = <span class="hljs-keyword">new</span> SubClass();
<span class="hljs-keyword">let</span> prop = subClass.prop;</code></pre>
<p>Во избежание проблемы продемонстрированной выше новое поведение предполагае отказ от подобных действий непосредственно в теле класса и реализацией их в любом другом месте, как например конструктор или тело метода.</p>
<p>Прежний код мог бы быть переписан следующим образом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// .ts</span>

<span class="hljs-comment">// Плохо!</span>
<span class="hljs-keyword">class</span> SubClass <span class="hljs-keyword">extends</span> SuperClass {
    prop: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>;
}

<span class="hljs-comment">// Хорошо.</span>
<span class="hljs-keyword">class</span> SubClass <span class="hljs-keyword">extends</span> SuperClass {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">super</span>();

        <span class="hljs-keyword">this</span>.prop = <span class="hljs-number">5</span>;
    }
}

<span class="hljs-comment">// Хорошо.</span>
<span class="hljs-keyword">class</span> SubClass <span class="hljs-keyword">extends</span> SuperClass {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">super</span>();

        <span class="hljs-keyword">this</span>.init();
    }

    init(){
        <span class="hljs-keyword">this</span>.prop = <span class="hljs-number">5</span>;
    }
}</code></pre>
<p>Кроме того специализация свойств также не будет работать.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * НОВОЕ ПОВЕДЕНИЕ
 */</span>

<span class="hljs-comment">// до компиляции (.ts)</span>

<span class="hljs-keyword">interface</span> IAnimal { <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">interface</span> IBird <span class="hljs-keyword">extends</span> IAnimal { isFly:<span class="hljs-built_in">boolean</span>; }

<span class="hljs-keyword">class</span> AnimalHouse {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> resident: IAnimal</span>){}
}
<span class="hljs-keyword">class</span> BirdHouse <span class="hljs-keyword">extends</span> AnimalHouse {
    resident: IBird; <span class="hljs-comment">// специализация свойства</span>
    <span class="hljs-comment">/**
     * Данный работать не будет, поскольку
     * неинициализированное поле resident
     * ОБЯЗАТЕЛЬНО БУДЕТ ВКЛЮЧЕНО в определение
     * класса, а его объявление, которое обязательно
     * будет выполнять после вызова super(bird) переопределит
     * переданное в родительский класс значение на undefined.
     */</span>

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">bird: IBird</span>){
        <span class="hljs-keyword">super</span>(bird);
    }
}</code></pre>
<p>Для решения этой проблемы в синтаксис <em>TypeScript</em> было добавлено ключевое слово <code class="inline-code">declare</code> указывающее компилятору о необходимости учесть специализированное свойство.  </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * НОВОЕ ПОВЕДЕНИЕ
 */</span>

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">class</span> BirdHouse <span class="hljs-keyword">extends</span> AnimalHouse {
    <span class="hljs-keyword">declare</span> resident: IBird; <span class="hljs-comment">// специализация свойства</span>

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">bird: IBird</span>){
        <span class="hljs-keyword">super</span>(bird);
    }
}</code></pre>
<p>Стоит упомянуть, что в случаи со специализированными свойствами флаг компилятора <code class="inline-code">strictPropertyInitialization</code> установленный в значение <code class="inline-code">false</code>, точно также как и модификатор <code class="inline-code">!</code> (<em>definite assignment assertion</em>) никакого влияния не оказывают.</p>
<p>По причине того, что новое поведение столь сильно изменило привычное направление, доступ к нему (скорее всего пока) сокрыт за новым, рекомендуемым разработчиками <em>TypeScript</em>, флагом <code class="inline-code">useDefineForClassFields</code>. Проще всего поведение активируемое данным флагом воспринимать как запрещающее при наследовании переопределение аксессоров полями и наоборот.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A{
    f = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A {
    f = <span class="hljs-number">1</span>; <span class="hljs-comment">// Ok</span>
}
<span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> A {
    <span class="hljs-comment">/**
     * [!] - Ok при неактивном флаге useDefineForClassFields
     *       Error при активном флаге useDefineForClassFields
     */</span>
    <span class="hljs-keyword">set</span> f(value: <span class="hljs-built_in">number</span>){} <span class="hljs-comment">// !</span>
    <span class="hljs-keyword">get</span> f(): <span class="hljs-built_in">number</span> {<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;} <span class="hljs-comment">// !</span>
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">set</span> f(value: <span class="hljs-built_in">number</span>) {}
    <span class="hljs-keyword">get</span> f(): <span class="hljs-built_in">number</span> {<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}
}
<span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A {
    <span class="hljs-keyword">set</span> f(value: <span class="hljs-built_in">number</span>){} <span class="hljs-comment">// Ok</span>
    <span class="hljs-keyword">get</span> f(): <span class="hljs-built_in">number</span> {<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;} <span class="hljs-comment">// Ok</span>
} 
<span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> A {
    <span class="hljs-comment">/**
     * [!] - Ok при неактивном флаге useDefineForClassFields
     *       Error при активном флаге useDefineForClassFields
     */</span>
    f: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// !</span>
}</code></pre>
