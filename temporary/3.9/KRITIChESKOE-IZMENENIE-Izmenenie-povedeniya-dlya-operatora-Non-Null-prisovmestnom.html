<p>После того, как начиная с версии <code class="inline-code">3.7</code> был реализован оператор опциональной последовательности (<code class="inline-code">.?</code>), функционал определенный стандартом <em>ESMAScript</em>, многие обратили внимание на нелогичность его поведения при совместном использовании с таким оператором, как <code class="inline-code">Not-Null\Not-Undefined</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = {
    f0?: {
        f1?: <span class="hljs-built_in">any</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p?:T</span>)</span>{
    p?.f0!.f1;
}

f({});</code></pre>
<p>Как известно, оператор опциональной последовательности предпологает предотвращение выполнения цепочки вызовов и поскольку в коде выше в функцию <code class="inline-code">f</code> передается объект лишенный хоть каких-то опциональных признаков типа <code class="inline-code">T</code>, то ошибки при обращении к полю <code class="inline-code">f1</code> через нулевую ссылку ассоциированную с полем <code class="inline-code">f0</code> не произойдет.</p>
<p>То есть предполагается что подобный код после компиляции примет следующий вид -</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>)</span>{
    <span class="hljs-comment">/**
     * Обращение к f1 произойдет только в случае
     * существования параметра p и определения в
     * нем поля f0 ссылающегося на объект.
     */</span>/
    p === <span class="hljs-literal">null</span> || p === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : p.f0.f1;
}</code></pre>
<p>И это логично!</p>
<p>Но до текущей версии подобный код разворачивался таким образом что приводило к ошибке во время выполнения.</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>)</span>{
    <span class="hljs-comment">/**
     * Обращение к f1 произойдет даже в случае
     * если параметр p и\или поле f1 отсутствует,
     * что приведет к ошибке во время выполнения.
     * Кроме того подобное поведение в корне противоречит
     * ожижидаемому разработчиком поведению оператора
     * опциональной последовательности.
     */</span>
     (p === <span class="hljs-literal">null</span> || p === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : p.f0).f1;
}</code></pre>
<p>Исходя из этого начиная с версии <code class="inline-code">3.9</code> поведение оператора <code class="inline-code">Not-Null\Not-Undefined</code> используемого совместно с оператором опциональной цепочки быломизменнено на ожидаемое. В случае необходимости получения поведения предшествующего текущей версии предлагается конкретизировать выражение с помощью фигурных скобок.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = {
    f0?: {
        f1?: <span class="hljs-built_in">any</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p?:T</span>)</span>{
    <span class="hljs-comment">/**
     * Указываем что обращение к полю f1
     * должно произойти независимо от результата
     * выражения в круглых скобках.
     * 
     * После компиляции данный код примет подобный вид -
     * 
     * (p === null || p === void 0 ? void 0 : p.f0).f1;
     */</span>
    (p?.f0)!.f1;
}

f({});</code></pre>
