<p>В <em>TypeScript</em> есть механизм называемый <em>проверкой избыточности свойств</em> (<em>excess property checking</em>), который призван выявлять опечатки в литералах объекта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> RectCssStyle = {
    width: <span class="hljs-built_in">string</span>;
    height: <span class="hljs-built_in">string</span>;

    color?: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">let</span> graphics: RectCssStyle = {
    width: <span class="hljs-string">'24px'</span>,
    height: <span class="hljs-string">'24px'</span>,

    colour: <span class="hljs-string">'red'</span>, <span class="hljs-comment">// Error</span>
}</code></pre>
<p>С этим механизмом связанно два неоднозначных момента. Первый момент заключается в том, что в <em>TypeScript</em>, в некоторых случаях, избыточность допускается. Один из таких случчаев является присвоение идентификатору, ассоциированного с типом Union, значения принадлежащего одновеременно ко всем типам определеляющих это объединение. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до версии v3.5</span>

<span class="hljs-keyword">type</span> CoordXY = {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> CoordZ = {
    z: <span class="hljs-built_in">number</span>;
};


<span class="hljs-comment">/**
 * По логике, в данном объекте, либо поля xy либо поле z являются излишними,
 * так как тип Union одновременно представляет лишь один определяющий
 * его тип данных
 */</span>
<span class="hljs-keyword">const</span> coords: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,

    z: <span class="hljs-number">0</span>
};</code></pre>
<p>Второй неоднозначный момент сокрыт в реализации описанного выше поведения, которая даже не предусматривает проверку типов для полей являющихся излишними.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до версии v3.5</span>

<span class="hljs-keyword">type</span> CoordXY = {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> CoordZ = {
    z: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">// вывод типов считает что значение принадлежит к типу CoordXY</span>
<span class="hljs-keyword">const</span> coordsFirst: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,
    z: <span class="hljs-string">''</span> <span class="hljs-comment">// Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает</span>
};

<span class="hljs-comment">// вывод типов считает что значение принадлежит к типу CoordZ</span>
<span class="hljs-keyword">const</span> coordsSecond: CoordXY | CoordZ = {
    x: <span class="hljs-string">''</span>, <span class="hljs-comment">// Ok...</span>
    y: <span class="hljs-string">''</span>, <span class="hljs-comment">// Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает</span>
    z: <span class="hljs-number">0</span> 
};</code></pre>
<p>Это поведение кажется нелогичным, поэтому Начиная с версии <em>TypeScript</em> <code class="inline-code">v3.5</code> частично было изменено. Теперь при проверке литералов объекта выполняется проверка типов, что устроняет второй неоднозначным случай.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// начиная с v3.5</span>

<span class="hljs-keyword">type</span> CoordXY = {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> CoordZ = {
    z: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> coordsFirst: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,
    z: <span class="hljs-string">''</span>, <span class="hljs-comment">// Error</span>
};

<span class="hljs-keyword">const</span> coordsSecond: CoordXY | CoordZ = {
    x: <span class="hljs-string">''</span>, <span class="hljs-comment">// Error</span>
    y: <span class="hljs-string">''</span>, <span class="hljs-comment">// Error</span>
    z: <span class="hljs-number">0</span>,
};</code></pre>
<p>Тем не менее, нужно помнить, что первый случай, который также быд обозначен как не совсем очевидный, остался.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// ... </span>


<span class="hljs-keyword">const</span> coords: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,
    z: <span class="hljs-number">0</span>,
}; <span class="hljs-comment">// Ok</span></code></pre>
