<p>Механизм уточнения импорта и экспорта (<code class="inline-code">import\export</code>) выступает в качестве указаний компилятору что данную конструкцию следует воспринимать исключительно как тип. Форма уточняющего импорта и экспорта включает в себя ключевое слово <code class="inline-code">type</code> идущее следом за ключевым словом <code class="inline-code">import</code> либо <code class="inline-code">export</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {Type} <span class="hljs-keyword">from</span> <span class="hljs-string">"./type"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {Type};</code></pre>
<p>Уточнению могут подвергаться только конструкции расцениваемые исключительно как типы (<code class="inline-code">interface</code>, <code class="inline-code">type alias</code> и <code class="inline-code">class</code>). </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IInterfaceType{}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AliasType = {};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {ClassType, IInterfaceType, AliasType} <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {ClassType, IInterfaceType, AliasType};</code></pre>
<p>Значения к которым можно отнести как экземпляры объектов, так и функции (<code class="inline-code">function expression</code> и <code class="inline-code">function declaration</code>) уточнятся, как в отдельности так и в одной форме с типами, не могут.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IInterfaceType{}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AliasType = {};


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> o = {};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fe = <span class="hljs-function"><span class="hljs-params">()</span>=></span>{};
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fd</span>(<span class="hljs-params"></span>)</span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">// import type {o, fe, fd} from "./types"; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-comment">// import type {o, fe, fd, ClassType, IInterfaceType, AliasType} from "./types"; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-keyword">import</span> {o, fe, fd} <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>; <span class="hljs-comment">// Ok!</span>


<span class="hljs-comment">// export type {o, fe, fd}; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-comment">// export type {o, fe, fd, ClassType, IInterfaceType, AliasType} from "./types"; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-keyword">export</span> {o, fe, fd}; <span class="hljs-comment">// Ok!</span></code></pre>
<p>Кроме того уточненая форма импорта и экспорта не может одновременно содержать импорт\экспорт поумолчанию и не поумолчанию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> DefaultExportType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ExportType {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 * Error!
 * All imports in import declaration are unused.ts(6192)
 * A type-only import can specify a default import or named bindings, but not both.ts(1363)
 */</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> DefaultType, {ExportType} <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;</code></pre>
<p>Также не будет лишним оговорить, что классы экспортированные как уточненные само собой разумеется не могут участвовать в механизме наследования.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file Base.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Base {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {Base} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Base"</span>;

<span class="hljs-keyword">class</span> Derivied <span class="hljs-keyword">extends</span> Base{}; <span class="hljs-comment">// 'Base' only refers to a type, but is being used as a value here.ts(2693)</span></code></pre>
<p>В дополнение механизму уточнения формы импорта\экспорта был добавлен флаг <code class="inline-code">--importsNotUsedAsValues</code> ожидаемый одно из трех значений. Но прежде чем познакомится с каждым предлагаю поглубже погрузится в природу возникновения необходимости в данном механизме.</p>
<p>Большинство разработчиков используя в повседневной работе механизм импорта\экспорта даже не подозревают что с ним связанно немало различных трудностей, которые возникают из-за механизмов призванных оптимизировать код. Но для начала рассмотрим несколько простых вводных примеров.</p>
<p>Представьте ситуацию при которой один модуль импортирует необходимый ему тип представленный такой конструкцией как <code class="inline-code">interface</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file IPerson.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPerson {
    name: <span class="hljs-built_in">string</span>;
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> {IPerson} <span class="hljs-keyword">from</span> <span class="hljs-string">"./IPerson"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:IPerson</span>)</span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Поскольку интерфейс является конструкцией присущей исключительно <em>TypeScript</em> то не удивительно что после компиляции от неё не останется и следа.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>)</span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Теперь представьте что один модуль импортирует конструкцию представленную классом, который задействован в логике уже знакомой нам функции <code class="inline-code">action()</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file IPerson.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPerson {
    name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Person {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name:<span class="hljs-built_in">string</span></span>){}

    toString(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">`[person <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>]`</span>;
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> {IPerson} <span class="hljs-keyword">from</span> <span class="hljs-string">"./IPerson"</span>;
<span class="hljs-keyword">import</span> {Person} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Person"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:IPerson</span>)</span>{
    <span class="hljs-keyword">new</span> Person(person);
}</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-keyword">import</span> {Person} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Person"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>)</span>{
    <span class="hljs-keyword">new</span> Person(person);
}</code></pre>
<p>В этом случае класс <code class="inline-code">Person</code> был включон в скомпилированный файл поскольку необходим для правильного выполнения программы.</p>
<p>А теперь представьте ситуацию когда класс <code class="inline-code">Person</code> задействован в том же модуле <code class="inline-code">action.ts</code>, но исключительно в качестве типа. Другими словами он не задействован в логике работы модуля.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file Person.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Person {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name:<span class="hljs-built_in">string</span></span>){}

    toString(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">`[person <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>]`</span>;
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> {Person} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Person"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:Person</span>)</span>{
    <span class="hljs-comment">//...</span>
}</code></pre>
<p>Подумайте, что должна включать в себя итоговая сборка? Если вы выбрали вариант идентичный первому то вы совершенно правы! Поскольку класс <code class="inline-code">Person</code> используется в качестве типа то нет смысла включать его в результатирующий файл.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>)</span>{
    <span class="hljs-comment">//...</span>
}</code></pre>
<p>Подобное поведение кажется логичным и возможно благодаря механизму называемому <em>import elision</em>. Этот механизм определяет что конструкции которые теоретически могут быть включены в скомпилированный модуль требуются ему исключительно в качестве типа. И как уже можно было догадаться именно с этим механизмом и связанны моменты мешающие оптимизизаци кода. Тут-то и вступает в дело механизм уточнения формы импорта\экспорта.</p>
<p>Механизм уточнения способен разрешить возникающие перед <em>import-elision</em> трудности при ре-экспорте модулей предотвращению которых способствует установленный в значение <code class="inline-code">true</code> флаг <code class="inline-code">--isolatedModules</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IActionParams{}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">params:IActionParams</span>)</span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file re-export.ts</span>

<span class="hljs-keyword">import</span> {IActionParams, action} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-comment">/**
 * [Error! ts &#x3C;3.8] > Cannot re-export a type when the '--isolatedModules' flag is provided.ts(1205)
 * 
 * [Error! ts >=3.8] > Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'.ts(1205)
 */</span>
<span class="hljs-keyword">export</span> {IActionParams, action};


<span class="hljs-comment">/**
 * 
 * Поскольку компиляторы как TypeScript так и Babel
 * в контексте файла неспособны определить является
 * ли конструкция IActionParams допустимой для JavaScript
 * существует вероятность возникновения ошибки. Простыми
 * словами механизмы обоих компиляторов не знаю нужно ли
 * удалять следы связанные с IActionParams из скомпилированного
 * .js кода или нет. Именно поэтому был добавлен флаг 
 * --isolatedModules который предупреждает о опасной ситуации.
 */</span>

 </code></pre>
<p>Рассмотренный выше случай можно разрешить с помощью явного уточнения формы импорта\экспорта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file re-export.ts</span>

<span class="hljs-keyword">import</span> {IActionParams, action} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-comment">/**
 * Явно указываем что IActionParams это тип.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {IActionParams};
<span class="hljs-keyword">export</span> {action};</code></pre>
<p>Специально введенный и ранее упомянутый флаг <code class="inline-code">--importsNotUsedAsValues</code>, как уже было сказанно, ожидает одно из трех возможных на данный момент значений - <code class="inline-code">remove</code>, <code class="inline-code">preserve</code> или <code class="inline-code">error</code>.</p>
<p>Значение <code class="inline-code">remove</code> активирует или другими словами оставляет поведение реализуемое до версии <code class="inline-code">3.8</code>.
Значения <code class="inline-code">preserve</code> способно разрешить проблему возникающую при экспорте так называемых сайд-эффектов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-with-side-effects.ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementVisitCounterLocalStorage</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// увеличиваем счетчик посещаемости в localStorage</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithSideEffects{};

incrementVisitCounterLocalStorage(); <span class="hljs-comment">// ожидается что вызов произойдет в момент подключения модуля</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-keyword">let</span> data:IDataFromModuleWithSideEffects = {};

<span class="hljs-comment">/**
 * Несмотря на то что модуль module.ts
 * задействован в коде, его содержимое
 * не будет включено в скомпилированную
 * программу, поскольку компилятор исключает
 * импорты конструкций не учавствующих в её логике.
 * Таким образом функция incrementVisitCounterLocalStorage()
 * никогда не будет вызвана, а значит программа не будет
 * работать корректно! 
 */</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">let</span> data = {};

<span class="hljs-comment">/**
 * В итоге программе ничего не
 * известно о модуле module-with-side-effects.ts
 */</span></code></pre>
<p>Решение из ситуации описанной выше заключается в повторном указании импорта всего модуля. Но не всем такое решение кажется очевидным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-with-side-effects"</span>; <span class="hljs-comment">// импорт всего модуля</span>

<span class="hljs-keyword">let</span> data:IDataFromModuleWithSideEffects = {};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-with-side-effects.js"</span>;

<span class="hljs-keyword">let</span> data = {};

<span class="hljs-comment">/**
 * Теперь программа выполнится так как и ожидалось.
 * То есть модуль module-with-side-effects.ts включен
 * в её состав.
 */</span></code></pre>
<p>Поэтому прежде всего начиная с версии <code class="inline-code">3.8</code> сама <code class="inline-code">ide</code> укажит на возможность уточнения импорта исключительно типов, что в свою очередь должно подтолкнуть на размышление о удалении импорта при компиляции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>; <span class="hljs-comment">//This import may be converted to a type-only import.ts(1372)</span></code></pre>
<p>Кроме того флаг <code class="inline-code">preserve</code> в отсутствие уточнения поможет избавится от повторного указания импорта. Простыми словами значение <code class="inline-code">preserve</code> указывает компилятору импортировать все модули полностью.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-with-side-effects.ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementVisitCounterLocalStorage</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// увеличиваем счетчик посещаемости в localStorage</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithSideEffects{};

incrementVisitCounterLocalStorage(); </code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-without-side-effects.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithoutSideEffects{};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>


<span class="hljs-comment">// Без уточнения</span>
<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-without-side-effects"</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-without-side-effects"</span>;

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects = {};

<span class="hljs-comment">/**
 * 
 * Несмотря на то что импортировались
 * исключительно конструкции-типы, модули
 * были импортированны полностью.
 */</span></code></pre>
<p>В случае уточнения поведение при компиляции останется прежднем. То есть в импорты в скомпилированный файл включены не будут.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>


<span class="hljs-comment">// С уточнением</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-without-side-effects"</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects = {};

<span class="hljs-comment">/**
 * 
 * Импорты отсутствуют.
 */</span></code></pre>
<p>Если же флагу <code class="inline-code">--importsNotUsedAsValues</code> задано значение <code class="inline-code">error</code>, то при импортировании типов без явного уточнения будет считаться ошибочным поведением.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 * 
 * [0][1] Error > This import is never used as a value and must use 'import type' because the 'importsNotUsedAsValues' is set to 'error'.ts(1371)
 */</span>

<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-without-side-effects"</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};</code></pre>
<p>Скомпилированный код выше после устранения ошибок, то есть после уточнения, включать в себя импорты не будет.</p>
<p>В заключение стоит заметить что в теории уточнение такой конструкции как класс способно ускорить компиляцию посколько избавляет компилятор от ненужных проверок на вовлечении его в логику работы модуля. Ну и кроме того, уточнения формы импорта\экспорта, это ещё один способ сделать код более информативным.</p>
<p>Также стоит обратить особое внимание, что на данный момент <em>конструкции-значения<strong> уточненные как </strong>конструкции-типы</em> не могут участвовать как в механизме наследования при объявлении декларации (<code class="inline-code">declare</code>), так и при запросе типа (<code class="inline-code">typeof</code>). Но эти недоработки планируется устранить в следующих версиях.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file ClassType.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {ClassType} <span class="hljs-keyword">from</span> <span class="hljs-string">"./ClassType"</span>;

<span class="hljs-comment">/**
 * [0][1] Error! > 'ClassType' only refers to a type, but is being used as a value here.ts(2693)
 */</span>

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> T <span class="hljs-keyword">extends</span> ClassType{} <span class="hljs-comment">// [0]</span>

<span class="hljs-keyword">let</span> prop: <span class="hljs-keyword">typeof</span> ClassType; <span class="hljs-comment">// [1]</span></code></pre>
