<p>Скорость разработки программы зависит не только от уровня разработчиков, но и от симантики кода, которая способна вывести из зоны комфорта даже бывалого специалиста. Понимая это <em>TypeScript</em> не перестает усовершенствовать систему типов стремясь сделать и без того <em>"говорящий код"</em> максималоно читаемым. Поэтому в версии <code class="inline-code">4.0</code> была добавлена возможность помечать элементы кортежа придовая им осмыслённость.</p>
<p>До текущей версии встретив кортеж наподобие <code class="inline-code">[string, number]</code> было совершенно не понятно что в дейтвительности представляют эти типы.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до версии 4.0</span>

<span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">p: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</span>) =></span> {}

<span class="hljs-comment">/**
 * автодополнение -> f(p: [string, number]): void
 * 
 * Совершенно не понятно что 
 */</span>
f0()</code></pre>
<p>Начиная с текущей версии безликим элементам кортежа стало возможно придавать осмысление за счет механизма добавления меток.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// начиная с версии 4.0</span>

<span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">p: [a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>]</span>) =></span> {};

<span class="hljs-comment">/**
 * автодополнение -> f(p: [a: string, b: number]): void
 * 
 * Теперь мы знаем что функция ожидает не просто 
 * строку и число, а аргумент "a" и аргумент "b",
 * которые в реальном проекте будут иметь более
 * осмысленное смысловое значение, например "name" и "age".
 */</span>
f1()</code></pre>
<p>Поскольку метки являются исключительной частью синтаксиса <em>TypeScript</em> они не имеют никакой силы в коде при деструктуризации массива представленного типом кортежа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">p: [a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>]</span>) =></span> {
    <span class="hljs-keyword">let</span> [c, d] = p;
};</code></pre>
<p>Единственное правило касающееся данного механизма заключается в том, что кортеж содержащий метки не может содеражть элементы описанные только типами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T = [a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>]; <span class="hljs-comment">// Error -> Tuple members must all have names or all not have names.ts(5084)</span></code></pre>
<p>Невозможно умолчать что данный механиз придется по нраву сообществу <code class="inline-code">react</code> поскольку помеченный кортеж придется как нельзя лучше при создании кастомных хуков. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>&#x3C;<span class="hljs-title">T</span>>(<span class="hljs-params">initialState: T</span>):[<span class="hljs-title">state</span>: <span class="hljs-title">T</span>, <span class="hljs-title">setState</span>: (<span class="hljs-params">state: T</span>) => <span class="hljs-title">void</span>]</span>;

<span class="hljs-comment">/**
 * автокомплит -> useState(initialState: number): [state: number, setState: (state: number) => void]
 * 
 * Даже в отсутствии комментариев известно
 * что именно предполагается в возвращаемом значении!
 */</span>
<span class="hljs-keyword">let</span> [state, setState] = useState(<span class="hljs-number">0</span>);</code></pre>
